/**************************************************************************/
/* FILE   **************          sisal.c          ************************/
/**************************************************************************/
/* Author: Patrick Miller January  1 2001                                 */
/* Copyright (C) portions 1989 Dave Gillespie                             */
/* Copyright (C) portions UC Regents                                      */
/**************************************************************************/
/*
 * $Log:
 */
/**************************************************************************/

#include "sisalInfo.h"

/**************************************************************************/
/* Copyright (C) 1989 Dave Gillespie, version 1.16.
 * This file may be copied, modified, etc. in any way.  It is not restricted
 * by the licence agreement accompanying p2c itself.
 */
/**************************************************************************/

/* Header file for code generated by "p2c", the Pascal-to-C translator */


/**************************************************************************/
/* FILE   **************          p2clib.c         ************************/
/**************************************************************************/
/* Author: Dave Gillespie                                                 */
/* Update: Dave Cann                                                      */
/* Update: Pat Miller -- Ansi compliance (extensive mods)                 */
/*                                                                        */
/* Copyright (C) 1989 Dave Gillespie                                      */
/* This file may be copied, modified, etc. in any way.  It is not restricted */
/* by the licence agreement accompanying p2c itself.                      */
/**************************************************************************/

/* Run-time library for use with "p2c", the Pascal to C translator */

/* "p2c"  Copyright (C) 1989 Dave Gillespie.
 */

#define SHORT int

#define unchar UNCHAR
typedef unsigned int unchar;
typedef void *Anyptr;



/* #include "p2c.h" */

/* #define LACK_LABS     */   /* Define these if necessary */
/* #define LACK_MEMMOVE  */





#define Isspace(c)  isspace(c)      /* or "((c) == ' ')" if preferred */




static int P_argc;
static char **P_argv;

static SHORT P_escapecode;
static int P_ioresult;


static Anyptr __MallocTemp__;

/* End. */
/* CANN 1/92 TO ALLOW FOR BIGGER LINE BUFFERS */
/* #define short int */
/* cann 5/29/90 */
#define fread(w,x,y,z) fscanf( z, "%d", w )



/* #ifdef M_XENIX  */ /* CANN 3/92 */ /* avoid compiler bug */
# define SHORT_MAX  (32767)
# define SHORT_MIN  (-32768)
/* #endif */


/* The following definitions work only on twos-complement machines */
#ifndef SHORT_MAX
# define SHORT_MAX  (((unsigned SHORT) -1) >> 1)
# define SHORT_MIN  (~SHORT_MAX)
#endif

#ifndef INT_MAX
# define INT_MAX    (((unsigned int) -1) >> 1)
# define INT_MIN    (~INT_MAX)
#endif

#ifndef LONG_MAX
# define LONG_MAX   (((unsigned long) -1) >> 1)
# define LONG_MIN   (~LONG_MAX)
#endif

#ifndef SEEK_SET
# define SEEK_SET   0
# define SEEK_CUR   1
# define SEEK_END   2
#endif

#ifndef EXIT_SUCCESS
# define EXIT_SUCCESS  0
# define EXIT_FAILURE  1
#endif


#define SETBITS  32


# define Signed
# define void       void
# ifndef Const
#  define Const
# endif
# ifndef Volatile
#  define Volatile
# endif

# define Inline

#define Register    register  /* Register variables */
#define Char        char      /* Characters (not bytes) */

#ifndef Static
# define Static
#endif

typedef Signed   char schar;
typedef unsigned char boolean;

#ifndef true
# define true    1
# define false   0
#endif


#define maxstringchars  1024

char blankstring[maxstringchars];

#define maxbigint       SHORT_MAX
/* Constants from setutl.m4 */
/* The maximum size of a set of integers */

#define maxsetsize      6000   /*mlw*/
/*#TITLE  IF1INIT CONSTANTS       Oct83   Standard IF1 Constants*/
/*Constants derived from v9.me 84/7/26 by sks*/
#define ifmaxnamelen    15   /* dlz -8/87 for the name tables */

/* CANN PEEK */ /* #define ifmaxnode       195 */
#define ifmaxnode       196  /* CANN PEEK */

/*Node */
#define ifnforall       0
#define ifnselect       1
#define ifntagcase      2
#define ifnloopa        3
#define ifnloopb        4
#define ifnifthenelse   5   /*mlw - 2/3/86*/
#define ifniter         6
#define ifnmodule       20   /* jwrg */
#define ifngraph        21   /* jwrg */
#define ifnaaddh        100
#define ifnaaddl        101
#define ifnaextract     102
#define ifnabuild       103
#define ifnacatenate    104
#define ifnaelement     105
#define ifnafill        106
#define ifnagather      107
#define ifnaisempty     108
#define ifnalimh        109
#define ifnaliml        110
#define ifnaremh        111
#define ifnareml        112
#define ifnareplace     113
#define ifnascatter     114
#define ifnasetl        115
#define ifnasize        116
#define ifnabs          117
#define ifnbindarguments  118
#define ifnbool         119
#define ifncall         120
#define ifnchar         121
#define ifndiv          122
#define ifndouble       123
#define ifnequal        124
#define ifnexp          125
#define ifnfirstvalue   126
#define ifnfinalvalue   127
#define ifnfloor        128
#define ifnint          129
#define ifniserror      130
#define ifnless         131
#define ifnlessequal    132
#define ifnmax          133
#define ifnmin          134
#define ifnminus        135
#define ifnmod          136
#define ifnneg          137
#define ifnnoop         138
#define ifnnot          139
#define ifnnotequal     140
#define ifnplus         141
#define ifnrangegenerate  142
#define ifnrbuild       143
#define ifnrelements    144
#define ifnrreplace     145
#define ifnredleft      146
#define ifnredright     147
#define ifnredtree      148
#define ifnreduce       149
#define ifnallbutlastvalue  150
#define ifnsingle       151
#define ifntimes        152
#define ifntrunc        153
#define ifnaprefixsize  154
#define ifnareplacen    160
#define ifnspawn        161
#define ifnfilter       168
#define ifnashift       169
/*IF2 Nodes*/
#define ifnaaddlat      170
#define ifnaaddhat      171
#define ifnabufpartition  172
#define ifnabuildat     173
#define ifnabufscatter  174
#define ifnacatenateat  175
#define ifnaelementsat  176
#define ifnaextractat   177
#define ifnafillat      178
#define ifnagatherat    179
#define ifnaremhat      180
#define ifnaremlat      181
#define ifnareplaceat   182
#define ifnarraytobuf   183
#define ifnasetlat      184
#define ifndefarraybuf  185
#define ifndefrecordbuf  186
#define ifnfinalvalueat  187
#define ifnmemalloc     188
#define ifnrbufelements  189
#define ifnrbuildat     190
#define ifnrecordtobuf  191
#define ifnrelementsat  192
#define ifnreduceat     193
#define ifnshiftbuffer  194
#define ifncondsetrefcnt  195

#define ifnpeek           196 /* CANN PEEK */

#define ifmaxerror      12
/*ErrorType */
/* genuine errors must be all < IFENoError */
#define ifebroken       0
#define ifeerror        1
#define ifemiselt       2
#define ifenegover      3
#define ifenegunder     4
#define ifeposover      5
#define ifeposunder     6
#define ifeundef        7
#define ifeunknown      8
#define ifezerodivide   9
#define ifenoerror      10   /*rky, means value present, not an error */
#define ifenovalue      11
    /*rky, means no value present, not even an error */
#define ifmrnovalue     12   /*dlz no min reeval previous value */
/*TypeTableEntry */
#define ifmaxtype       11
#define iftarray        0
#define iftbasic        1
#define iftfield        2
#define iftfunctiontype  3
#define iftmultiple     4
#define iftrecord       5
#define iftstream       6
#define ifttag          7
#define ifttuple        8
#define iftunion        9
#define iftwild         10
#define iftbuffer       11
/*BasicType */
#define ifmaxbasic      6
#define ifbboolean      0
#define ifbcharacter    1
#define ifbdouble       2
#define ifbinteger      3
#define ifbnull         4
#define ifbreal         5
#define ifbwild         6
/* types of reduction operations */
#define ifmaxreduction  5
#define ifrsum          0
#define ifrproduct      1
#define ifrleast        2
#define ifrgreatest     3
#define ifrcatenate     4
#define ifrappend       5
    /* rky 10dec84. AGather is just a kind of multiple reduction */
/* PARUTL TYPESApril 84Parameter Handling Constants*/
#define maxinfile       9

#define parflagchar     "-"
#define parsepchar      " "
#define parsplitchar    " "
#define parargchar      " "
/*dlz - 8/87 added new functions: NewTypeAlloc, NewEdgeAlloc, and
  NewNodeAlloc to consolidate and replace various allocation and
  initialization sequences throughout.  Also, made compilation
  of vivek's extra edge and node fields conditional.  Some new
  macros, etc. for simplification, fixed errors in some existing
  macro definitions, general "cleanup" and correction */
/* Constants from graph.m4 */
/* The number of the first Atomic node sort */

#define firstatom       100
/* The maximum number of Type Table Entries handled */
#define entrymax        1000
/* Constant for internal pragmas (for Vivek) */
#define extrainfomax    15
/* for Bit Marks set in node record */
#define maxbitrange     29
/*------------------- SEMANTIC ROUTINE CONSTANTS ---------------------*/
#define maxhashtable    90
#define hashtablesize   91
#define maxsemanticnumber  200
#define lbstartfunction  1
#define lbstartnamelist  2
#define lbaddtonamelist  3
#define lbstarttypelist  4
#define lbaddtotypelist  5
#define lbendglobalheader  6
#define lbendforwardglobheader  7
#define lbsmashintotable  8
#define lbinitsem       9
#define lbpushbasic     10
#define lbpushtypename  11
#define lbpusharray     12
#define lbfinishtypelinks  13
#define lbchecktypename  14
#define lblinkbase      15
#define lbpushstream    16
#define lbpushrecord    17
#define lbbuildfield    18
#define lbpushunion     19
#define lbbuildtag      20
#define lbpushnulltype  21
#define lbenddefinelist  22
#define lbaddtodefinelist  23
#define lbstartforwardfunct  24
#define lbstartglobalfunct  25
#define lbprocessparam  27
#define lbendfunctionheader  29
#define lbendfunctionlist  30
#define lbendfunction   31
#define lbstartsymlist  32
#define lbcheckatypes   33
#define lbcheckarity    34
#define lbassoctypes    35
#define lbincreasegenerator  36
#define lbcheckcross    37
#define lbexplicitcross  38
#define lbstartbody     39
#define lbendabody      40
#define lbmakeforall    41
#define lbfixforfunct   42
#define lbprocesstaghead  43
#define lbcreatetagsubgraph  44
#define lbchecktagnames  45
#define lbassocexprs    46
#define lbendtagcase    47
#define lbotherwisetag  48
#define lbstartforinit  49
#define lbendinitpart   50
#define lbpushwhile     51
#define lbpushuntil     52
#define lbstartatest    53
#define lbendtest       54
#define lbloopbassoclist  55
#define lbloopaassoclist  56
#define lbpushold       57
#define lbpushnoold     58
#define lbdoredright    59
#define lbdoredleft     60
#define lbdoredtree     61
#define lbdoreduce      62
#define lbdosum         63
#define lbdoproduct     64
#define lbdogreatest    65
#define lbdoleast       66
#define lbdocatenate    67
#define lbnoredop       68
#define lbdounlessexp   69
#define lbdowhenexp     70
#define lbnomaskingexp  71
#define lbdovalueof     72
#define lbdoarrayof     73
#define lbdostreamof    74
#define lbstartreturns  75
#define lbstartainitbody  76
#define lbendbody       77
#define lbendforinit    78
#define lbstartif       79
#define lbstartbtest    80
#define lbstartifsubgraph  81
#define lbendifsubgraph  82
#define lbendpredsubgraph  83
#define lbstartbinitbody  84
#define lbendif         85
#define lbbeforeexp     86
#define lbincboostfac   87
#define lbdecboostfac   88
#define lbreduceexp     89
#define lbpoppreclevel  90
#define lbafterexp      91
#define lbdofieldlist   92
#define lbpushnilttptr  93
#define lbstartrbuild   95
#define lbbuildfieldlist  97
#define lbendrbuild     98
#define lbstartabuild   99
#define lbstartsbuild   100
#define lbdolowerbound  101
#define lbendabuild     102
#define lbendsbuild     103
#define lbpushniltag    105
#define lbendubuild     106
#define lbpushemptyexplist  107
#define lbdofunctcall   108
#define lbdoarrayindex  109
#define lbdoarrayreplace  110
#define lbbuildreplace  111
#define lbdobinaryop    112
#define lbpopsymlist    113
#define lbbuildchar     114
#define lbfixfortag     115
#define lbbuilddouble   116
#define lbbuildint      118
#define lbbuildreal     120
#define lbcreateisunion  121
#define lbcheckold      122
#define lbpushuplus     123
#define lbpushuminus    124
#define lbpushunot      125
#define lbcreateiserror  127
#define lbpushnilcons   129
#define lbpushtruecons  130
#define lbpushfalsecons  131
#define lbpushintcons   132
#define lbpushrealcons  133
#define lbpushcharcons  134
#define lbpushstringcons  135
#define lbpusherrorcons  136
#define lbfindandpushname  137
#define lbopenllevel    138
#define lbendlevel      139
#define lbendforall     140
#define lbendprogram    141
#define lbpushdoubcons  142
#define lbendbbody      143
#define lbaftersimpexp  144
#define lbendtypedefs   145
#define lbpushdefarray  146
#define lbpushdefstream  147
#define lbpushdefrecord  148
#define lbpushdefunion  149
#define lbbuilddeffield  150
#define lbbuilddeftag   151
#define lbstarttypedefs  152
#define lbpreparefordot  153
#define lbstartnestedif  154
/* Type Name Key Word Terminal Values */
#define boolkw          21
#define charkw          23
#define doubkw          27
#define intgkw          41
#define nullkw          47
#define realkw          52
/*Type table labels for the basic types*/
#define boollabel       1
#define charlabel       2
#define doublabel       3
#define intlabel        4
#define reallabel       6
/*Type table codes for structured types*/
#define arraycode       0
#define fieldcode       2
#define recordcode      5
#define streamcode      6
#define tagcode         7
#define unioncode       9
/*CrossDotFlag constants*/
#define crossflag       1
#define dotflag         2
/* Smash into type table flags */

#define addtottable     true
#define noaddtottable   false

#define version         "1.8       "  /* Used as a String10 - pjm 1/88 */
#define compiled        "(Mar 28, 1989)"
/*    Compiled = '(unreleased version)';*/

/* #define maxlinelength   132 */
#define maxlinelength   40000  /* TOO SUPPORT THE C PREPROCESSOR */

#define maxprod         300
#define maxsym          300
#define maxstack        300
#define maxprodspace    4000   /* size of the array for storing productions */
#define maxstring       5000
/* !! constants for error correction phase */
#define maxinsertspace  2000
#define maxcorrection   20
#define maxterm         85
#define maximuminsert   maxcorrection
#define maxhisto        12   /* size of histogram array */
#define alphalength     12

#define blank           " "
#define tab             "\t"
#define newlinechar     blank
#define opendelete      "{"
#define closedelete     "}"

#define echooldline     false
#define scandebug       false
#define tracing         false
#define gorydetail      false
#define iedp            true   /* do we want Immediate detection property */
/*--------- all purpose constants --------------------*/

#define maxalphalength  75   /*for certain kind of string*/
/* local implementation restricts to 75 for file name */
/* ---------- template constants----------*/
#define tarraymax       500
/* --------- constants for scanning ----------*/
/* NonTerminal numerical identifiers */

#define tokentrace      false

#define numreswords     103
#define maxbackup       255   /* how far we might overscan */
#define andtoken        1
#define lparentoken     2
#define rparentoken     3
#define timestoken      4
#define plustoken       5
#define commatoken      6
#define minustoken      7
#define periodtoken     8
#define dividetoken     9
#define colontoken      10
#define assigntoken     11
#define semicolontoken  12
#define chartoken       13
#define stringtoken     14
#define integertoken    15
#define idtoken         16
#define realtoken       17
#define eqtoken         18
#define firstkeyword    19
#define lastkeyword     71
#define lbrackettoken   72
#define rbrackettoken   73
#define getoken         74
#define gttoken         75
#define letoken         76
#define lttoken         77
#define nottoken        78
#define netoken         79
#define stroketoken     80
#define cattoken        81
#define commenttoken    (-1)
#define eoftoken        83
#define escapetoken     83
#define doubtoken       82
#define incltoken       (-2)
#define backspace       8   /* ASCII code for backspace */
#define newline         10
#define blankord        32
#define tabord          9
#define fford           12

#ifndef _FNSIZE
# define _FNSIZE  120
#endif

/* The maximum number of Equivalence classes handled */

#define maxclass        1000

/* CANN ********** */
#define MAX_BBLOCKS 10000
#define MAX_SBLOCKS 10000

/* I/O error handling */
#define _CHKIO(cond,ior,val,def)  ((cond) ? P_ioresult=0,(val)  \
                                          : P_ioresult=(ior),(def))
#define _SETIO(cond,ior)          (P_ioresult = (cond) ? 0 : (ior))

/* Following defines are suitable for the HP Pascal operating system */
#define FileNotFound     10
#define FileNotOpen      13
#define FileWriteError   38
#define BadInputFormat   14
#define EndOfFile        30

staticforward Anyptr __MallocTemp__;
# define Malloc(n)  ((__MallocTemp__ = calloc(n,1)) ? __MallocTemp__ : (Anyptr)_OutMem())

/* #define FreeR(p)    (free((Anyptr)(p))) */    /* used if arg is an rvalue */
/* #define Free(p)     (free((Anyptr)(p)), (p)=NULL) */
#define MyFree(p)     (free((Anyptr)(p)), (p)=NULL)
#define Free(p)     ((p)=NULL)

/* sign extension */
#define SEXT(x,n)   ((x) | -(((x) & (1L<<((n)-1))) << 1))

/* packed arrays */   /* BEWARE: these are untested! */
#define P_getbits_UB(a,i,n,L)   ((int)((a)[(i)>>((L)-(n))] >> (((~(i))&((1<<((L)-(n)))-1)) << (n)) & ((1<<(1<<(n)))-1)))

#define P_getbits_SB(a,i,n,L)   ((int)((a)[(i)>>((L)-(n))] <<   \
                                       (16 - ((((~(i))&((1<<((L)-(n)))-1))+1) <<\
                                              (n)) >> (16-(1<<(n))))))

#define P_putbits_UB(a,i,x,n,L) ((a)[(i)>>((L)-(n))] |=   \
                                 (x) << (((~(i))&((1<<((L)-(n)))-1)) << (n)))

#define P_putbits_SB(a,i,x,n,L) ((a)[(i)>>((L)-(n))] |=   \
                                 ((x) & (1<<(1<<(n)))-1) <<   \
                                 (((~(i))&((1<<((L)-(n)))-1)) << (n)))

#define P_clrbits_B(a,i,n,L)    ((a)[(i)>>((L)-(n))] &=   \
                                 ~( ((1<<(1<<(n)))-1) <<   \
                                   (((~(i))&((1<<((L)-(n)))-1)) << (n))) )

/* small packed arrays */
#define P_getbits_US(v,i,n)     ((int)((v) >> ((i)<<(n)) & (1<<(1<<(n)))-1))
#define P_getbits_SS(v,i,n)     ((int)((long)(v) << (SETBITS - (((i)+1) << (n))) >> (SETBITS-(1<<(n)))))
#define P_putbits_US(v,i,x,n)   ((v) |= (x) << ((i) << (n)))
#define P_putbits_SS(v,i,x,n)   ((v) |= ((x) & (1<<(1<<(n)))-1) << ((i)<<(n)))
#define P_clrbits_S(v,i,n)      ((v) &= ~( ((1<<(1<<(n)))-1) << ((i)<<(n)) ))

#define P_max(a,b)   ((a) > (b) ? (a) : (b))
#define P_min(a,b)   ((a) < (b) ? (a) : (b))


/* Fix toupper/tolower on Suns and other stupid BSD systems */
#ifdef toupper
# undef toupper
# undef tolower
# define toupper(c)   my_toupper(c)
# define tolower(c)   my_tolower(c)
#endif
staticforward int my_tolower PROTO((int));
staticforward int my_toupper PROTO((int));

#ifndef z_toupper
# if 'A' == 65 && 'a' == 97
#  define z_toupper(c)  ((c)-'a'+'A')
#  define z_tolower(c)  ((c)-'A'+'a')
# else
#  define z_toupper(c)  toupper(c)
#  define z_tolower(c)  tolower(c)
# endif
#endif


#ifdef LINUX
/* Fix things on Linux */
#ifdef islower
#undef islower
#endif
#define islower(c) ((c) >= 'a' && (c) <= 'z')
#ifdef isupper
#undef isupper
#endif
#define isupper(c) ((c) >= 'A' && (c) <= 'Z')
#ifdef isspace
#undef isspace
#endif
#define isspace(c) ((c) == ' ')
#ifdef isdigit
#undef isdigit
#endif
#define isdigit(c) ((c) >= '0' && (c) <= '9')

#endif

#define stackbucketsize  50

#define tab_            9
#define maxnamelen      5
#define commtablesize   80
#define commtablemax    79   /* CommTableSize - 1 */
#define intlistlen      50

#define backspace_      8
#define tabord_         9
#define formfeed        12
#define MAX_NAMES 200



/* -----------------------------------------------

  #####   #   #  #####   ######   ####
    #      # #   #    #  #       #
    #       #    #    #  #####    ####
    #       #    #####   #            #
    #       #    #       #       #    #
    #       #    #       ######   ####
    
 ----------------------------------------------- */
/*  global types here */
/*#TITLE  STRUTL  TYPES           Jan82   String Handling Routines.*/
typedef struct {
    Anyptr proc, link;
} _PROCEDURE;

typedef Char stryngar[maxstringchars];

typedef struct stryng {
  int len;
  stryngar str;
} stryng;

typedef Char str10[10];
typedef Char str20[20];
/* Types from setutl.m4 */
typedef unchar bitbucket[(maxsetsize + 7) / 8];   /*mlw*/
/*mlw*/

typedef struct setofint {
  SHORT count;   /* number of elements in the set */
  SHORT maxsize;   /* max numb of elements set can hold */
  bitbucket inset;   /* bit vector, true means ele in set */
} setofint;

/*#TITLE  IF1INIT TYPES             IFNAug83   Standard IF1 Types*/
/* Printable Name */
typedef Char printable[16];
/* Nodes */
/* Error Values */
/* Type Values */
/* Basic Values */
/* Types for reduction operations */
typedef enum {
  ifgfunction, ifgselector, ifgalternative, ifgvariant, ifgloopainit,
  ifgloopabody, ifgloopatest, ifgloopareturns, ifgloopbinit, ifgloopbbody,
  ifgloopbtest, ifgloopbreturns, ifgforallgenerator, ifgforallbody,
  ifgforallreturns, ifgifpredicate, ifgiftrue, ifgiffalse, ifgiterbody
} ifgraphtype;
/*dlz - 8/87*/
typedef enum {
  unaryalgeb, binaryalgeb, multiplereduct, multiplefilter, multiplegenr,
  structureaccess, structurebuild, indexchange, bufferaccess, bufferbuild,
  bufferreduct, buffergenr, bufferdefine, controlabstr, functioninvoke,
  graphnode, unclassified, unknown
} ndclasstype;
/*#TITLE  PARUTL  TYPES           Jan82   Parameter Handling Routines.*/
typedef enum {
  intpar, boolpar, strpar, ifilpar, ofilpar, flagpar, restpar
} partyp;
typedef struct parrec *infilelist[maxinfile];

typedef struct parrec {
  str10 longname, shortname;
  partyp partype;
  int normpos, specpos;
  stryng parvalue;
  struct parrec *nextpar;
} parrec;

/* Types from graph.m4 */
/* Type Table Entries
      STId -a special value used for dumping out if1 programs and
              for checking multiple definitions.
      STLabel - The label of the IF1 type entry.  Also used for type
                smashing.
      STEquivChain - Used for type smashing.
      STLiteral - The name of the type (if there is one).
      STSize - Amount of memory an object of this type requires. Used
               in IF1offset.
      STRecurFlag - Whether or not this type is recursive.
*/

typedef struct stentry {
  int stid, stlabel;   /*sks*/
  struct stentry *stequivchain;   /*sks*/
  stryng stliteral;   /*mlw*/
  int stsize;
  boolean strecurflag;   /*jef 10/1/85*/
  char stsort;
  union {
    char stbasic;
    struct {
      struct stentry *starg, *stres;
    } U3;
    struct stentry *stbasetype;
    struct {
      struct stentry *stelemtype, *stnext;
    } U2;
  } UU;
} stentry;

typedef double extrainfo[extrainfomax];   /*for vivek*/
/* Ports
   Each node has a list of input and output ports.  A single structure is
   used for Literals and Edges.  Edges have some extra fields descibing
   the source Port.  The fields are used as follows:
     PTType - points to a symbol table entry giving the type of the
                port.
     PTToNode - points to the node which is destination of the edge or
                literal.
     PTToPort - gives the number of this port.
     PTToNext - points to the next input port for the destination node.
     PTName - gives the symbolic name associated with this edge (if avail.)
     PTIF1Line - the line number of the if1 file that defined this edge.
     PTSrcLine - the line number of the SISAL text file where this edge is
                 created.
     PTWiLine - the column of the SISAL text file where this edge is
                 created.
     PTId - Global ID for this edge.  Does not correspond to anything in
            the IF1 test file.
     PTMark - ByValue, ByReference or Destroy pragma.
               Destoy means this is the last reference and the value may be removed.
     PTDFAddr - AR offset pragma.
     PTLBound, PTUBound - lower and upper bound pragma.
     PTNextEdge - Used by DI for associating similar edges.
     PTClass - ???
   Extra fields for Edges:
     PTFrNode - points to the origin node.
     PTFrPort - indicates the number of the output port.
     PTFrNext - points to the next output port for the origin node.
   Extra fields for Literals:
     PTLitValue - value of the literal edge stored in Stryng format.
 */
typedef enum {
  byref, byval, destroy
} egmark;   /***NEW** no ByDefault*/
typedef enum {
  ptlit, ptedge, ptdep, ptundef
} portsort;
typedef enum {
  pcuncoded, pccoded
} portclass;
/*mlw - more descriptive name*/

typedef struct port {
  stentry *pttype;
  struct node *pttonode;
  int pttoport;
  egmark ptmark;   /*mlw  - pass by value or reference */
  int ptif1line;   /* sks for structure analysis reporting */
  int ptsrcline, ptwiline;
  struct port *pttonext;
  stryng ptname;   /*mlw*/
  int ptid;   /*mlw*/
  int ptlbound, ptubound;   /* mlw, lower and upper bounds pragmas */
  int ptsetrc, ptconmodrc, ptprodmodrc;
      /* rjs, set & modify ref count pragmas */
  int ptdfaddr, ptmraddr;   /* dlz, for MinReeval offsets */
  struct port *ptnextedge;
  portclass ptclass;
  portsort ptsort;
  union {
    struct {
      struct node *ptfrnode;
      int ptfrport;
      struct port *ptfrnext;
    } U1;
    stryng ptlitvalue;
  } UU;
} port;

/* Graphs
   Each compound node has a list of subsidiary graphs. Each graph is
   accessed via the special Graph node.
 */

typedef struct graph {
  struct node *grnode;
  struct graph *grnext;
} graph;

/* Nodes
    Nodes are either Simple nodes, Compound nodes, or Graph nodes.
    Further, a Graph node may be a Function graph (in which case it
    has an associated Linkage record) or a subgraph of a compound node.
    NDId - A global identifier with no counterpart in IF1 text files.
    NDCode - The opcode of this node, e.g. IFNPlus, IFNSelect, IFNGraph.
    NDMisc - an integer (or set of bits) for miscellaneous use.
    NDLabel - Label of the node within a graph.  Graph nodes always have
              a label of zero.
    NDLine - Line number in the IF1 text file where this node was defined.
    NDSrcLine - Line number within the SISAL text file that defined this
                node.
    NDWiLine - column number in SISAL text file where this node was defined.
    NDXCoord, NDYCoord - (X,Y) coordinate pargmas
    NDParent - If the node is Simple or Compound then Parent is the
               graph node corresponding to the graph immediately containing
               this node.  If the node is a Graph node representing a
               subgraph of a compound node the Parent is the compound
               node.If the node is a Function graph node then the
               parent is the dummy compound node called "Module".
    NDNext - The nodes of a graph are connected in a linked list.  This
             field points to the next node in the list.  The NDNext
             fields of Graph nodes point to the first (simple or compound)
             node of the graph it defines.
    NDNextInLine - A pointer to the next node of the IF1 graph that
                   came from the same source line.  Used by DI.
    NDIList - A pointer to the list of input edges of the node.  CAUTION:
              No fan-in is allowed.  Therefore, the input edges of a
              GRAPH node are the edges where the values LEAVE the graph.
    NDOList - A pointer to the list of output edges of the node.  On a
              GRAPH node, these are the edges where values ENTER the graph.
    NDDepIList - A pointer to the list of dependence edges that are input
              to the node.  NOTE: there can be fan-in of dependence edges.
              The input port of all dep edges is port 0.
    NDDepOList - A pointer to the list of dependence edges that are output
              by the node.  The output port of all dep edges is port 0.
 Fields for Graph nodes only:
    NDLink - A pointer to the Linkage record if this node represents a
             function graph node.
    NDType - A pointer into the type table used only for Function graph
             nodes.  Subgraphs of Compound nodes have a nil type.
 Fields for Compound nodes only:
    NDSubsid - a pointer to a list of subgraphs.
    NDAssoc - a pointer to an association list used to associate tag
              numbers with subgraphs of a TAGCASE nodes.
*/

typedef struct assoclist {
  int graphnum;
  struct assoclist *next;
} assoclist;

typedef enum {
  ndatomic, ndgraph, ndcompound, ndundef
} nodesort;

typedef union intbitset {
  int numb;
  long bits;
} intbitset;

typedef struct node {
  int ndid, ndcode;
  intbitset ndmisc;   /* dlz (new) -- for miscellaneous uses */
  int ndlabel;   /* sks for structure analysis reporting */
  int ndline;   /* sks for structure analysis reporting */
  int ndsrcline, ndwiline;   /* mlw, Source Line and Within Line markers */
  int ndxcoord, ndycoord;   /* mlw, X and Y coordinates - graphics */
  struct node *ndparent, *ndnext;
  port *ndilist, *ndolist, *nddepilist, *nddepolist;
  struct node *ndnextinline;
  double ndfrequency;   /*rjs, pragma for vivek */
  int ndexpanded;   /* rjs, pragma for vivek */
  nodesort ndsort;
  union {
    struct {
      struct linkrec *ndlink;
      stentry *ndtype;
      int ndfirstmro, ndlastmro;   /* dlz, added for MR */
    } U1;
    struct {
      graph *ndsubsid;
      assoclist *ndassoc;
    } U2;
  } UU;
} node;

/* Linkage Records
   Each Function in a compilation unit has a record associating the
   appropriate Graph node with a string used to identify the function
   in literals.
   LKSort - Is it a static (G), Imported (I), or Exported (X) function.
   LKGraph - a pointer to the Function graph node.
   LKName - The name of the function.
   LKModuleName - Name of the Module this function resides in
   LKARSize - Number of DATUMS in an AR for this function (pragma).
   LKMRSize - Number of Datums in an MRV for this function (someday a pragma?)
   LKExpand - Marked to be expanded inline or not (pragma).
   LKARIndex - a field for DI internal use.
   LKNext - pointer to the next linkage record in this module.
 */
typedef enum {
  lslocal, lsimported, lsexported
} linksort;

typedef struct linkrec {
  linksort lksort;
  node *lkgraph;
  stryng lkname, lkmodulename;
  int lkarsize;   /*mlw - Size of activation record for this fun*/
  int lkmrsize;   /*dlz - Size of MR value record for this fun */
  boolean lkexpand;   /*mlw - Is this function inline expandable? */
  int lkarindex;
  struct linkrec *lknext;
} linkrec;

/* a more descriptive name for pointers to type table
                     entries.  JEF */
/*------------------ POINTERS ------------------------------------------*/
/* -------------- TYPES OF LEXICAL LEVELS THAT EXIST ------------------- */
typedef enum {
  forloop, specfa, let, funct, tagcase, initloop, ifcomp, root, nestedifcomp
} lexleveltype;
/* -------------- TYPES OF SYMBOL TABLE OBJECTS THAT EXIST ------------- */
typedef enum {
  ttype, tglobal, tfunction, tforward, tvariable, tparam, tpredefined, none
} identtype;
/* Variants rec types that occur on the undef pointer list of symbol
   tabel entried for type names.*/
typedef enum {
  typetag, symtag
} torntype;
/* Flag to denote what type of reduction node is to be places in the
   returns graph of a for loop */
typedef enum {
  rfnone, rfsum, rfproduct, rfgreatest, rfleast, rfcatenate
} reduceflag;
/* List of predefined functions that exist so a case statement can be
   used to distiguish them. */
typedef enum {
  nopredef, tgabs, tgarrayaddh, tgarrayaddl, tgarrayadjust, tgarrayfill,
  tgarraylimh, tgarrayliml, tgarrayprefixsize, tgarrayremh, tgarrayreml,
  tgarraysetl, tgarraysize, tgexp, tgfloor, tgmax, tgmin, tgmod,
/* CANN PEEK */ tgpeek,
  tgstreamappend, tgstreamempty, tgstreamfirst, tgstreamprefixsize,
  tgstreamrest, tgstreamsize, tgtrunc
} predeftype;
/* Flag to denote whether the test boolean in a forinit loop should be
   negated or not */
typedef enum {
  neitherloop, whileloop, untilloop
} testflagtype;
/* Flag to denote whether a pragma is to be processed by the first pass
   of the compiler or not */
typedef enum {
  pother, pinclude
} pragmaname;
/* Flags to denote the status of a loop variable at a given time */
/* not a loop var */
/* is a loop variable */
/* is a loop constant */
/* appears in the init part, could end a LVar or a
           LConst */
typedef enum {
  lnone, lvar, lconst, linit, lbinit
} loopvarflags;
/* appears in the init part of a LoopB, set to
           a LBInit before the test and to an LInit after
           the test.  This is so it cannot be used with
           the old modifier in the test clause */
/* Flag to tell AssignPorts with it is to assign the to or from port of
   the given edge. */
typedef enum {
  noport, toport, fromport
} toorfromtype;
typedef enum {
  truetag, falsetag, errortag
} tagflag;

typedef struct defrec {
  /* Definition lines for names in the source code */
  int fline, fcolumn, sline, scolumn;
} defrec;

typedef struct reflist {
  /* List items for refernces of names in the source code */
  int line, column;
  struct reflist *nextref;
} reflist;

typedef struct refrec {
  /* List pointers for the references list */
  reflist *front, *back;
} refrec;

typedef struct edgelist {
  /* Items for the list of edges to be assigned the */
  port *edge;   /* same port number.  ToOrFrom denotes whether the */
  toorfromtype toorfrom;   /* to port ot from port is to be filled in. */
  struct edgelist *next;
} edgelist;

typedef struct edgelisthead {
  /* list structure for the lists of edges */
  stryng edgename;   /* Edges name, used to find it on the list */
  edgelist *edges;   /* List of edges */
  struct edgelisthead *next;
} edgelisthead;

/* holds infomation as to where name exists in the graph at any given time.
   Used in the symbol table, by AddEdge to connect edges from one place to
   another and as a way to say this information on the semantic stack. */

typedef struct inforecord {
  node *node_;   /* node value comes from */
  int port_;   /* port value comes from */
  stentry *typeptr;   /* type of value */
  stryng name;   /* name of value */
  stryng litvalue;   /* value if it is a literal, then no node or port*/
  edgelisthead *onlist;   /* If port isn't assigned yet, this points to */
} inforecord;   /* the edge list the value is on */

/*  This record holds information used in creating a Tagcase node.
    It mimicks the type structure of a union so info on the tagnames
    found and the subgraphs they are associated with can be saved.*/

typedef struct tcstacklistrec {
  stryng tagname;
  int sgnum;
  stentry *typeptr;
  struct tcstacklistrec *next;
} tcstacklistrec;

/*  This record hold information for the cross reference that can be printed
    at the end of a function.  Since there may be internal scope within a
    function, as these scope are exited information about there identifiers
    are placed in these reords which are then stored in a large array by
    alphabetical order.*/

typedef struct xrefrec {
  stryng name;
  reflist *refs;
  defrec *defs;
  stentry *typeptr;
} xrefrec;

/* ------------------ SYMBOL TABLE ENTRIES ---------------------------- */

typedef struct symtblbucket {
  stryng name;
  defrec *defloc;
  refrec *references;
  stentry *typeptr;
  inforecord *graphinfo;
  /* info as to where this name currently
                                        is in the graph */
  struct symtblbucket *nextbucket;
  boolean importedflag;
  /* has name been pulled into this
                                        scope from an outer scope or was
                                        it defined in this scope? */
  identtype identtag;
  union {
    struct tornrec *undeftypeptrs;
    struct {
      /* List of places in type table and
         symbol table to fill in when this
         type name is defined.  Types can
         be refernced before they are
         defined.  */
      loopvarflags *loopflag;   /*see LoopVarFlags*/
      boolean tflag;   /*Denotes a loop Temporary*/
      inforecord *oldfrom;   /*Old value information*/
      boolean redefflag;   /*been redefined?*/
    } U4;
    predeftype predefined;   /*see PreDefType*/
  } UU;
} symtblbucket;

/* ------------------------ LEX LEVEL OBJECTS --------------------------- */

typedef struct treestackobj {
  symtblbucket *hashtable[maxhashtable + 1];
  node *prevnode;
  /* Last node in the node chain, connect the next
                               one to this one. */
  node *currentsubn0;
  /* Node pointer for the current subgraph being
                               constructed. */
  int nodecounter;   /* Node count for the current subgraph */
  struct treestackobj *lastlevel, *nextlevel;
  lexleveltype lleveltag;
  union {
    struct {
      edgelisthead *kflist, *mflist, *tflist;
      /* List of ports to be assigned after loop is complete.  */
      node *forallnode;   /* ptr to Compound Node*/
      inforecord *lowerbound;
      /* Infomation for the lower bound
                                      if an array is returned */
      int crossdotflag;
      /* flag to make sure dots and
                                      crosses aren't mixed */
      boolean crossdoterror;   /* dots and crosses were mixed */
      node *returnn0, *bodyn0;
      int bodynodecount, returnnodecount;
      node *bodyprevnode, *returnprevnode;
      int bodyoutputportnum;
      /* Above variables allow construction of both the
         body and returns graphs to occur at once.  A
         "context switch" is done between the two.  */
      int freturnportnum;   /* count of output ports */
    } U0;
    struct {
      edgelisthead *kilist, *lilist, *tilist;
      /* List of ports to be assigned after loop is complete.*/
      node *initnode;   /* ptr to Compound Node */
      int ireturnportnum;   /* count of output ports */
    } U5;
    struct {
      int ktport;   /* Count of KPorts */
      node *tagcasenode;   /* ptr to compound node */
      struct typelistrec *tarmreturnstype;
    } U4;
    struct {
      /* types or values returned, used to
         make sure all arms return the same
         types */
      int kiport;   /* Count of KPorts */
      node *ifnode;   /* ptr to compound node */
      struct typelistrec *iarmreturnstype;
    } U8;
    /* types or values returned, used to
       make sure all arms return the same
       types */
    symtblbucket *lfunctname;   /*Sym Tab entry for the funct */
  } UU;
} treestackobj;

typedef enum {
  nulltype, booltype, intgtype, realtype, doubtype, chartype
} basictypes;
typedef enum {
  noop, orop, andop, mult, divd, plus, minus, concat, lt, le, gt, ge, equal,
  notequal, uplus, uminus, unot
} opertype;
/*------------------  SEMANTIC ERROR TYPES -------------------------------*/
typedef enum {
  fndoubdef, tnameundef, fieldnameddef, tagnameddef, defineerr, doubledefarg,
  forwardtype, innerfndoubdef, binaryoparity, chararity, doublearity,
  intarity, realarity, binarytypesnoteq, charitype, doubleitype, intitype,
  realitype, binarytypeerr, typefunctres, numfunctres, asstypeclash,
  vardoubledef, longexplist, longnamelist, vardoubledecl, vnameundef,
  undeffunct, typefunctarg, numfunctarg, unaryoparity, unarytypeerr,
  vnamenotloopvar, arityonerror, arityonisu, isutype, expimporterr,
  arityonrbuild, typeonrbuild, forwardnotresolved, arityonubuild, tnonubuild,
  undeftagub, typeclashub, lbarity, lbtype, notypeabuild, atypenameerr,
  notarraytype, arraytypeclash, abuildelemtype, arityonrselect, etypeonrs,
  nameundrs, ntypeonrs, arityonrexp, arityonoexp, ntyperr, nameundrr,
  typeclashrr, ifreturnstypes, tagreturnstypes, numifreturns, numtagreturns,
  prednotbool, predarity, nothingsc, typenssc, expsnstypesc, typeclashsc,
  undefntag, arityontag, typenutc, nameundeftc, ddtname, typesnsametc,
  othernone, notalltc, arrayarity, needarraytype, indexexperr, arityareplace,
  typeareplace, replaceoverdim, replaceelemtype, valueofarity, maskingarity,
  masknotbool, arityonfa, typeonfa, atinrg, reducetype, arrayofarity,
  streamofarity, icnotas, cdmix, decbutnotdef, lvarnotdef, testarity,
  testnotbool, lvarusebredef, loopcvmix, loopconsassn, redefimlvar,
  lvarneverredef, deflistnotempty, typedoubdef
/* p2c: mono.bin.noblank.p, line 1257: Note:
 * Line breaker spent 4.5+1.02 seconds, 5000 tries on line 1012 [251] */
} errortypes;

typedef struct errorrecord {
  int linenumber, column;
  errortypes etype;
  union {
    stryng errorstr;
    opertype op;
    stentry *typeptr;
    struct {
      stentry *btypeptr;
      opertype bop;
    } U18;
    struct {
      stentry *utypeptr;
      opertype uop;
    } U31;
    struct {
      stryng functname;
      int resnum;
    } U19;
    struct {
      stentry *exptype, *nametype;
    } U21;
    struct {
      stryng varname;
      stentry *exp1type, *exp2type;
    } U25;
    struct {
      stryng functionname;
      int argnum;
    } U29;
    int elemnum;
    int expnum;
    struct {
      stentry *redtype;
      reduceflag redflag;
    } U91;
  } UU;
} errorrecord;

/*---------------  RECORDS FOR BUILDING LISTS  -----------------------*/
/*  This record is used to build lists of identifiers.  It holds the line
    number where the id is found and the column (which is not currently
    used).  */

typedef struct namelistrec {
  stryng name;
  struct namelistrec *next, *prev;
  int linenum, column;
} namelistrec;

/*  This record is used to build lists of Type Table pointers.  */

typedef struct typelistrec {
  stentry *typeptr;
  struct typelistrec *next, *prev;
  int linenum;
} typelistrec;

/*  This record is used to build a list of type table and symbol table
    points.  The list is kept in a symbol table entry for a type name.
    When the structure for the type name is  then list is searched
    and the new type structure is associated with the list entries.*/

typedef struct tornrec {
  struct tornrec *next, *prev;
  torntype torntag;
  union {
    stentry *ttptr;
    symtblbucket *symptr;
  } UU;
} tornrec;

/*  This record is used to build lists of "graph information".  For instance
    it is used to place expressions of any arity on the semantic stack.  The
    expression is represented as a list of graph locations.*/

typedef struct explistnode {
  inforecord *graphinfo;
  struct explistnode *next;
} explistnode;

/*  This record is used to build lists of Symbol Table entries.*/

typedef struct symlistnode {
  symtblbucket *sym;
  struct symlistnode *next;
} symlistnode;

/*------------- SEMANTIC STACK STRUCTURES ------------------------------*/
typedef enum {
  tgnamelist, tgtypelist, tgttptr, tgsymptr, tgexplist, tgpreclevel,
  tgsymlist, tgnodeptr, tgsubgraphnum, tgoldflag, tgreduceflag, tgrednodetype,
  tgtestflag, tgtcstacklist
} typesemanticdata;

typedef struct semanticrec {
  struct semanticrec *next;
  typesemanticdata tag;
  union {
    namelistrec *namelist;
    typelistrec *typelist;
    stentry *ttptr;
    symtblbucket *symptr;
    explistnode *explist;
    struct {
      int preclevel, column, line;
      opertype operation;
    } U5;
    symlistnode *symlist;
    node *nodeptr;
    int subgraphnum;
    boolean oldflag;
    reduceflag redflag;
    int rednodetype;
    testflagtype testflag;
    tcstacklistrec *tcstacklist;
  } UU;
} semanticrec;

/*--------------- DEBUGGER TYPES  -------------------------------------*/
typedef Char alpha[alphalength];

typedef struct stringrec {
  unsigned start : 13, length : 13, foo : 2;   /* kluge !!! */
} stringrec;

typedef Char linebuffer[maxlinelength + 1];

typedef struct inputbuffer {
  linebuffer buf;
  stryng inputfile;
  struct inputbuffer *next;
  Char *underline;
  unchar pointer, length;
  int lineno;
  unsigned modified : 1, lastline : 1;
} inputbuffer;

typedef struct rabrec {
  /* ReadAhead Buffer records */
  unsigned token : 7;
  struct rabrec *next;
} rabrec;

/* !! type for error correction phase */

typedef struct insertstringrec {
  int first : 11, last : 11, cost : 31;
} insertstringrec;

typedef struct prodrec {
  /* one production in the grammar */
  unsigned start : 12;   /* pointer into production space */
  int length : 12;   /* number of symbols in uction */
} prodrec;

typedef struct stagerec {
  /* insertion in progress */
  int cost : 31;
  char string[maxcorrection + 1];
  int length : 5;
} stagerec;

typedef struct ptabrec {
  Signed int term : 10;
  unsigned pact : 12;
  struct ptabrec *next;
} ptabrec;

typedef insertstringrec pretabarray[maxsym + 3];
/* ------------- types for handling stringspace ------------*/

typedef struct extstringspace {
  struct extstringspace *nextextent;
  Char string[maxstring + 1];
} extstringspace;

typedef union stringptrklugerec {
  /*allows us to put the size of
                                        stringspace into record for writing to file */
  int strlength;
  extstringspace *ptr;
} stringptrklugerec;

/*------------ types for message handler --------------*/
typedef enum {
  cmdunavailable, numtoobig, badrealnum, unclosedstring, overlap, opencomment,
  ctrlcharinstring, badsymbol, nomessage, nondeletable, ppromptmess,
  tooshallow, toohigh, cantputtree, copymess, oldfileexists, cantelide,
  notelided, lastcmd, prexpansion, cantundo, reallyzap, noundo, noredo,
  ttytype, notermfile, filemessage, nofilename, nosuchfile, nametoolong,
  wrotefilemessage, cantwrite, chngdquit, chngdread, reachedeof, reachedbof,
  invalidcmd, nonterminalrequired, nonexpandable, cantcontinue,
  nomoreexpansions, nondelterminal, terminalrequired, syntaxerror,
  deletedtoken, nosemanticroutine, headermess, inputmode, namenotfound,
  notreethere, nolasttree, insrtmess, deletemess, assumeno, execmess,
  noexecmess, nodefnofid, predefid, retrnfromdefn, elidedid
/* p2c: mono.bin.noblank.p, line 1257: Note:
 * Line breaker spent 5.3+0.56 seconds, 5000 tries on line 1212 [251] */
} messagecode;
/* *** types for scanner *** */
typedef enum {
  compareless, compareequal, comparegreater
} comparetype;

typedef enum {
  charerr
} errtype;
/* *** types for attributes *** */
/*----------types for pretty-print templates----------*/
/*type for templates */
/*-------- Super Rec, able initialize large tables in a single read */

typedef struct tablerec {
  long digits[9];
  long idcharset[9];
  stryng resword[maxsym + 3];
} tablerec;

typedef struct includestackrec {
  stryng fname;
  rabrec *readaheadbuf;
  int linenumber;
  struct includestackrec *next;
} includestackrec;




union sblock {
  graph g;
  assoclist al;
  defrec    dr;
  reflist   rl;
  refrec    rr;
  edgelist  el;
  typelistrec tlr;
  explistnode eln;
  symlistnode sln;
  semanticrec sr;
  };

union bblock {
  node n;
  port p;
  stentry i;
  inforecord ir;
  symtblbucket sb;
  edgelisthead elh;
  namelistrec  nlr;
  parrec       pr;
  linkrec      lr;
  };

typedef union bblock BBLOCK, *PBBLOCK;
typedef union sblock SBLOCK, *PSBLOCK;

/* local variables for smashtypes: */
struct LOC_smashtypes {
  int lastclass;
  stentry *classtable[maxclass + 1];
  stentry *lastinclass[maxclass + 1];
} ;

/* local variables for dumpprogram: */
struct LOC_dumpprogram {
  FILE *diag;
} ;

typedef Char commandname[maxnamelen];
/*List all function*/
/*List all nodes*/
/*Name current function*/
/*Goto node with Id*/
/*List input edges*/
/*List commands*/
/*Move left*/
/*display loop depth*/
/*Move right*/
/*Goto node with label*/
/*Show Current Graph*/
/*List nodes with given opcode*/
/*List all nodes with opcode (recursive)*/
/*Goto next node*/
/*List output edges*/
/*Goto parent*/
/*Shop which graph ports effect node*/
/*Show current position*/
/*Quit*/
/*Goto given subgraph*/
/*Show type*/
/*Show Nodes Above*/
/*Show Nodes Below*/
/*Display node record*/
/*Display input edge record*/
/*Display output edge record*/
/*Display input dependence edge records*/
/*Display output dependence edge records*/
/*Display all input edges*/
/*Display all output edges*/
typedef enum {
  cclisallfun, cclisallnodes, ccfunction, ccnodeid, cclisinedges, cchelp,
  ccleft, cclooplevel, ccright, ccnodelabel, ccgraph, cclisnodeswop,
  ccrecfind, ccnextnode, cclisoutedges, ccparent, ccgraphports, ccposition,
  ccquit, ccsubgraph, ccdisptype, ccnodesabove, ccnodesbelow, ccdumpnode,
  ccdumpinput, ccdumpoutput, ccdumpdepinput, ccdumpdepoutput, ccdumpallinput,
  ccdumpalloutput, ccshowtable
} commandtype;   /*Display hash table*/
/* p2c: mono.bin.noblank.p, line 8579: Note:
 * Line breaker spent 1.7+0.30 seconds, 1907 tries on line 9972 [251] */

typedef struct commandrec {
  boolean empty;
  commandname name;
  commandtype commvalue;
} commandrec;

/* local variables for graphwalk: */
struct LOC_graphwalk {
  commandrec commandtable[commtablemax + 1];
  long blankchars[9];
} ;

/* local variables for initcommandtable: */
struct LOC_initcommandtable {
  struct LOC_graphwalk *LINK;
} ;

/* local variables for getvalidcommand: */
struct LOC_getvalidcommand {
  struct LOC_graphwalk *LINK;
} ;

/* local variables for findnodes: */
struct LOC_findnodes {
  struct LOC_graphwalk *LINK;
  boolean recursive;
} ;

typedef struct symlistobj {
  symtblbucket *entry_;
  struct symlistobj *next;
} symlistobj;


/* local variables for dopredefined: */
struct LOC_dopredefined {
  int line;
} ;

/* local variables for printtable: */
struct LOC_printtable {
  symlistobj *frontl, *backl;
} ;

typedef struct ilistrec {
  inforecord *graphinfo;
  struct ilistrec *next;
} ilistrec;

typedef struct plistrec {
  int position;
  struct plistrec *next;
} plistrec;


typedef struct trec {
  node *node_;
  struct trec *next;
} trec;


/* local variables for removegraphcse: */
struct LOC_removegraphcse {
  trec *table[ifmaxnode - firstatom + 1];
} ;

typedef struct ndptrelmlist {
  node *elem;
  struct ndptrelmlist *next;   /*NDPtrelmlist*/
} ndptrelmlist;

typedef struct ndptrreclist {
  int length;
  ndptrelmlist *listhd, *listtl;
} ndptrreclist;

/* local variables for scan: */
struct LOC_scan {
  Char ch;
  boolean done;
} ;

/* local variables for findloopconstants: */
struct LOC_findloopconstants {
  node *n, *initg, *testg, *bodyg, *retg;
  int port_;
  port *inite;
} ;

/* local variables for pass1: */
struct LOC_pass1 {
  stryng fname;
  FILE *outfile;
} ;

/* local variables for dissectpragma: */
struct LOC_dissectpragma {
  struct LOC_pass1 *LINK;
  int linenum;
  pragmaname *pname;
} ;

/* static variables for fixreturnsgraph: */
struct LOC_fixreturnsgraph {
  node *loop, *geng, *bodyg, *retg, *initg, *testg, *loopparent;
  int k, l, t, port_;
  port *e;
  boolean isforall;
} ;



typedef struct intlist {
  char length;
  int element[intlistlen];
} intlist;

typedef struct nodebucket {
  struct nodebucket *prev, *next;
  node *elems[stackbucketsize];
} nodebucket;

typedef struct ndstack {
  int length;
  nodebucket *firstbucket, *lastbucket;
} ndstack;




/* -----------------------------------------------
 ######   ####   #####   #    #    ##    #####   #####
 #       #    #  #    #  #    #   #  #   #    #  #    #
 #####   #    #  #    #  #    #  #    #  #    #  #    #
 #       #    #  #####   # ## #  ######  #####   #    #
 #       #    #  #   #   ##  ##  #    #  #   #   #    #
 #        ####   #    #  #    #  #    #  #    #  #####   
 ----------------------------------------------- */
staticforward void    PASCAL_MAIN  PROTO( (int, Char **) );
staticforward Char    **P_argv;
staticforward int     P_argc;
staticforward SHORT   P_escapecode;
staticforward int     P_ioresult;
staticforward void CANN_exit PROTO((int));


/* staticforward Anyptr   malloc      PROTO( (size_t) ); */
/* staticforward void     free        PROTO( (Anyptr) ); */

/* staticforward int      _OutMem     PROTO((void)); */
staticforward Anyptr   _OutMem     PROTO((void));

staticforward int      _Escape     PROTO( (int) );
staticforward int      _EscIO      PROTO( (int) );

staticforward int      P_peek      PROTO( (FILE *) );
staticforward int      P_eof       PROTO( (FILE *) );
staticforward int      P_eoln      PROTO( (FILE *) );
staticforward int      P_inset     PROTO( (unsigned, long *) );
staticforward long    *P_addset    PROTO( (long *, unsigned) );
staticforward long    *P_addsetr   PROTO( (long *, unsigned, unsigned) );
staticforward long    *P_remset    PROTO( (long *, unsigned) );
staticforward long    *P_expset    PROTO( (long *, long) );
staticforward void     P_sun_argv  PROTO( (char *, int, int) );

staticforward node* buildcompound_ PROTO(( lexleveltype ));
staticforward void addgrptr PROTO(( graph*,node* ));
staticforward node* buildsubgraph PROTO(( node* ));
staticforward void insertat PROTO(( int ));
staticforward void addtolist_ PROTO(( int,int ));
staticforward void addtoxref PROTO(( symtblbucket* ));
staticforward void printxref PROTO(( void ));
staticforward void endlevel PROTO(( void ));
staticforward void endcompound PROTO(( void ));
staticforward void addtoassolist PROTO(( node*,int ));
staticforward port* orderolist PROTO(( port* ));
staticforward port* orderilist PROTO(( port* ));
staticforward void createlevel PROTO(( lexleveltype ));
staticforward symtblbucket* createbucket PROTO(( identtype ));
staticforward void setname PROTO(( symtblbucket*,stryng ));
staticforward void setdefloc PROTO(( symtblbucket*,int,int ));
staticforward void addref PROTO(( symtblbucket*,int,int ));
staticforward void setlowerbound PROTO(( treestackobj*,inforecord* ));
staticforward int getdefline PROTO(( symtblbucket*,int ));
staticforward int getdefcolumn PROTO(( symtblbucket*,int ));
staticforward loopvarflags getloopflag PROTO(( symtblbucket* ));
staticforward int hash PROTO(( int,int ));
staticforward void addtotable PROTO(( symtblbucket*,treestackobj* ));
staticforward symtblbucket* incurrentlevel PROTO(( stryng,identtype ));
staticforward void findname PROTO(( stryng,identtype,treestackobj**,symtblbucket** ));
staticforward void addpredefined PROTO(( stryng,predeftype ));
staticforward void initsymtable PROTO(( void ));
staticforward void outtype PROTO(( FILE*,stentry*,int ));
staticforward void printbucket PROTO(( symtblbucket* ));
staticforward void printtable PROTO(( FILE*,treestackobj* ));
staticforward void printtypes PROTO(( FILE* ));
staticforward void printtree PROTO(( FILE*,treestackobj* ));
staticforward void crossref PROTO(( FILE*,treestackobj* ));
staticforward symtblbucket* getsymtabentry PROTO(( stryng,identtype ));
staticforward edgelisthead* addnametolist PROTO(( edgelisthead**,stryng ));
staticforward edgelisthead* addtoklist PROTO(( stryng,port*,edgelisthead* ));
staticforward edgelisthead* addtoforklist PROTO(( stryng,port*,treestackobj* ));
staticforward edgelisthead* addtoiklist PROTO(( stryng,port*,treestackobj* ));
staticforward void addtoolist PROTO(( port*,node* ));
staticforward void addtoilist PROTO(( port*,node* ));
staticforward symtblbucket* copysym PROTO(( symtblbucket* ));
staticforward port* emptyoldedge PROTO(( symtblbucket* ));
staticforward port* emptyedge PROTO(( symtblbucket* ));
staticforward int nextkport PROTO(( treestackobj* ));
staticforward symtblbucket* pullname PROTO(( symtblbucket*,treestackobj*,int ));
staticforward void addedge PROTO(( inforecord*,inforecord* ));
staticforward void pushnilttptr PROTO(( void ));
staticforward void pushbasic PROTO(( int ));
staticforward void pushtypename PROTO(( stryng,int,int ));
staticforward void pusharray PROTO(( int ));
staticforward void pushstream PROTO(( int ));
staticforward void pushrecord PROTO(( int ));
staticforward void pushunion PROTO(( int ));
staticforward void pushnulltype PROTO(( void ));
staticforward void checktypename PROTO(( stryng,int,int ));
staticforward void finishtypelinks PROTO(( void ));
staticforward void linkbase PROTO(( void ));
staticforward void buildfort PROTO(( int,int ));
staticforward void buildfield PROTO(( int ));
staticforward void buildtag PROTO(( int ));
staticforward void starttypedefs PROTO(( void ));
staticforward void endtypedefs PROTO(( void ));
staticforward void smashintotable PROTO(( void ));
staticforward void startabuild PROTO(( void ));
staticforward void dolowerbound PROTO(( void ));
staticforward void endabuild PROTO(( void ));
staticforward void doarrayindex PROTO(( void ));
staticforward void doarrayreplace PROTO(( void ));
staticforward void startsbuild PROTO(( void ));
staticforward inforecord* createerr PROTO(( stentry** ));
staticforward void endsbuild PROTO(( int,int ));
staticforward void beforeexp PROTO(( void ));
staticforward void incboostfac PROTO(( void ));
staticforward void decboostfac PROTO(( void ));
staticforward void buildunarynode PROTO(( explistnode*,opertype,int ));
staticforward void buildbinarynode PROTO(( explistnode*,explistnode*,opertype,int ));
staticforward boolean Reduce PROTO(( void ));
staticforward void reduceexp PROTO(( void ));
staticforward void afterexp PROTO(( void ));
staticforward void aftersimpexp PROTO(( void ));
staticforward void dobinaryop PROTO(( int,int,int ));
staticforward void poppreclevel PROTO(( void ));
staticforward void findfieldname PROTO(( stryng,stentry**,boolean*,int* ));
staticforward inforecord* createerrlit PROTO(( void ));
staticforward void dofieldlist PROTO(( int,int ));
staticforward void startrbuild PROTO(( void ));
staticforward void buildfieldlist PROTO(( int,int ));
staticforward void endrbuild PROTO(( int,int ));
staticforward void pushniltag PROTO(( void ));
staticforward void builderrunion PROTO(( semanticrec*,semanticrec*,semanticrec** ));
staticforward void endubuild PROTO(( int,int ));
staticforward void pushinfolist PROTO(( ilistrec**,inforecord* ));
staticforward inforecord* popinfolist PROTO(( ilistrec** ));
staticforward void pushpositionlist PROTO(( plistrec**,int ));
staticforward int poppositionlist PROTO(( plistrec** ));
staticforward void buildreplace PROTO(( int,int ));
staticforward void popsymlist PROTO(( void ));
staticforward void startsymlist PROTO(( void ));
staticforward void checkatypes PROTO(( int,int ));
staticforward void checkarity PROTO(( void ));
staticforward void assoctypes PROTO(( void ));
staticforward void errindexnames PROTO(( namelistrec**,int ));
staticforward void startbody PROTO(( void ));
staticforward void checkcross PROTO(( void ));
staticforward void preparefordot PROTO(( void ));
staticforward void endbody PROTO(( void ));
staticforward explistnode* createerrint PROTO(( void ));
staticforward void checkexptype PROTO(( explistnode**,int,int ));
staticforward void makearrayfor PROTO(( namelistrec*,explistnode*,namelistrec*,int,int ));
staticforward void makerangefor PROTO(( explistnode*,explistnode*,namelistrec*,int,int ));
staticforward void makeforall PROTO(( int,int ));
staticforward void increasegenerator PROTO(( int,int ));
staticforward void explicitcross PROTO(( int,int ));
staticforward void endforall PROTO(( void ));
staticforward edgelisthead* findnameonlist PROTO(( stryng,edgelisthead* ));
staticforward void endinitpart PROTO(( void ));
staticforward void endabody PROTO(( int,int ));
staticforward void endbbody PROTO(( int,int ));
staticforward void startbtest PROTO(( void ));
staticforward void startatest PROTO(( void ));
staticforward void startbinitbody PROTO(( void ));
staticforward void startainitbody PROTO(( void ));
staticforward void startforinit PROTO(( void ));
staticforward void pushwhile PROTO(( void ));
staticforward void pushuntil PROTO(( void ));
staticforward void endtest PROTO(( void ));
staticforward assoclist* buildforinitasslist PROTO(( node* ));
staticforward void loopbassoclist PROTO(( void ));
staticforward void loopaassoclist PROTO(( void ));
staticforward void pushold PROTO(( void ));
staticforward void pushnoold PROTO(( void ));
staticforward void doreduce PROTO(( int ));
staticforward void dosum PROTO(( void ));
staticforward void doproduct PROTO(( void ));
staticforward void dogreatest PROTO(( void ));
staticforward void doleast PROTO(( void ));
staticforward void docatenate PROTO(( void ));
staticforward void noredop PROTO(( void ));
staticforward void checkmask PROTO(( explistnode* ));
staticforward void dounlessexp PROTO(( void ));
staticforward void dowhenexp PROTO(( void ));
staticforward void nomaskingexp PROTO(( void ));
staticforward inforecord* removelast PROTO(( inforecord*,treestackobj* ));
staticforward stentry* buildredtype PROTO(( stentry* ));
staticforward void switchtoreturngraph PROTO(( treestackobj* ));
staticforward void switchtobodygraph PROTO(( treestackobj* ));
staticforward void dovalueof PROTO(( void ));
staticforward void doarrayof PROTO(( int ));
staticforward void startreturns PROTO(( void ));
staticforward void endforinit PROTO(( void ));
staticforward void notenoughargs PROTO(( stryng,struct LOC_dopredefined* ));
staticforward void toomanyargs PROTO(( stryng,struct LOC_dopredefined* ));
staticforward void wrongargtype PROTO(( int,stryng,struct LOC_dopredefined* ));
staticforward inforecord* getalit1_ PROTO(( struct LOC_dopredefined* ));
staticforward void checknumberofargs PROTO(( semanticrec*,int,stryng,struct LOC_dopredefined* ));
staticforward inforecord* addintnode PROTO(( inforecord*,struct LOC_dopredefined* ));
staticforward inforecord* buildpredefnode PROTO(( int,int,struct LOC_dopredefined* ));
staticforward inforecord* errtype_ PROTO(( int,stentry*,struct LOC_dopredefined* ));
staticforward inforecord* maxmin PROTO(( unchar,semanticrec*,int,stryng,struct LOC_dopredefined* ));
staticforward inforecord* addhlarrayorstream PROTO(( int,semanticrec*,unchar,int,stryng,struct LOC_dopredefined* ));
staticforward inforecord* sizearrayorstream PROTO(( predeftype,int,semanticrec*,int,stryng,struct LOC_dopredefined* ));
staticforward inforecord* remhlarrayorstream PROTO(( int,semanticrec*,unchar,int,stryng,struct LOC_dopredefined* ));
staticforward inforecord* arraylimhorl PROTO(( unchar,semanticrec*,int,stryng,struct LOC_dopredefined* ));
staticforward inforecord* floorortrunc PROTO(( unchar,semanticrec*,int,stryng,struct LOC_dopredefined* ));
staticforward void dopredefined PROTO(( symtblbucket*,semanticrec*,int ));
staticforward void initsem PROTO(( void ));
staticforward boolean linkdefinename PROTO(( stryng,namelistrec** ));
staticforward void addtodefinelist PROTO(( stryng ));
staticforward void addtotypelist PROTO(( void ));
staticforward void starttypelist PROTO(( void ));
staticforward stryng buildfunctname PROTO(( stryng ));
staticforward void addlkptr PROTO(( linkrec* ));
staticforward void addgrptr_ PROTO(( graph* ));
staticforward void buildfunctgraph PROTO(( symtblbucket*,stryng,int,int ));
staticforward boolean checkdefinelist PROTO(( stryng,int ));
staticforward void startfunction PROTO(( stryng,int,int,int ));
staticforward void enddefinelist PROTO(( void ));
staticforward void startforwardfunct PROTO(( stryng,int,int ));
staticforward void addfunctargtype PROTO(( stentry*,stentry* ));
staticforward void processparam PROTO(( void ));
staticforward void addfunctrestype PROTO(( stentry*,stentry* ));
staticforward void doresultlist PROTO(( typelistrec*,symtblbucket* ));
staticforward boolean checklastlevel PROTO(( stryng,identtype,symtblbucket** ));
staticforward void freelist PROTO(( stentry* ));
staticforward void freefuncttype PROTO(( stentry* ));
staticforward void endfunctionheader PROTO(( void ));
staticforward void endforwardglobheader PROTO(( void ));
staticforward void endfunctionlist PROTO(( void ));
staticforward void endfunction PROTO(( void ));
staticforward void dofunctcall PROTO(( void ));
staticforward void endprogram PROTO(( void ));
staticforward void startif PROTO(( lexleveltype ));
staticforward void startifsubgraph PROTO(( void ));
staticforward void endiftagsubgraph PROTO(( int ));
staticforward void endifsubgraph PROTO(( void ));
staticforward void endif PROTO(( void ));
staticforward void findandpushname PROTO(( void ));
staticforward void pushnilcons PROTO(( void ));
staticforward void pushtruecons PROTO(( void ));
staticforward void pushfalsecons PROTO(( void ));
staticforward void pushintcons PROTO(( void ));
staticforward void pushrealcons PROTO(( void ));
staticforward void pushdoubcons PROTO(( void ));
staticforward void pushcharcons PROTO(( void ));
staticforward void pushstringcons PROTO(( void ));
staticforward void pusherrorcons PROTO(( void ));
staticforward void buildchar PROTO(( void ));
staticforward void builddouble PROTO(( void ));
staticforward void buildint PROTO(( void ));
staticforward void buildreal PROTO(( void ));
staticforward void createsub PROTO(( node*,tagflag ));
staticforward void changeto2 PROTO(( assoclist* ));
staticforward void createisunion PROTO(( int,int ));
staticforward void checkold PROTO(( stryng,int,int ));
staticforward void pushuplus PROTO(( int,int ));
staticforward void pushuminus PROTO(( int,int ));
staticforward void pushunot PROTO(( int,int ));
staticforward void createiserror PROTO(( int,int ));
staticforward void fixforfunct PROTO(( void ));
staticforward stentry* errorstruct PROTO(( void ));
staticforward void fixfortag PROTO(( int,int ));
staticforward void processtaghead PROTO(( int,int ));
staticforward void createtagsubgraph PROTO(( void ));
staticforward tcstacklistrec* findtag PROTO(( stryng,tcstacklistrec* ));
staticforward void checktagnames PROTO(( int,int ));
staticforward void assocexprs PROTO(( void ));
staticforward void endtagcase PROTO(( void ));
staticforward void otherwisetag PROTO(( int,int ));
staticforward void setstep PROTO(( void ));
staticforward void showbrkpts PROTO(( void ));
staticforward void removebrkpts PROTO(( void ));
staticforward void addbrkpts PROTO(( void ));
staticforward void printnames PROTO(( namelistrec* ));
staticforward void printtypes_ PROTO(( typelistrec* ));
staticforward void printgraphinfo PROTO(( inforecord* ));
staticforward void printsymlist PROTO(( symlistnode* ));
staticforward void printexplist PROTO(( explistnode* ));
staticforward void printtclist PROTO(( tcstacklistrec* ));
staticforward void printstack PROTO(( void ));

staticforward void readcosts PROTO(( void ));
staticforward void reads PROTO(( void ));
staticforward void checkinsertsize PROTO(( int ));
staticforward void get1prefix PROTO(( void ));
staticforward void skipcosts PROTO(( void ));
staticforward void skips PROTO(( void ));
staticforward void skip1prefix PROTO(( void ));
staticforward void seeke PROTO(( int,stryng ));
staticforward void getprefixinfo PROTO(( int,stryng ));
staticforward void readerrtables PROTO(( stryng* ));
staticforward void copye PROTO(( SHORT,stagerec* ));
staticforward void copys PROTO(( SHORT,stagerec* ));
staticforward void printinsertion PROTO(( stagerec ));
staticforward void expandinsertion PROTO(( SHORT,stagerec* ));
staticforward void llinsert PROTO(( int,stagerec*,stryng* ));
staticforward void inoverflow PROTO(( void ));
staticforward void llcorrector PROTO(( SHORT*,stryng* ));
staticforward void myabort PROTO(( void ));
staticforward void initptab PROTO(( void ));
staticforward SHORT findlltab PROTO(( SHORT,int ));
staticforward void printstring PROTO(( stryng ));
staticforward void printsym PROTO(( int ));
staticforward void printline PROTO(( inputbuffer* ));
staticforward void modify PROTO(( inputbuffer* ));
staticforward void flushlines PROTO(( void ));
staticforward void readline PROTO(( inputbuffer* ));
staticforward void getline PROTO(( inputbuffer** ));
staticforward void readchar PROTO(( Char*,inputbuffer** ));
staticforward void unreadchar PROTO(( int,inputbuffer* ));
staticforward void insertcharbuf PROTO(( int,unchar,inputbuffer* ));
staticforward void displaydeletions PROTO(( int ));
staticforward void displayinsertion PROTO(( SHORT ));
staticforward void scanerror PROTO(( void ));
staticforward SHORT searchsymboltable PROTO(( int,int,stryng*,SHORT ));
staticforward SHORT lookupterm PROTO(( stryng*,SHORT,struct LOC_scan* ));
staticforward void ctrlchtooctal PROTO(( int,stryng*,struct LOC_scan* ));
staticforward int branchonfirstchar PROTO(( struct LOC_scan* ));
staticforward void scannererr PROTO(( errtype,struct LOC_scan* ));
staticforward void unappend PROTO(( stryng*,inputbuffer**,struct LOC_scan* ));
staticforward void scan PROTO(( SHORT*,int*,inputbuffer** ));
staticforward void initscanner PROTO(( void ));
staticforward void peek PROTO(( SHORT* ));
staticforward void gettok PROTO(( SHORT*,int* ));
staticforward void deletetokens PROTO(( int ));
staticforward void inserttokens PROTO(( stagerec ));
staticforward void checkerrorok PROTO(( void ));
staticforward void readtables PROTO(( stryng ));
staticforward void push PROTO(( SHORT ));
staticforward int tos PROTO(( void ));
staticforward void pop PROTO(( void ));
staticforward void trace PROTO(( void ));
staticforward boolean checkepsilonok PROTO(( int ));
staticforward void parseerror PROTO(( SHORT,stryng* ));
staticforward void printstats PROTO(( void ));
staticforward void init PROTO(( void ));
staticforward void parse PROTO(( stryng* ));
staticforward void readline_ PROTO(( int,inputbuffer*,FILE*,struct LOC_pass1* ));
staticforward boolean recursiveincl PROTO(( stryng,struct LOC_pass1* ));
staticforward void pushinclstack PROTO(( stryng,int,struct LOC_pass1* ));
staticforward void popinclstack PROTO(( struct LOC_pass1* ));
staticforward void dumpline PROTO(( inputbuffer*,struct LOC_pass1* ));
staticforward char* CANN_StringCopy PROTO((int,char*));
staticforward int CANN_PreparePragmaName PROTO(( char* ));
staticforward int CANN_IsEntryPragma PROTO(( char* ));
staticforward int CANN_IsFortranPragma PROTO(( char* ));
staticforward int CANN_IsCPragma PROTO(( char* ));
staticforward void CANN_ProcessPragmaFields PROTO(( int,char*,char**,int* ));
staticforward int CANN_DissectSpecialPragmas PROTO(( int,int,char* ));
staticforward char* CANN_StripWhites PROTO(( char* ));
staticforward void error PROTO(( struct LOC_dissectpragma* ));
staticforward void dissectpragma PROTO(( inputbuffer*,int,int,pragmaname*,stryng*,struct LOC_pass1* ));
staticforward boolean pass1 PROTO(( stryng*,stryng*,FILE* ));
staticforward void splitaelement PROTO(( node* ));
staticforward void convertareplacen PROTO(( node* ));
staticforward void removeunusedports PROTO(( node* ));
staticforward node* createselectorgraph PROTO(( node* ));
staticforward void convertiftoselect PROTO(( node* ));
staticforward void convertelseiftoselect PROTO(( node* ));
staticforward void searchgraph_ PROTO(( node* ));
staticforward void converttoversion1 PROTO(( void ));
staticforward boolean nodesareequivalent PROTO(( node*,node*,struct LOC_removegraphcse* ));
staticforward void inittable PROTO(( struct LOC_removegraphcse* ));
staticforward void addtotable_ PROTO(( unchar,node*,struct LOC_removegraphcse* ));
staticforward node* getequivnode PROTO(( unchar,node*,struct LOC_removegraphcse* ));
staticforward void movealloutputedges PROTO(( node*,node*,struct LOC_removegraphcse* ));
staticforward void moveoutputedges PROTO(( node*,int,int ));
staticforward void pushfanoutout PROTO(( node*,struct LOC_removegraphcse* ));
staticforward int removegraphcse PROTO(( node*,int ));
staticforward ndptrreclist* ndptrnewlist PROTO(( void ));
staticforward boolean ndptrisnull PROTO(( ndptrreclist* ));
staticforward node* ndptrrmhead PROTO(( ndptrreclist* ));
staticforward int ndptrlength PROTO(( ndptrreclist* ));
staticforward ndptrreclist* ndptrappend PROTO(( ndptrreclist*,node* ));
staticforward void imposegraphordering PROTO(( ndptrreclist*,node* ));
staticforward int numancestors PROTO(( node* ));
staticforward void setrefcount PROTO(( node*,int ));
staticforward int refcount PROTO(( node* ));
staticforward boolean dfordergraph PROTO(( node* ));
staticforward boolean allconstantinputs PROTO(( node*,struct LOC_fixreturnsgraph* ));
staticforward void createnewkport PROTO(( struct LOC_fixreturnsgraph* ));
staticforward void createnewlport PROTO(( struct LOC_fixreturnsgraph* ));
staticforward void insureedgeisnotconstant PROTO(( node*,int,struct LOC_fixreturnsgraph* ));
staticforward void moveoutsideofloop PROTO(( node*,struct LOC_fixreturnsgraph* ));
staticforward void copynodetograph PROTO(( node*,node*,int,struct LOC_fixreturnsgraph* ));
staticforward void movenodeafterloop PROTO(( node*,node*,node*,struct LOC_fixreturnsgraph* ));
staticforward void removefinalvalue PROTO(( node*,node*,struct LOC_fixreturnsgraph* ));
staticforward void fixreturnsgraph PROTO(( node* ));
staticforward void findloopnodes PROTO(( node* ));
staticforward boolean dforder PROTO(( node* ));
staticforward boolean backend PROTO(( void ));


/* ----------------------------------------------- */
/* Externals                                       */
/* ----------------------------------------------- */
static int   CANN_GlueMode = 0;
static FILE *CANN_source = NULL;
static char  CANN_source_file[1024];
static char *CANN_file_name = NULL;

staticforward printable nodename[ifmaxnode + 1];
staticforward printable errvname[ifmaxerror + 1];
staticforward printable typename[ifmaxtype + 1];
/* staticforward printable basename[ifmaxbasic + 1]; */
staticforward printable graphname[19];
staticforward ndclasstype nodeclass[ifmaxnode + 1];   /* dlz - 8/87 */
staticforward FILE *source, *diag;
staticforward infilelist infile;
staticforward parrec *outfile;
/* these vars are needed by module using the graph */
staticforward stentry *typetable[entrymax];
staticforward int univmodulecnt, univnodecnt, univedgecnt;
staticforward linkrec *funclist;
staticforward node *firstfunction, *module;
staticforward stryng stamp['[' - 'A'];
staticforward long stampset[9];

staticforward semanticrec *topsemstk;   /* Top of Semantic Stack */
staticforward namelistrec *definelist;
staticforward treestackobj *currentlevel;
staticforward int linenumber, tokenlineno;

staticforward void deletestring PROTO((stryng*,int,int));
staticforward void dumpmodule PROTO((void));
staticforward boolean equalstrings PROTO((stryng*,stryng*));
staticforward stentry* getbasictype PROTO((int));
staticforward void insertchar PROTO((stryng*,int,int));
staticforward void mymemcpy PROTO((char*,char*,int));
staticforward graph* newgraphptr PROTO((void));
staticforward void newnamelist PROTO((namelistrec**));
staticforward void removenode PROTO((node*));
staticforward void string10 PROTO((stryng*,Char*));
staticforward void string20 PROTO((stryng*,Char*));
staticforward Char stringchar PROTO((stryng*,int));
staticforward void stringlowercase PROTO((stryng*));
staticforward void substring PROTO((stryng*,stryng*,int,int));
staticforward void writestring PROTO((FILE*,stryng*));
staticforward PSBLOCK MySBlockAlloc PROTO((void));
staticforward PBBLOCK MyBBlockAlloc PROTO((void));
staticforward void addstamp PROTO((int,stryng));
staticforward void removestamp PROTO((int));
staticforward void addtoexplist PROTO((explistnode**,explistnode*));
staticforward void addtonamelist PROTO((stryng,int,int));
staticforward stentry *addtotypetable PROTO((stentry*));
staticforward void adjustgraphptrs PROTO((void));
staticforward boolean announceaction PROTO((int,int,int,int,stryng));
staticforward void askordefault PROTO((parrec*,stryng*,int,Char*));
staticforward int assignports PROTO((edgelisthead*,int));
staticforward boolean canwrite PROTO((stryng*));
staticforward void changeedgedest PROTO((port*,node*,int));
staticforward void changeedgesrc PROTO((port*,node*,int));
staticforward void compactports PROTO((node*));
staticforward void compacttypetable PROTO((int*,int));
staticforward void concatchar PROTO((stryng*,int));
staticforward node *copynode PROTO((node*));
staticforward node *copygraph PROTO((node*));
staticforward node *copycompound PROTO((node*));
staticforward node *createcompoundnode PROTO((int));
staticforward node *createsimplenode PROTO((int));
staticforward boolean debugger PROTO((int,int));
staticforward void defaultext PROTO((stryng*,stryng*,Char*));
staticforward parrec *defineparameter PROTO((parrec**,Char*,Char*,partyp,int,int));
staticforward void disconnectedgefromdest PROTO((port*));
staticforward void disconnectedgefromsource PROTO((port*));
staticforward int findstring PROTO((stryng*,stryng*,int));
staticforward void freeinfoptr PROTO((inforecord**));
staticforward void freenamelist PROTO((namelistrec**));
staticforward void freesemantic PROTO((semanticrec**));
staticforward void freesymptr PROTO((symtblbucket*));
staticforward void freetornlist PROTO((tornrec**));
staticforward void freetreestack PROTO((treestackobj*));
staticforward void freettptr PROTO((stentry**));
staticforward void freetypelist PROTO((typelistrec**));
staticforward inforecord *getalit1 PROTO((void));
staticforward stentry *getconstructortype PROTO((int,stentry*));
staticforward port *getinputedge PROTO((node*,int));
staticforward port *getoutputedge PROTO((node*,int));
staticforward node *graphwalk PROTO((node*));
staticforward void initmodule PROTO((void));
staticforward void initnames PROTO((void));
staticforward port *insertedge PROTO((node*,int,node*,int,stentry*,stryng));
staticforward port *insertliteral PROTO((node*,int,stentry*,stryng,stryng));
staticforward void insertnode PROTO((node*,node*,node*));
staticforward void integerstring PROTO((stryng*,int,int));
staticforward int largestinputportnumber PROTO((node*));
staticforward int largestoutputportnumber PROTO((node*));
staticforward void linkparent PROTO((node*,treestackobj*));
staticforward tornrec *linktorntype PROTO((tornrec*,tornrec*));
staticforward void linktype PROTO((stentry*,typelistrec**));
staticforward edgelist *newedgelistptr PROTO((void));
staticforward port *newedgeptr PROTO((portsort));
staticforward errorrecord *newerrorptr PROTO((errortypes));
staticforward explistnode *newexplistptr PROTO((void));
staticforward edgelisthead *newheadptr PROTO((void));
staticforward inforecord *newinfoptr PROTO((void));
staticforward linkrec *newlinkageptr PROTO((linksort));
staticforward node *newnodealloc PROTO((nodesort));
staticforward node *newnodeptr PROTO((nodesort,treestackobj*));
staticforward refrec *newreferencesptr PROTO((void));
staticforward void newsemantic PROTO((semanticrec**,typesemanticdata));
staticforward symlistnode *newsymlistptr PROTO((void));
staticforward tcstacklistrec *newtcstacklist PROTO((void));
staticforward void newtornlist PROTO((tornrec**,torntype));
staticforward void newttptr PROTO((stentry**,int));
staticforward void newtypelist PROTO((typelistrec**));
staticforward void nextbodyportname PROTO((treestackobj*,stryng*));
staticforward port *nextoutputedgesameport PROTO((port*));
staticforward int nextreturnport PROTO((treestackobj*));
staticforward int numberofwiredoutputports PROTO((node*));
staticforward int numbnodesingraph PROTO((node*));
staticforward int numbofsubgraphs PROTO((node*));
staticforward boolean openintread PROTO((FILE**,stryng*));
staticforward boolean openlistfile PROTO((stryng,FILE**));
staticforward boolean openread PROTO((FILE**,stryng*));
staticforward boolean openwrite PROTO((FILE**,stryng*));
staticforward port *outputedgegeport PROTO((node*,int));
staticforward semanticrec *popsemantic PROTO((void));
staticforward node *producernodeofedge PROTO((port*));
staticforward int producerportnumber PROTO((port*));
staticforward void pushemptyexplist PROTO((void));
staticforward void pushsemantic PROTO((semanticrec*));
staticforward void putintable PROTO((stentry**));
staticforward void readcommandline PROTO((parrec**,parrec**,parrec**));
staticforward void removedeadcode PROTO((void));
staticforward void removeedge PROTO((port**));
staticforward void semerror PROTO((errorrecord*));
staticforward void shiftinputports PROTO((node*,int,int));
staticforward void shiftoutputports PROTO((node*,int,int));
staticforward void smashtypes PROTO((void));
staticforward void splitname PROTO((stryng*,stryng*,stryng*,stryng*));
staticforward void startnamelist PROTO((void));
staticforward comparetype stringcompare PROTO((stryng*,stryng*,int));
staticforward long stringnumber PROTO((stryng*,int*,int));
staticforward void stringuppercase PROTO((stryng*));
staticforward node *tobodygraph PROTO((node*));
staticforward node *tochildgraph PROTO((node*,int));
staticforward node *toforallbodygraph PROTO((node*));
staticforward node *toforallgeneratorgraph PROTO((node*));
staticforward node *toforallreturnsgraph PROTO((node*));
staticforward node *toinitgraph PROTO((node*));
staticforward node *tolastnodeingraph PROTO((node*));
staticforward node *tonextfunction PROTO((node*));
staticforward node *toprevnode PROTO((node*));
staticforward node *toreturnsgraph PROTO((node*));
staticforward node *totestgraph PROTO((node*));
staticforward void insertstring PROTO((stryng*,stryng*,int));
staticforward void stripspaces PROTO((stryng*));
staticforward void cleanupgraph PROTO((node*));
staticforward void CANN_DumpSpecialPragmas PROTO((FILE*));

staticforward int idxrefmax;
staticforward boolean semtrace;
staticforward int currentstep;
staticforward int stepcount;
staticforward stryng inputtoken;
staticforward int boostfac;
staticforward boolean cortrace;
staticforward boolean debug;
staticforward long arithtypes;
staticforward long algebtypes;
staticforward long streamorarray;
staticforward long binaryops;
staticforward int column;
staticforward boolean xref;
staticforward int tthwm;
staticforward FILE *listfile;
staticforward boolean typedefsfinished;
staticforward includestackrec *topincludestk;
staticforward int numterms;
staticforward FILE* ptableout;
staticforward FILE* etableout;
staticforward int insertptr;
staticforward int numsymbols;
staticforward int numprods;
staticforward pretabarray prefixtable;
staticforward FILE* reservedwords;
staticforward FILE* inputfile;
staticforward stryng listfilename;
staticforward stryng stampstr;
staticforward stryng versionstr;
staticforward stryng versionnum;
staticforward int myinfinity;
staticforward char curerrsym;
staticforward boolean errortables;
staticforward SHORT stackptr;
staticforward int savinsertptr;
staticforward int errorcount;
staticforward int numdeltried;
staticforward int tokinserted;
staticforward int tokdeleted;
staticforward parrec *directoryparam;
staticforward parrec* paramlist;
staticforward int semerrcnt;
staticforward parrec *xrefparam;
staticforward parrec* listingparam;
staticforward parrec* debugparam;
staticforward parrec* pass1param;
staticforward boolean passerr;
staticforward stryng directoryname;
staticforward stryng defaultdirectoryname;
staticforward stryng filename;
staticforward parrec *listfparam;
staticforward boolean listing;
staticforward namelistrec *includelist;
staticforward int stringptr;
staticforward inputbuffer* linebuf;
staticforward inputbuffer* oldline;
staticforward boolean echoed;
staticforward boolean endfile;
staticforward stryng curinputfile;
staticforward stryng newfname;
staticforward unchar tokenstart;
staticforward boolean debugcg;
staticforward boolean commentflag;
staticforward boolean peeking;
staticforward boolean firsttime;
staticforward boolean firsttime;
staticforward int newlinenum;
staticforward SHORT oldtoken;
staticforward int toconsume;
staticforward rabrec *readaheadbuf;   /*head of buffer of inserted tokens*/
staticforward int reuseindex;
staticforward int ordzero;
staticforward SHORT prodspceptr;
staticforward Char newcommand;
staticforward SHORT savetoken;
staticforward int rea;
staticforward int inttokenval;
staticforward int CANN_GlueMode;
staticforward tablerec p;
staticforward boolean done;
staticforward int tokenposition;   /* character position within a token */
staticforward void clearstring PROTO(( stryng*,int,int ));
staticforward void readstring PROTO(( FILE*,stryng* ));
staticforward Char uppercase PROTO(( int ));
staticforward Char lowercase PROTO(( int ));
staticforward boolean matchstrings PROTO(( stryng*,stryng*,int ));
staticforward int findchar PROTO(( int,stryng*,int ));
staticforward int findlastchar PROTO(( int,stryng* ));
staticforward void numberstring PROTO(( stryng*,int,int ));
staticforward int charval PROTO(( int ));
staticforward void initnames PROTO(( void ));
staticforward void buildname PROTO(( stryng*,stryng,stryng,stryng ));
staticforward void splitname PROTO(( stryng*,stryng*,stryng*,stryng* ));
staticforward void defaultfilename PROTO(( stryng*,stryng* ));
staticforward boolean openread PROTO(( FILE**,stryng* ));
staticforward boolean openintread PROTO(( FILE**,stryng* ));
staticforward boolean openwrite PROTO(( FILE**,stryng* ));
staticforward boolean canwrite PROTO(( stryng* ));
staticforward void gettermline PROTO(( stryng*,stryng* ));
staticforward void getcommandline PROTO(( stryng* ));
staticforward void CANN_exit PROTO(( int ));
staticforward parrec* defineparameter PROTO(( parrec**,Char*,Char*,partyp,int,int ));
staticforward void setparameter PROTO(( parrec*,stryng* ));
staticforward Char gettoken PROTO(( stryng*,stryng* ));
staticforward boolean parsecommandline PROTO(( parrec* ));
staticforward void getparamvalue PROTO(( parrec*,stryng ));
staticforward void defaultext PROTO(( stryng*,stryng*,Char* ));
staticforward void readcommandline PROTO(( parrec**,parrec**,parrec** ));
staticforward boolean openoutputfile PROTO(( stryng*,FILE** ));
staticforward stentry* newtypealloc PROTO(( int ));
staticforward port* newedgealloc PROTO(( portsort ));
staticforward node* newnodealloc PROTO(( nodesort ));
staticforward void initstamps PROTO(( void ));
staticforward void removestamp PROTO(( int ));
staticforward void addstamp PROTO(( int,stryng ));
staticforward int numbofsubgraphs PROTO(( node* ));
staticforward int numbnodesingraph PROTO(( node* ));
staticforward int numberofwiredoutputports PROTO(( node* ));
staticforward int largestinputportnumber PROTO(( node* ));
staticforward int largestoutputportnumber PROTO(( node* ));
staticforward int nodelabel PROTO(( node* ));
staticforward node* producernodeofedge PROTO(( port* ));
staticforward int producerportnumber PROTO(( port* ));
staticforward node* tolastnodeingraph PROTO(( node* ));
staticforward node* toprevnode PROTO(( node* ));
staticforward node* tochildgraph PROTO(( node*,int ));
staticforward node* toenclosingcompound PROTO(( node* ));
staticforward node* toenclosingfunction PROTO(( node* ));
staticforward node* toinitgraph PROTO(( node* ));
staticforward node* tobodygraph PROTO(( node* ));
staticforward node* totestgraph PROTO(( node* ));
staticforward node* toreturnsgraph PROTO(( node* ));
staticforward node* toiterbodygraph PROTO(( node* ));
staticforward node* toselectorgraph PROTO(( node* ));
staticforward node* toforallgeneratorgraph PROTO(( node* ));
staticforward node* toforallbodygraph PROTO(( node* ));
staticforward node* toforallreturnsgraph PROTO(( node* ));
staticforward port* getinputedge PROTO(( node*,int ));
staticforward port* getoutputedge PROTO(( node*,int ));
staticforward port* nextoutputedgesameport PROTO(( port* ));
staticforward port* outputedgegeport PROTO(( node*,int ));
staticforward node* getnodewithlabel PROTO(( node*,int ));
staticforward node* getnodewithid PROTO(( node*,int ));
staticforward node* tonextfunction PROTO(( node* ));
staticforward stentry* searchtypetable PROTO(( int,stentry*,stentry*,stryng ));
staticforward int equivclass PROTO(( stentry*,struct LOC_smashtypes* ));
staticforward boolean sameequivclass PROTO(( stentry*,stentry*,struct LOC_smashtypes* ));
staticforward void createnewequivclass PROTO(( stentry*,struct LOC_smashtypes* ));
staticforward void removefromequivclass PROTO(( stentry*,stentry*,struct LOC_smashtypes* ));
staticforward void addtoequivclass PROTO(( stentry*,stentry*,struct LOC_smashtypes* ));
staticforward void initequivclasses PROTO(( struct LOC_smashtypes* ));
staticforward void gatherothers PROTO(( stentry*,stentry**,struct LOC_smashtypes* ));
staticforward void pointtohead PROTO(( struct LOC_smashtypes* ));
staticforward void smashtypes PROTO(( void ));
staticforward void adjustgraphptrs PROTO(( void ));
staticforward stentry* getbasictype PROTO(( int ));
staticforward stentry* getwildtype PROTO(( void ));
staticforward stentry* getconstructortype PROTO(( int,stentry* ));
staticforward void putintable PROTO(( stentry** ));
staticforward void putstruct PROTO(( stentry* ));
staticforward stentry* addtotypetable PROTO(( stentry* ));
staticforward ifgraphtype graphkind PROTO(( node* ));
staticforward void disconnectedgefromsource PROTO(( port* ));
staticforward void disconnectedgefromdest PROTO(( port* ));
staticforward void removeedge PROTO(( port** ));
staticforward void removeinputedges PROTO(( node* ));
staticforward void removegraph PROTO(( node* ));
staticforward void removenode PROTO(( node* ));
staticforward node* createsimplenode PROTO(( int ));
staticforward node* createcompoundnode PROTO(( int ));
staticforward void insertnode PROTO(( node*,node*,node* ));
staticforward void changeedgedest PROTO(( port*,node*,int ));
staticforward void changeedgesrc PROTO(( port*,node*,int ));
staticforward port* insertedge PROTO(( node*,int,node*,int,stentry*,stryng ));
staticforward port* insertliteral PROTO(( node*,int,stentry*,stryng,stryng ));
staticforward void renumbergraph PROTO(( node*,int ));
staticforward void shiftinputports PROTO(( node*,int,int ));
staticforward void shiftoutputports PROTO(( node*,int,int ));
staticforward node* copynode PROTO(( node* ));
staticforward node* copycompound PROTO(( node* ));
staticforward void copyedges PROTO(( node*,node* ));
staticforward node* copygraph PROTO(( node* ));
staticforward void cleanupnewiter PROTO(( node* ));
staticforward void cleanupforall PROTO(( node* ));
staticforward void cleanupiterloop PROTO(( node* ));
staticforward void cleanupselect PROTO(( node* ));
staticforward void cleanuptagcase PROTO(( node* ));
staticforward void cleanupifthenelse PROTO(( node* ));
staticforward void nsinit PROTO(( ndstack* ));
staticforward boolean nsempty PROTO(( ndstack* ));
staticforward void nspush PROTO(( ndstack*,node* ));
staticforward node* nspop PROTO(( ndstack* ));
staticforward void cleanupgraph PROTO(( node* ));
staticforward void removedeadcode PROTO(( void ));
staticforward void rm PROTO(( node* ));
staticforward void removenoop PROTO(( node* ));
staticforward int compactinputs PROTO(( node*,int,int ));
staticforward void compactports PROTO(( node* ));
staticforward void buildbasictype PROTO(( int,Char* ));
staticforward void initmodule PROTO(( void ));
staticforward void writetypenumber PROTO(( stentry*,struct LOC_dumpprogram* ));
staticforward void dumpentry PROTO(( stentry*,struct LOC_dumpprogram* ));
staticforward void writeedgepragmas PROTO(( port*,struct LOC_dumpprogram* ));
staticforward void dumpinputedges PROTO(( node*,struct LOC_dumpprogram* ));
staticforward void writenodepragmas PROTO(( node*,struct LOC_dumpprogram* ));
staticforward void dumpsimple PROTO(( node*,struct LOC_dumpprogram* ));
staticforward void dumpcompound PROTO(( node*,struct LOC_dumpprogram* ));
staticforward void dumpgraph PROTO(( node*,struct LOC_dumpprogram* ));
staticforward void dumpif1file PROTO(( FILE*,struct LOC_dumpprogram* ));
staticforward void dumpprogram PROTO(( stryng ));
staticforward void dumpmodule PROTO(( void ));
staticforward char hashfunction PROTO(( Char*,struct LOC_graphwalk* ));
staticforward boolean emptylist PROTO(( intlist*,struct LOC_graphwalk* ));
staticforward void initlist PROTO(( intlist*,struct LOC_graphwalk* ));
staticforward int poplist PROTO(( intlist*,struct LOC_graphwalk* ));
staticforward void addtolist PROTO(( intlist*,int,struct LOC_graphwalk* ));
staticforward void displaytable PROTO(( struct LOC_graphwalk* ));
staticforward void insert_ PROTO(( Char*,commandtype,struct LOC_initcommandtable* ));
staticforward void initcommandtable PROTO(( struct LOC_graphwalk* ));
staticforward void skipblanks PROTO(( struct LOC_graphwalk* ));
staticforward boolean readinteger_ PROTO(( int*,struct LOC_graphwalk* ));
staticforward void readcommandname PROTO(( Char*,struct LOC_getvalidcommand* ));
staticforward boolean foundintable PROTO(( Char*,commandtype*,struct LOC_getvalidcommand* ));
staticforward void getvalidcommand PROTO(( commandtype*,struct LOC_graphwalk* ));
staticforward int findlooplevel PROTO(( node*,struct LOC_graphwalk* ));
staticforward int findlexicallevel PROTO(( node*,struct LOC_graphwalk* ));
staticforward void displayedge PROTO(( port*,struct LOC_graphwalk* ));
staticforward void displaynode PROTO(( node*,struct LOC_graphwalk* ));
staticforward void writetype PROTO(( stentry* ));
staticforward void displaytype PROTO(( struct LOC_graphwalk* ));
staticforward void marknode PROTO(( node*,struct LOC_graphwalk* ));
staticforward boolean nodemarked PROTO(( node*,struct LOC_graphwalk* ));
staticforward void unmarkgraph PROTO(( node*,int,struct LOC_graphwalk* ));
staticforward void gatherboundaryedges PROTO(( intlist*,node*,int*,struct LOC_graphwalk* ));
staticforward void listallfuns PROTO(( struct LOC_graphwalk* ));
staticforward void listallnodes PROTO(( node*,struct LOC_graphwalk* ));
staticforward void gotonextnode PROTO(( node**,struct LOC_graphwalk* ));
staticforward void gotoparent PROTO(( node**,struct LOC_graphwalk* ));
staticforward void showcurrfun PROTO(( node*,struct LOC_graphwalk* ));
staticforward void gotonodeid PROTO(( node**,struct LOC_graphwalk* ));
staticforward void showoutedges PROTO(( node*,struct LOC_graphwalk* ));
staticforward void showinedges PROTO(( node*,struct LOC_graphwalk* ));
staticforward void gotosubgraph PROTO(( node**,struct LOC_graphwalk* ));
staticforward void gotonodelabel PROTO(( node**,struct LOC_graphwalk* ));
staticforward void searchgraph PROTO(( node*,int,struct LOC_findnodes* ));
staticforward void findnodes PROTO(( node*,int,struct LOC_graphwalk* ));
staticforward void moveright_ PROTO(( node**,struct LOC_graphwalk* ));
staticforward void moveleft_ PROTO(( node**,struct LOC_graphwalk* ));
staticforward void shownodesabove PROTO(( node*,struct LOC_graphwalk* ));
staticforward void shownodesbelow PROTO(( node*,struct LOC_graphwalk* ));
staticforward void showgraph PROTO(( node*,struct LOC_graphwalk* ));
staticforward void givehelp PROTO(( struct LOC_graphwalk* ));
staticforward void showgraphports PROTO(( node*,struct LOC_graphwalk* ));
staticforward void dumpnode PROTO(( node*,struct LOC_graphwalk* ));
staticforward void dumponeedge PROTO(( port*,struct LOC_graphwalk* ));
staticforward void dumpdepinputedges PROTO(( node*,struct LOC_graphwalk* ));
staticforward void dumpdepoutputedges PROTO(( node*,struct LOC_graphwalk* ));
staticforward void dumpinputedges_ PROTO(( node*,struct LOC_graphwalk* ));
staticforward void dumpallinput PROTO(( node*,struct LOC_graphwalk* ));
staticforward void dumpoutputedges PROTO(( node*,struct LOC_graphwalk* ));
staticforward void dumpalloutput PROTO(( node*,struct LOC_graphwalk* ));
staticforward node* graphwalk PROTO(( node* ));
staticforward int nextnodenum PROTO(( void ));
staticforward int nextedgenum PROTO(( void ));
staticforward int nextsgnodenum PROTO(( treestackobj* ));
staticforward int nextreturnport PROTO(( treestackobj* ));
staticforward void nextbodyportname PROTO(( treestackobj*,stryng* ));
staticforward void freesymptr PROTO(( symtblbucket* ));
staticforward void freetreestack PROTO(( treestackobj* ));
staticforward void newsemantic PROTO(( semanticrec**,typesemanticdata ));
staticforward void freesemantic PROTO(( semanticrec** ));
staticforward void newnamelist PROTO(( namelistrec** ));
staticforward void freenamelist PROTO(( namelistrec** ));
staticforward void newtypelist PROTO(( typelistrec** ));
staticforward void freetypelist PROTO(( typelistrec** ));
staticforward void newtornlist PROTO(( tornrec**,torntype ));
staticforward void freetornlist PROTO(( tornrec** ));
staticforward void newttptr PROTO(( stentry**,int ));
staticforward void freettptr PROTO(( stentry** ));
staticforward node* newnodeptr PROTO(( nodesort,treestackobj* ));
staticforward port* newedgeptr PROTO(( portsort ));
staticforward linkrec* newlinkageptr PROTO(( linksort ));
staticforward graph* newgraphptr PROTO(( void ));
staticforward edgelisthead* newheadptr PROTO(( void ));
staticforward void freeheadptr PROTO(( edgelisthead** ));
staticforward edgelist* newedgelistptr PROTO(( void ));
staticforward void freeedgelistptr PROTO(( edgelist** ));
staticforward refrec* newreferencesptr PROTO(( void ));
staticforward inforecord* newinfoptr PROTO(( void ));
staticforward void freeinfoptr PROTO(( inforecord** ));
staticforward explistnode* newexplistptr PROTO(( void ));
staticforward tcstacklistrec* newtcstacklist PROTO(( void ));
staticforward errorrecord* newerrorptr PROTO(( errortypes ));
staticforward void freeerrorptr PROTO(( errorrecord** ));
staticforward symlistnode* newsymlistptr PROTO(( void ));
staticforward void printtypesort PROTO(( FILE*,stentry* ));
staticforward void printoperation PROTO(( FILE*,opertype ));
staticforward void printerror PROTO(( FILE*,errorrecord* ));
staticforward void semerror PROTO(( errorrecord* ));
staticforward node* findparent PROTO(( treestackobj* ));
staticforward void linkparent PROTO(( node*,treestackobj* ));
staticforward void pushsemantic PROTO(( semanticrec* ));
staticforward semanticrec* popsemantic PROTO(( void ));
staticforward void linkname PROTO(( stryng,int,int,namelistrec** ));
staticforward tornrec* linktorntype PROTO(( tornrec*,tornrec* ));
staticforward void linktype PROTO(( stentry*,typelistrec** ));
staticforward void addtonamelist PROTO(( stryng,int,int ));
staticforward void startnamelist PROTO(( void ));
staticforward void addtoexplist PROTO(( explistnode**,explistnode* ));
staticforward void pushemptyexplist PROTO(( void ));
staticforward inforecord* getalit1 PROTO(( void ));
staticforward int assignports PROTO(( edgelisthead*,int ));

/**************************************************************************/
/* FILE   **************         frontend.h        ************************/
/**************************************************************************/
/* Author: Skedz?                                                         */
/* Update: Dave Cann                                                      */
/* Update: Pat Miller -- ANSI compliance                                  */
/* Copyright (C) 1986 University of California Regents                    */
/**************************************************************************/

/* Output from p2c, the Pascal-to-C translator */
/* From input file "mono.bin.noblank.p" */


/* copyright (C) 1986 by the Regents of the University of California */

/*========================================================
     declarations for parser.p
=========================================================*/
/* STRUTL has no data dependancies ...  first in .makeo file */
/* Pad String pads a string constant to a M4 known size  - pjm 1/88*/
/* SETUTL has on data dependancies ...
   second in .makeo file */
/* IF1INIT no dependancies..
   third in .makeo file */
/* FILUTL depends on STRUTL,
   Include fourth in .makeo files */
/* PARUTL depends on STRUTL, FILUTL,
   Include fifth in .makeo files   */
/* Graph.m4 depends on STRUTL, IF1INIT, SETUTL.
   Include sixth in the .makeo file      */
/* IF1INPUT depends on STRUTL, IF1INIT, GRAPH.
   Include seventh in .makeo file                */
/* IF1DUMP depends on STRUTL, GRAPH, and IF1INPUT
   eighth in .makeo file                          */
/* llprocs depends on STRUTL */
/* UNIX (tm Bell Labs.) specific declarations */
/*  global constants here */
/*#TITLE  STRUTL  CONSTANTS       Jan82   String Handling Routines.*/




/**************************************************************************/
/* FILE   **************          file3.c          ************************/
/**************************************************************************/
/* Author: Skedz?                                                         */
/* Update: Dave Cann                                                      */
/* Update: Pat Miller -- ANSI compliance                                  */
/* Copyright (C) University of California Regents                         */
/**************************************************************************/

/* CANN ********** */
static PBBLOCK bpool;
static int     bpidx = MAX_BBLOCKS+100;

static PSBLOCK spool;
static int     spidx = MAX_SBLOCKS+100;



static PSBLOCK MySBlockAlloc()
{
  if ( spidx >= MAX_SBLOCKS ) {
    spool = (PSBLOCK) Malloc( sizeof(SBLOCK)*MAX_SBLOCKS );
    spidx = 0;
    }
  return( &(spool[spidx++]) );
}

static PBBLOCK MyBBlockAlloc()
{
  if ( bpidx >= MAX_BBLOCKS ) {
    bpool = (PBBLOCK) Malloc( sizeof(BBLOCK)*MAX_BBLOCKS );
    bpidx = 0;
    }
  return( &(bpool[bpidx++]) );
}
/* ***** CANN ***** */

/* Include global variables here */
/*#TITLE  IF1INIT VARIABLES         IFNAug83   Standard IF1 Variables*/
static printable nodename[ifmaxnode + 1];
static printable errvname[ifmaxerror + 1];
static printable typename[ifmaxtype + 1];
static printable basname[ifmaxbasic + 1];
static printable graphname[19];
static ndclasstype nodeclass[ifmaxnode + 1];   /* dlz - 8/87 */
static FILE *source, *diag;
static infilelist infile;
static parrec *outfile;
/* these vars are needed by module using the graph */
static stentry *typetable[entrymax];
static int tthwm;   /* symbol table high water mark */
static int univmodulecnt, univnodecnt, univedgecnt;
static linkrec *funclist;
static node *firstfunction, *module;
static stryng stamp['[' - 'A'];
static long stampset[9];
static semanticrec *topsemstk;   /* Top of Semantic Stack */
static namelistrec *definelist;
/* hold the list of function names
                                     listed in the  stmt that have
                                     not been declared yet.  Should be
                                     empty at the end of the module.  */
static int boostfac;
/* Used to help determine which binary
                                     operation has higher precedence when
                                     () are involved.*/
static long binaryops;
/* Set used to distiguish binary
                                     operators from others*/
static long arithtypes;   /* holds TT labels for int,real,doub */
static long algebtypes;   /* holds TT labels for int,real,doub,bool */
static long streamorarray;
/* holds TT code for stream and
                                                                       array types*/
static namelistrec *includelist;
/* holds stack of names of files that have
                                   been included.  List is checked to avoid
                                   recursive includes*/
static boolean typedefsfinished;
/* Flag to say type def sections is done,
                                   used to know whether to add each piece
                                   of a type into the table or just
                                   smash it in when it is complete*/
/*------------------- SYMBOL TABLE VARS ----------------*/
static treestackobj *currentlevel;   /* pointer to current Lex Level */
/*------------------- DEBUGGER VARS -------------------*/
static long breakpointset[maxsemanticnumber / 32 + 2];
    /* Set of semantic routines to break on */
static int currentstep, stepcount;
static boolean semtrace;
/* Print out names of semantic routines
                                     as they are called it set*/
/*-------------------- COMMAND LINE PARAMS ------------*/
static parrec *xrefparam;
/*--------------------- XREF --------------------------*/
static xrefrec idunsorted[1000];
static int idsorted[1000];
static int idxrefmax;
static inputbuffer *linebuf, *oldline;
static unchar tokenstart;
static int linenumber, tokenlineno;
static boolean endfile;
static int parsestack[maxstack + 1];
static Char stringspace[maxstring + 1];
static boolean epsprod[maxprod + 1];
static int stringptr;
static SHORT stackptr;
static SHORT oldtoken;
static boolean echoed;
static ptabrec *table[maxsym + 3];
static stringrec symkluge[maxsym + 3];
static int prodspace[maxprodspace + 1];
/* all the productions. (strings of symbols) */
static prodrec productions[maxprod + 1];   /* pointers into prodspace*/
static SHORT prodspceptr;
static int numprods, numsymbols;
static stryng inputtoken;
static int toconsume, column;
/* !! variables for error correction */
static int myinfinity, numterms;
static rabrec *readaheadbuf;   /*head of buffer of inserted tokens*/
static FILE *ptableout, *etableout;
/* index : intfile; */
static FILE *inputfile;   /* file to be parsed */
static boolean peeking;
static int errorcount;
    /* histograms of deletions and insertions */
static int tokinserted, tokdeleted;
static char insertspace[maxinsertspace + 1];
static int deletecosts[maxterm + 1];
static insertstringrec costtable[maxsym + 3];
static pretabarray prefixtable;
static char curerrsym;   /* current terminal symbol resident in prefixtable*/
static boolean errortables;
    /* whether error correction tables were created */
static int insertptr, savinsertptr, numdeltried;
    /* number of deletions considered */
static FILE *reservedwords;
/*---------- Current State of the editor ----------*/
static int tokenposition;   /* character position within a token */
/*--------- variables for prettyprinting-------------*/
static unchar debugflags[32];
/*-------- variables for maintaining stringspace ---------*/
/* index of the first element
                                             of CurExtent */
/*--------- variables for the scanner ---------*/
static int inttokenval;
static int ordzero;
static SHORT savetoken;
static Char newcommand;
/* digits          : set of char; */
/* idcharset       : set of char; */
/* resword         : array [ ResWordIndex ] of StringRec; */
/* following added by sks 83/1/31 */
static int singlechar['\177' - ' '];   /* token numbers */
static int reuseindex;
static int statehistory[maxbackup + 1];
static long badcharset[9];
/*------- Super Record, where most of the files are ----------*/
static tablerec p;
static FILE *listfile;
static boolean listing, xref;
static int rea;
static boolean debugcg, debug, cortrace, firsttime, done, commentflag;
static includestackrec *topincludestk;
static stryng curinputfile, newfname;
static int newlinenum;
static parrec *listingparam, *debugparam, *pass1param;
static int semerrcnt;
static parrec *listfparam;
static stryng directoryname, defaultdirectoryname, filename;
static parrec *directoryparam, *paramlist;
static boolean passerr;
static stryng listfilename, stampstr, versionstr, versionnum;


/* Include all desired functions and procedures here */
/*#TITLE  STRUTL  ROUTINES        Jan83   String Handling Routines.*/
/* macro function IsDigit( C: char ): boolean */
/* macro function IsHexOnly( C: char ): boolean */
/* macro function IsLowerCase( C: char ): boolean */
/* macro function IsUpperCase( C: char ): boolean */
/* macro procedure MakeLowerCase( var C: char ) */
/* macro procedure MakeUpperCase( var C: char ) */
/* macro function StringLength( S: Stryng ): integer */
/* macro function IsEmptyString( S: Stryng ): boolean */

static void mymemcpy(s1,s2,n)
char *s1;
char *s2;
int   n;
{
  /* int i; */

  while ( n-- > 0 )
    *s1++ = *s2++;
  /* for ( i = 0; i < n; i++ )
    s1[i] = s2[i]; */
}

static void PASCAL_MAIN(argc, argv)
int argc;
char **argv;
{
    P_argc = argc;
    P_argv = argv;

#ifdef LOCAL_INIT
    LOCAL_INIT();
#endif
}

static int my_toupper(c)
int c;
{
    if (islower(c))
        return z_toupper(c);
    else
        return c;
}


static int my_tolower(c)
int c;
{
    if (isupper(c))
        return z_tolower(c);
    else
        return c;
}

/* Common string functions: */

/* Store in "ret" the substring of length "len" starting from "pos" (1-based).
   Store a shorter or null string if out-of-range.  Return "ret". */



/* Return the index of the first occurrence of "pat" as a substring of "s",
   starting at index "pos" (1-based).  Result is 1-based, 0 if not found. */

/* HP and Turbo Pascal string functions: */

/* Trim blanks at left end of string. */


/* Trim blanks at right end of string. */


/* Store in "ret" "num" copies of string "s".  Return "ret". */



/* Store in "ret" string "s" with enough pad chars added to reach "size". */


/* File functions */

/* Peek at next character of input stream; return EOF at end-of-file. */

static int P_peek(f)
FILE *f;
{
    int ch;

    ch = getc(f);
    if (ch == EOF)
        return EOF;
    ungetc(ch, f);
    return (ch == '\n') ? ' ' : ch;
}


/* Check if at end of file, using Pascal "eof" semantics.  End-of-file for
   stdin is broken; remove the special case for it to be broken in a
   different way. */

static int P_eof(f)
FILE *f;
{
    register int ch;

    if (feof(f))
        return 1;
    if (f == stdin)
        return 0;    /* not safe to look-ahead on the keyboard! */
    ch = getc(f);
    if (ch == EOF)
        return 1;
    ungetc(ch, f);
    return 0;
}


/* Check if at end of line (or end of entire file). */

static int P_eoln(f)
FILE *f;
{
    register int ch;

    ch = getc(f);
    if (ch == EOF)
        return 1;
    ungetc(ch, f);
    return (ch == '\n');
}

/* Read a packed array of characters from a file. */


/* Compute maximum legal "seek" index in file (0-based). */


/* Use packed array of char for a file name. */

/* Pascal's "memavail" doesn't make much sense in Unix with virtual memory.
   We fix memory size as 30Meg as a reasonable compromise. */



/* Sets are stored as an array of longs.  S[0] is the size of the set;
   S[N] is the N'th 32-bit chunk of the set.  S[0] equals the maximum
   I such that S[I] is nonzero.  S[0] is zero for an empty set.  Within
   each long, bits are packed from lsb to msb.  The first bit of the
   set is the element with ordinal value 0.  (Thus, for a "set of 5..99",
   the lowest five bits of the first long are unused and always zero.) */

/* (Sets with 32 or fewer elements are normally stored as plain longs.) */





static int P_inset(val, s)                 /* val IN s */
register unsigned val;
register long *s;
{
    register int bit;
    bit = val % SETBITS;
    val /= SETBITS;
    if (val < *s++ && ((1<<bit) & s[val]))
        return 1;
    return 0;
}

static long *P_addset(s, val)              /* s := s + [val] */
register long *s;
register unsigned val;
{
    register long *sbase = s;
    register int bit, size;
    bit = val % SETBITS;
    val /= SETBITS;
    size = *s;
    if (++val > size) {
        s += size;
        while (val > size)
            *++s = 0, size++;
        *sbase = size;
    } else
        s += val;
    *s |= 1<<bit;
    return sbase;
}


static long *P_addsetr(s, v1, v2)              /* s := s + [v1..v2] */
register long *s;
register unsigned v1, v2;
{
    register long *sbase = s;
    register int b1, b2, size;
    if ((int)v1 > (int)v2)
        return sbase;
    b1 = v1 % SETBITS;
    v1 /= SETBITS;
    b2 = v2 % SETBITS;
    v2 /= SETBITS;
    size = *s;
    v1++;
    if (++v2 > size) {
        while (v2 > size)
            s[++size] = 0;
        s[v2] = 0;
        *s = v2;
    }
    s += v1;
    if (v1 == v2) {
        *s |= (~((-2)<<(b2-b1))) << b1;
    } else {
        *s++ |= (-1) << b1;
        while (++v1 < v2)
            *s++ = -1;
        *s |= ~((-2) << b2);
    }
    return sbase;
}


static long *P_remset(s, val)              /* s := s - [val] */
register long *s;
register unsigned val;
{
    register int bit;
    bit = val % SETBITS;
    val /= SETBITS;
    if (++val <= *s) {
        if (!(s[val] &= ~(1<<bit)))
            while (*s && !s[*s])
                (*s)--;
    }
    return s;
}







/* s is a "smallset", i.e., a 32-bit or less set stored
   directly in a long. */

static long *P_expset(d, s)                /* d := s */
register long *d;
register long s;
{
    if (s) {
        d[1] = s;
        *d = 1;
    } else
        *d = 0;
    return d;
}



/* Oregon Software Pascal extensions, courtesy of William Bader */


#ifdef TURN_BACK_ON
void TimeStamp(Day, Month, Year, Hour, Min, Sec)
int *Day, *Month, *Year, *Hour, *Min, *Sec;
{
#ifndef NO_TIME
    struct tm *tm;
    /* long clock; */
    time_t clock;  /* Oct, 1991 */

    time(&clock);
    tm = localtime(&clock);
    *Day = tm->tm_mday;
    *Month = tm->tm_mon + 1;            /* Jan = 0 */
    *Year = tm->tm_year;
    if (*Year < 1900)
        *Year += 1900;     /* year since 1900 */
    *Hour = tm->tm_hour;
    *Min = tm->tm_min;
    *Sec = tm->tm_sec;
#endif
}
#endif




/* SUN Berkeley Pascal extensions */

static void P_sun_argv(s, len, n)
register char *s;
register int len, n;
{
    register char *cp;

    if ((unsigned)n < P_argc)
        cp = P_argv[n];
    else
        cp = "";
    while (*cp && --len >= 0)
        *s++ = *cp++;
    while (--len >= 0)
        *s++ = ' ';
}


/* int _OutMem() */
static Anyptr _OutMem()
{
    /* return _Escape(-2); */
    /* TO AVOID int->char* COERSION WARNING MESSAGES ON SOME MACHINES */
    _Escape(-2);
    return( (Anyptr) NULL );
}




/* The following is suitable for the HP Pascal operating system.
   It might want to be revised when emulating another system. */

static char *_ShowEscape(char*,int,int,char*);
static char *_ShowEscape(buf, code, ior, prefix)
char *buf, *prefix;
int code, ior;
{
    char *bufp;

    if (prefix && *prefix) {
        strcpy(buf, prefix);
        strcat(buf, ": ");
        bufp = buf + strlen(buf);
    } else {
        bufp = buf;
    }
    if (code == -10) {
        sprintf(bufp, "Pascal system I/O error %d", ior);
        switch (ior) {
            case 3:
                strcat(buf, " (illegal I/O request)");
                break;
            case 7:
                strcat(buf, " (bad file name)");
                break;
            case FileNotFound:   /*10*/
                strcat(buf, " (file not found)");
                break;
            case FileNotOpen:    /*13*/
                strcat(buf, " (file not open)");
                break;
            case BadInputFormat: /*14*/
                strcat(buf, " (bad input format)");
                break;
            case 24:
                strcat(buf, " (not open for reading)");
                break;
            case 25:
                strcat(buf, " (not open for writing)");
                break;
            case 26:
                strcat(buf, " (not open for direct access)");
                break;
            case 28:
                strcat(buf, " (string subscript out of range)");
                break;
            case EndOfFile:      /*30*/
                strcat(buf, " (end-of-file)");
                break;
            case FileWriteError: /*38*/
                strcat(buf, " (file write error)");
                break;
        }
    } else {
        sprintf(bufp, "Pascal system error %d", code);
        switch (code) {
            case -2:
                strcat(buf, " (out of memory)");
                break;
            case -3:
                strcat(buf, " (reference to NIL pointer)");
                break;
            case -4:
                strcat(buf, " (integer overflow)");
                break;
            case -5:
                strcat(buf, " (divide by zero)");
                break;
            case -6:
                strcat(buf, " (real math overflow)");
                break;
            case -8:
                strcat(buf, " (value range error)");
                break;
            case -9:
                strcat(buf, " (CASE value range error)");
                break;
            case -12:
                strcat(buf, " (bus error)");
                break;
            case -20:
                strcat(buf, " (stopped by user)");
                break;
        }
    }
    return buf;
}


static int _Escape(code)
int code;
{
    char buf[100];

    P_escapecode = code;
    if (code == 0)
        CANN_exit(0);
    if (code == -1)
        CANN_exit(1);
    fprintf(stderr, "%s\n", _ShowEscape(buf, P_escapecode, P_ioresult, ""));
    CANN_exit(1);
    return code;
}

int _EscIO(code)
int code;
{
    P_ioresult = code;
    return _Escape(-10);
}





static Char stringchar(s, n)
stryng *s;
int n;
{
  if (n > s->len)
    return ' ';
  else
    return (s->str[n - 1]);
}


static void clearstring(s, first, last)
stryng *s;
char first, last;
{
  char i;

  for (i = first - 1; i < last; i++)
    s->str[(int)i] = ' ';
  s->len = first - 1;
}



/* macro procedure InitString( S: Stryng )  */
static void insertchar(s, c, p)
stryng *s;
Char c;
char p;
{
  int i;

  if (s->len < p - 1)
    s->len = p - 1;
  if (s->len != maxstringchars)
    s->len++;
  for (i = s->len; i > p; i--)
    s->str[i - 1] = s->str[i - 2];
  s->str[p - 1] = c;
}


static void concatchar(s, c)
stryng *s;
Char c;
{
  if (s->len < maxstringchars) {
    s->len++;
    s->str[s->len - 1] = c;
  }
}


/* macro procedure CharString( S: Stryng; C: Char ) */
static void stripspaces(s)
stryng *s;
{
  boolean spaces;

  spaces = (s->len > 0);
  while (spaces) {
    if (s->str[s->len - 1] != ' ') {
      spaces = false;
      break;
    }
    s->len--;
    if (s->len == 0)
      spaces = false;
  }
}


static void string10(s, s10)
stryng *s;
Char *s10;
{
  int i;

  for (i = 0; i <= 9; i++)
    s->str[i] = s10[i];
  clearstring(s, 11, maxstringchars);
  stripspaces(s);
}


static void string20(s, s20)
stryng *s;
Char *s20;
{
  int i;

  for (i = 0; i <= 19; i++)
    s->str[i] = s20[i];
  clearstring(s, 21, maxstringchars);
  stripspaces(s);
}



static void insertstring(s, t, p)
stryng *s, *t;
char p;
{
  int i, j, FORLIM;

  if (s->len < p - 1)
    s->len = p - 1;
  if (s->len + t->len <= maxstringchars)
    s->len += t->len;
  else
    s->len = maxstringchars;
  FORLIM = p + t->len - 1;
  for (i = s->len - 1; i >= FORLIM; i--)
    s->str[i] = s->str[i - t->len];
  if (s->len < p + t->len)
    j = s->len;
  else
    j = p + t->len - 1;
  for (i = p; i <= j; i++)
    s->str[i - 1] = t->str[i - p];
}


/* macro procedure ConcatString( var S: Stryng; T: Stryng ) */
static void readstring(fil, s)
FILE *fil;
stryng *s;
{
  Char ch;

  s->len = 0;
  while (!P_eoln(fil) && s->len < maxstringchars) {
    s->len++;
    ch = getc(fil);
    if (ch == '\n')
      ch = ' ';
    s->str[s->len - 1] = ch;
  }
  if (s->len < maxstringchars)
    clearstring(s, s->len + 1, maxstringchars);
  fscanf(fil, "%*[^\n]");
  getc(fil);
}





static void writestring(fil, s)
FILE *fil;
stryng *s;
{
  int i, FORLIM;

  FORLIM = s->len;
  for (i = 0; i < FORLIM; i++)
    putc(s->str[i], fil);
}


static void substring(t, s, first, last)
stryng *t, *s;
char first;
int last;
{
  int i, FORLIM;

  if (last > s->len)
    last = s->len;
  if (first > last)
    first = last + 1;
  else {
    FORLIM = last - first;
    for (i = 0; i <= FORLIM; i++)
      t->str[i] = s->str[i + first - 1];
  }
  clearstring(t, last - first + 2, maxstringchars);
}


static void deletestring(s, first, last)
stryng *s;
char first;
int last;
{
  int i, offset, FORLIM;

  if (last > s->len)
    last = s->len;
  if (first > last)
    first = last + 1;
  offset = last - first + 1;
  FORLIM = s->len;
  for (i = last; i < FORLIM; i++)
    s->str[i - offset] = s->str[i];
  clearstring(s, s->len - offset + 1, s->len);
}


static Char uppercase(c)
Char c;
{
  if (islower(c))
    return z_toupper(c);
  else
    return c;
}


static void stringuppercase(s)
stryng *s;
{
  int i, FORLIM;

  FORLIM = s->len;
  for (i = 0; i < FORLIM; i++) {
    if (islower(s->str[i]))
      s->str[i] = z_toupper(s->str[i]);
  }
}


static Char lowercase(c)
Char c;
{
  if (isupper(c))
    return z_tolower(c);
  else
    return c;
}


static void stringlowercase(s)
stryng *s;
{
  int i, FORLIM;

  /*StringLowerCase*/
  FORLIM = s->len;
  for (i = 0; i < FORLIM; i++) {
    if (isupper(s->str[i]))
      s->str[i] = z_tolower(s->str[i]);
  }
}


static boolean matchstrings(s1, s2, pos)
stryng *s1, *s2;
char pos;
{
  int i, ix;
  boolean res;
  int FORLIM;

  /* Convert to offset in index */
  ix = pos - 1;
  /* Check first string is long enough */
  if (s2->len < s1->len + ix)
    return false;
  else {
    res = true;
    FORLIM = s1->len;
    for (i = 0; i < FORLIM; i++) {
      if (s2->str[i + ix] != s1->str[i])
        res = false;
    }
    return res;
  }
}


static boolean equalstrings(s1, s2)
stryng *s1, *s2;
{
  if (s1->len == s2->len)
    return (matchstrings(s1, s2, 1));
  else
    return false;
}



static int findchar(c, s, pos)
Char c;
stryng *s;
char pos;
{
  int Result, i;

  Result = 0;
  for (i = s->len; i >= pos; i--) {
    if (s->str[i - 1] == c)
      Result = i;
  }
  return Result;
}


static int findstring(s, t, pos)
stryng *s, *t;
char pos;
{
  int chpos;
  boolean match;

  if (s->len == 0)
    return pos;
  else {
    match = false;
    chpos = pos - 1;
    do {
      chpos = findchar(s->str[0], t, chpos + 1);
      if (chpos != 0)
        match = matchstrings(s, t, chpos);
    } while (!(match || chpos == 0));
    return chpos;
  }
}


static int findlastchar(c, s)
Char c;
stryng *s;
{
  int Result, i, FORLIM;

  Result = 0;
  FORLIM = s->len;
  for (i = 1; i <= FORLIM; i++) {
    if (s->str[i - 1] == c)
      Result = i;
  }
  return Result;
}


static void numberstring(s, n, base)
stryng *s;
int n, base;
{
  int sign, ch;

  mymemcpy(s->str, blankstring, sizeof(stryngar));
  s->len = 0;
  if (n < 0)
    sign = -1;
  else
    sign = 1;
  do {
    ch = sign * (n % base);
/* p2c: mono.bin.noblank.p, line 1906:
 * Note: Using % for possibly-negative arguments [317] */
    if (ch < 10)
      ch += '0';
    else
      ch += '7';
    insertchar(s, ch, 1);
    n /= base;
  } while (n != 0);
  if (sign == -1)
    insertchar(s, '-', 1);
}


static void integerstring(s, n, width)
stryng *s;
int n, width;
{
  numberstring(s, n, 10);
  while (s->len < width)
    insertchar(s, ' ', 1);
}


static int charval(ch)
Char ch;
{
  ch = uppercase(ch);
  if (isdigit(ch))
    return (ch - '0');
  else {
    if (ch >= 'A' && ch <= 'F')
      return (ch - 55);
    else
      return 16;
  }
}


static long stringnumber(s, pos, base)
stryng *s;
int *pos, base;
{
  long maxdivbase, maxmodbase, newval, res;
  boolean neg;

  /* StringNumber */
  neg = false;
  if (base < 2 || base > 16)
    base = 16;
  maxdivbase = maxbigint / base;
  maxmodbase = maxbigint % base;
  res = 0;
  while (*pos < s->len && s->str[*pos - 1] == ' ')
    (*pos)++;
  if (s->str[*pos - 1] == '-' || s->str[*pos - 1] == '+') {
    if (s->str[*pos - 1] == '-')
      neg = true;
    (*pos)++;
  }
  while (*pos < s->len && s->str[*pos - 1] == ' ')
    (*pos)++;
  while ((res >= 0) && (charval(s->str[*pos - 1]) < base)) {
    newval = charval(s->str[*pos - 1]);
    if (res < maxdivbase || (res == maxdivbase && newval <= maxmodbase)) {
      res = res * base + newval;
      (*pos)++;
    } else
      res = -maxbigint;
  }
  if (neg)
    return (-res);
  else
    return res;
}


/*#TITLE  IF1INIT ROUTINES          IFNAug83   Standard IF1 Routines*/
static void initnames()
{
  int i;

  /* InitNames */
  /* Node Identifiers */
  for (i = 0; i <= ifmaxnode; i++)
    mymemcpy(nodename[i], "*************** ", sizeof(printable));
  /* Compound Nodes */
  mymemcpy(nodename[ifnselect], "Select          ", sizeof(printable));
  mymemcpy(nodename[ifnloopb], "LoopB           ", sizeof(printable));
  mymemcpy(nodename[ifnloopa], "LoopA           ", sizeof(printable));
  mymemcpy(nodename[ifnforall], "Forall          ", sizeof(printable));
  mymemcpy(nodename[ifntagcase], "TagCase         ", sizeof(printable));
  mymemcpy(nodename[ifnmodule], "Module          ", sizeof(printable));
  mymemcpy(nodename[ifnifthenelse], "IfThenElse      ", sizeof(printable));
  mymemcpy(nodename[ifniter], "Iter            ", sizeof(printable));
  /* Simple Node */
  mymemcpy(nodename[ifnaaddh], "AAddH           ", sizeof(printable));
  mymemcpy(nodename[ifnaaddl], "AAddL           ", sizeof(printable));
  mymemcpy(nodename[ifnaextract], "AExtract        ", sizeof(printable));
  mymemcpy(nodename[ifnabuild], "ABuild          ", sizeof(printable));
  mymemcpy(nodename[ifnacatenate], "ACatenate       ", sizeof(printable));
  mymemcpy(nodename[ifnaelement], "AElement        ", sizeof(printable));
  mymemcpy(nodename[ifnafill], "AFill           ", sizeof(printable));
  mymemcpy(nodename[ifnagather], "AGather         ", sizeof(printable));
  mymemcpy(nodename[ifnaisempty], "AIsEmpty        ", sizeof(printable));
  mymemcpy(nodename[ifnalimh], "ALimH           ", sizeof(printable));
  mymemcpy(nodename[ifnaliml], "ALimL           ", sizeof(printable));
  mymemcpy(nodename[ifnaremh], "ARemH           ", sizeof(printable));
  mymemcpy(nodename[ifnareml], "ARemL           ", sizeof(printable));
  mymemcpy(nodename[ifnareplace], "AReplace        ", sizeof(printable));
  mymemcpy(nodename[ifnascatter], "AScatter        ", sizeof(printable));
  mymemcpy(nodename[ifnasetl], "ASetL           ", sizeof(printable));
  mymemcpy(nodename[ifnasize], "ASize           ", sizeof(printable));
  mymemcpy(nodename[ifnabs], "Abs             ", sizeof(printable));
/* CANN PEEK */  mymemcpy(nodename[ifnpeek], "Peek            ", sizeof(printable));
  mymemcpy(nodename[ifnbindarguments], "BindArguments   ", sizeof(printable));
  mymemcpy(nodename[ifnbool], "Bool            ", sizeof(printable));
  mymemcpy(nodename[ifncall], "Call            ", sizeof(printable));
  mymemcpy(nodename[ifnchar], "Char            ", sizeof(printable));
  mymemcpy(nodename[ifndiv], "Div             ", sizeof(printable));
  mymemcpy(nodename[ifndouble], "Double          ", sizeof(printable));
  mymemcpy(nodename[ifnequal], "Equal           ", sizeof(printable));
  mymemcpy(nodename[ifnexp], "Exp             ", sizeof(printable));
  mymemcpy(nodename[ifnfirstvalue], "FirstValue      ", sizeof(printable));
  mymemcpy(nodename[ifnfinalvalue], "FinalValue      ", sizeof(printable));
  mymemcpy(nodename[ifnfloor], "Floor           ", sizeof(printable));
  mymemcpy(nodename[ifnint], "Int             ", sizeof(printable));
  mymemcpy(nodename[ifniserror], "IsError         ", sizeof(printable));
  mymemcpy(nodename[ifnless], "Less            ", sizeof(printable));
  mymemcpy(nodename[ifnlessequal], "LessEqual       ", sizeof(printable));
  mymemcpy(nodename[ifnmax], "Max             ", sizeof(printable));
  mymemcpy(nodename[ifnmin], "Min             ", sizeof(printable));
  mymemcpy(nodename[ifnminus], "Minus           ", sizeof(printable));
  mymemcpy(nodename[ifnmod], "Mod             ", sizeof(printable));
  mymemcpy(nodename[ifnneg], "Neg             ", sizeof(printable));
  mymemcpy(nodename[ifnnoop], "NoOp            ", sizeof(printable));
  mymemcpy(nodename[ifnnot], "Not             ", sizeof(printable));
  mymemcpy(nodename[ifnnotequal], "NotEqual        ", sizeof(printable));
  mymemcpy(nodename[ifnplus], "Plus            ", sizeof(printable));
  mymemcpy(nodename[ifnrangegenerate], "RangeGenerate   ", sizeof(printable));
  mymemcpy(nodename[ifnrbuild], "RBuild          ", sizeof(printable));
  mymemcpy(nodename[ifnrelements], "RElements       ", sizeof(printable));
  mymemcpy(nodename[ifnrreplace], "RReplace        ", sizeof(printable));
  mymemcpy(nodename[ifnreduce], "Reduce          ", sizeof(printable));
  mymemcpy(nodename[ifnredleft], "ReduceLeft      ", sizeof(printable));
  mymemcpy(nodename[ifnredright], "ReduceRight     ", sizeof(printable));
  mymemcpy(nodename[ifnredtree], "ReduceTree      ", sizeof(printable));
  mymemcpy(nodename[ifnallbutlastvalue], "AllButLastVal   ", sizeof(printable));
  mymemcpy(nodename[ifnsingle], "Single          ", sizeof(printable));
  mymemcpy(nodename[ifntimes], "Times           ", sizeof(printable));
  mymemcpy(nodename[ifntrunc], "Trunc           ", sizeof(printable));
  mymemcpy(nodename[ifnaprefixsize], "APrefixSize     ", sizeof(printable));
  mymemcpy(nodename[ifnareplacen], "AReplaceN       ", sizeof(printable));
  mymemcpy(nodename[ifnspawn], "Spawn           ", sizeof(printable));
  mymemcpy(nodename[ifnfilter], "Filter          ", sizeof(printable));
  mymemcpy(nodename[ifnashift], "AShift          ", sizeof(printable));
  mymemcpy(nodename[ifnarraytobuf], "ArrayToBuf      ", sizeof(printable));
  mymemcpy(nodename[ifnrecordtobuf], "RecordToBuf     ", sizeof(printable));
  mymemcpy(nodename[ifnshiftbuffer], "ShiftBuffer     ", sizeof(printable));
  mymemcpy(nodename[ifnabufscatter], "ABufScatter     ", sizeof(printable));
  mymemcpy(nodename[ifnabufpartition], "ABufPartition   ", sizeof(printable));
  mymemcpy(nodename[ifnrbufelements], "RBufElements    ", sizeof(printable));
  mymemcpy(nodename[ifnabuildat], "ABuildAt        ", sizeof(printable));
  mymemcpy(nodename[ifnafillat], "AFillAt         ", sizeof(printable));
  mymemcpy(nodename[ifnareplaceat], "AReplaceAt      ", sizeof(printable));
  mymemcpy(nodename[ifnasetlat], "ASetLAt         ", sizeof(printable));
  mymemcpy(nodename[ifnaelementsat], "AElementsAt     ", sizeof(printable));
  mymemcpy(nodename[ifnacatenateat], "ACatenateAt     ", sizeof(printable));
  mymemcpy(nodename[ifnaremlat], "ARemLAt         ", sizeof(printable));
  mymemcpy(nodename[ifnaremhat], "ARemHAt         ", sizeof(printable));
  mymemcpy(nodename[ifnaaddlat], "AAddLAt         ", sizeof(printable));
  mymemcpy(nodename[ifnaaddhat], "AAddHAt         ", sizeof(printable));
  mymemcpy(nodename[ifnaextractat], "AExtractAt      ", sizeof(printable));
  mymemcpy(nodename[ifnrbuildat], "RBuildAt        ", sizeof(printable));
  mymemcpy(nodename[ifnrelementsat], "RElementsAt     ", sizeof(printable));
  mymemcpy(nodename[ifnagatherat], "AGatherAt       ", sizeof(printable));
  mymemcpy(nodename[ifnreduceat], "ReduceAt        ", sizeof(printable));
  mymemcpy(nodename[ifnfinalvalueat], "FinalValueAt    ", sizeof(printable));
  mymemcpy(nodename[ifndefarraybuf], "DefArrayBuf     ", sizeof(printable));
  mymemcpy(nodename[ifndefrecordbuf], "DefRecordBuf    ", sizeof(printable));
  mymemcpy(nodename[ifnmemalloc], "MemAlloc        ", sizeof(printable));
  mymemcpy(nodename[ifncondsetrefcnt], "CondSetRefCnt   ", sizeof(printable));
  /* Graph Names */
  mymemcpy(graphname[(long)ifgfunction], "Function        ", sizeof(printable));
  mymemcpy(graphname[(long)ifgselector], "Selector        ", sizeof(printable));
  mymemcpy(graphname[(long)ifgalternative], "Alternative     ",
         sizeof(printable));
  mymemcpy(graphname[(long)ifgvariant], "Variant         ", sizeof(printable));
  mymemcpy(graphname[(long)ifgloopainit], "LoopAInit       ", sizeof(printable));
  mymemcpy(graphname[(long)ifgloopabody], "LoopABody       ", sizeof(printable));
  mymemcpy(graphname[(long)ifgloopatest], "LoopATest       ", sizeof(printable));
  mymemcpy(graphname[(long)ifgloopareturns], "LoopAReturns    ",
         sizeof(printable));
  mymemcpy(graphname[(long)ifgloopbinit], "LoopBInit       ", sizeof(printable));
  mymemcpy(graphname[(long)ifgloopbbody], "LoopBBody       ", sizeof(printable));
  mymemcpy(graphname[(long)ifgloopbtest], "LoopBTest       ", sizeof(printable));
  mymemcpy(graphname[(long)ifgloopbreturns], "LoopBReturns    ",
         sizeof(printable));
  mymemcpy(graphname[(long)ifgforallgenerator], "ForallGenerate  ",
         sizeof(printable));
  mymemcpy(graphname[(long)ifgforallbody], "ForallBody      ",
         sizeof(printable));
  mymemcpy(graphname[(long)ifgforallreturns], "ForallReturns   ",
         sizeof(printable));
  mymemcpy(graphname[(long)ifgifpredicate], "IfPredicate     ",
         sizeof(printable));
  mymemcpy(graphname[(long)ifgiftrue], "IfTrue          ", sizeof(printable));
  mymemcpy(graphname[(long)ifgiffalse], "IfFalse         ", sizeof(printable));
  mymemcpy(graphname[(long)ifgiterbody], "IterBody        ", sizeof(printable));
  /* Error Values */
  mymemcpy(errvname[ifeerror], "Error           ", sizeof(printable));
  mymemcpy(errvname[ifeundef], "Undef           ", sizeof(printable));
  mymemcpy(errvname[ifebroken], "Broken          ", sizeof(printable));
  mymemcpy(errvname[ifemiselt], "MisElt          ", sizeof(printable));
  mymemcpy(errvname[ifeposover], "PosOver         ", sizeof(printable));
  mymemcpy(errvname[ifenegover], "NegOver         ", sizeof(printable));
  mymemcpy(errvname[ifeposunder], "PosUnder        ", sizeof(printable));
  mymemcpy(errvname[ifenegunder], "NegUnder        ", sizeof(printable));
  mymemcpy(errvname[ifezerodivide], "ZeroDivide      ", sizeof(printable));
  mymemcpy(errvname[ifeunknown], "Unknown         ", sizeof(printable));
  mymemcpy(errvname[ifenoerror], "NoError         ", sizeof(printable));
  mymemcpy(errvname[ifenovalue], "NoValue         ", sizeof(printable));
  mymemcpy(errvname[ifmrnovalue], "NoMRValue       ", sizeof(printable));
  /* Type Values */
  mymemcpy(typename[iftbasic], "Basic           ", sizeof(printable));
  mymemcpy(typename[iftfunctiontype], "Function        ", sizeof(printable));
  mymemcpy(typename[iftarray], "Array           ", sizeof(printable));
  mymemcpy(typename[iftstream], "Stream          ", sizeof(printable));
  mymemcpy(typename[iftmultiple], "Multiple        ", sizeof(printable));
  mymemcpy(typename[iftrecord], "Record          ", sizeof(printable));
  mymemcpy(typename[ifttuple], "Tuple           ", sizeof(printable));
  mymemcpy(typename[iftunion], "Union           ", sizeof(printable));
  mymemcpy(typename[iftfield], "Field           ", sizeof(printable));
  mymemcpy(typename[ifttag], "Tag             ", sizeof(printable));
  mymemcpy(typename[iftwild], "Wild            ", sizeof(printable));
  mymemcpy(typename[iftbuffer], "Buffer          ", sizeof(printable));
  /* Base Type Values */
  mymemcpy(basname[ifbboolean], "Boolean         ", sizeof(printable));
  mymemcpy(basname[ifbcharacter], "Character       ", sizeof(printable));
  mymemcpy(basname[ifbinteger], "Integer         ", sizeof(printable));
  mymemcpy(basname[ifbreal], "Real            ", sizeof(printable));
  mymemcpy(basname[ifbdouble], "Double          ", sizeof(printable));
  mymemcpy(basname[ifbnull], "Null            ", sizeof(printable));
  mymemcpy(basname[ifbwild], "Wild            ", sizeof(printable));
  /* Node Classifications */
  for (i = 0; i <= ifmaxnode; i++)
    nodeclass[i] = unknown;
  /* Compound Nodes */
  nodeclass[ifnselect] = controlabstr;
  nodeclass[ifnloopb] = controlabstr;
  nodeclass[ifnloopa] = controlabstr;
  nodeclass[ifnforall] = controlabstr;
  nodeclass[ifntagcase] = controlabstr;
  nodeclass[ifniter] = controlabstr;
  nodeclass[ifnifthenelse] = controlabstr;
  /* Not real sure about these .... */
  nodeclass[ifnmodule] = unclassified;
  nodeclass[ifngraph] = graphnode;
  nodeclass[ifncondsetrefcnt] = unclassified;
  /* Simple Node */
  nodeclass[ifnaaddh] = structurebuild;
  nodeclass[ifnaaddl] = structurebuild;
  nodeclass[ifnaextract] = structureaccess;
  nodeclass[ifnabuild] = structurebuild;
  nodeclass[ifnacatenate] = structurebuild;
  nodeclass[ifnaelement] = structureaccess;
  nodeclass[ifnafill] = structurebuild;
  nodeclass[ifnagather] = structurebuild;
  nodeclass[ifnaisempty] = structureaccess;
  nodeclass[ifnalimh] = structureaccess;
  nodeclass[ifnaliml] = structureaccess;
  nodeclass[ifnaremh] = structureaccess;
  nodeclass[ifnareml] = structureaccess;
  nodeclass[ifnareplace] = structurebuild;
  nodeclass[ifnascatter] = multiplegenr;
  nodeclass[ifnasetl] = indexchange;
  nodeclass[ifnasize] = structureaccess;
  nodeclass[ifnabs] = unaryalgeb;

/* PEEK CANN */ nodeclass[ifnpeek] = unclassified;

  nodeclass[ifnbindarguments] = functioninvoke;
  nodeclass[ifnbool] = unaryalgeb;
  nodeclass[ifncall] = functioninvoke;
  nodeclass[ifnchar] = unaryalgeb;
  nodeclass[ifndiv] = binaryalgeb;
  nodeclass[ifndouble] = unaryalgeb;
  nodeclass[ifnequal] = binaryalgeb;
  nodeclass[ifnexp] = binaryalgeb;
  nodeclass[ifnfirstvalue] = multiplefilter;
  nodeclass[ifnfinalvalue] = multiplefilter;
  nodeclass[ifnfloor] = unaryalgeb;
  nodeclass[ifnint] = unaryalgeb;
  nodeclass[ifniserror] = unaryalgeb;
  nodeclass[ifnless] = binaryalgeb;
  nodeclass[ifnlessequal] = binaryalgeb;
  nodeclass[ifnmax] = binaryalgeb;
  nodeclass[ifnmin] = binaryalgeb;
  nodeclass[ifnminus] = binaryalgeb;
  nodeclass[ifnmod] = binaryalgeb;
  nodeclass[ifnneg] = unaryalgeb;
  nodeclass[ifnnoop] = unaryalgeb;
  nodeclass[ifnnot] = unaryalgeb;
  nodeclass[ifnnotequal] = binaryalgeb;
  nodeclass[ifnplus] = binaryalgeb;
  nodeclass[ifnrangegenerate] = multiplegenr;
  nodeclass[ifnrbuild] = structurebuild;
  nodeclass[ifnrelements] = structureaccess;
  nodeclass[ifnrreplace] = structurebuild;
  nodeclass[ifnreduce] = multiplereduct;
  nodeclass[ifnredleft] = multiplereduct;
  nodeclass[ifnredright] = multiplereduct;
  nodeclass[ifnredtree] = multiplereduct;
  nodeclass[ifnallbutlastvalue] = multiplefilter;
  nodeclass[ifnsingle] = unaryalgeb;
  nodeclass[ifntimes] = unaryalgeb;
  nodeclass[ifntrunc] = unaryalgeb;
  nodeclass[ifnaprefixsize] = structureaccess;
  nodeclass[ifnareplacen] = structurebuild;
  nodeclass[ifnspawn] = controlabstr;
  nodeclass[ifnfilter] = multiplefilter;
  nodeclass[ifnashift] = indexchange;
  /*IF2 Nodes*/
  nodeclass[ifnarraytobuf] = bufferbuild;
  nodeclass[ifnrecordtobuf] = bufferbuild;
  nodeclass[ifnshiftbuffer] = indexchange;
  nodeclass[ifnabufscatter] = buffergenr;
  nodeclass[ifnabufpartition] = bufferaccess;
  nodeclass[ifnrbufelements] = bufferaccess;
  nodeclass[ifnabuildat] = bufferbuild;
  nodeclass[ifnafillat] = bufferbuild;
  nodeclass[ifnareplaceat] = bufferbuild;
  nodeclass[ifnasetlat] = indexchange;
  nodeclass[ifnaelementsat] = bufferaccess;
  nodeclass[ifnacatenateat] = bufferbuild;
  nodeclass[ifnaremlat] = bufferaccess;
  nodeclass[ifnaremhat] = bufferaccess;
  nodeclass[ifnaaddlat] = bufferbuild;
  nodeclass[ifnaaddhat] = bufferbuild;
  nodeclass[ifnaextractat] = bufferaccess;
  nodeclass[ifnrbuildat] = bufferbuild;
  nodeclass[ifnrelementsat] = bufferaccess;
  nodeclass[ifnagatherat] = bufferreduct;
  nodeclass[ifnreduceat] = bufferreduct;
  nodeclass[ifnfinalvalueat] = bufferreduct;
  nodeclass[ifndefarraybuf] = bufferdefine;
  nodeclass[ifndefrecordbuf] = bufferdefine;
  nodeclass[ifnmemalloc] = bufferdefine;
}


/* #include "../util/c.h" */
/* copyright (C) 1986 by the Regents of the University of California */


/*#TITLE  FILUTL  ROUTINES        Jul83   File Handling Routines.*/
/*
**  Code for BuildName and Splitname tends to be common to all systems
*/
static void buildname(newname, dev, name, ext)
stryng *newname, dev, name, ext;
{
  if (dev.len > 0)
    *newname = dev;
  else {
    mymemcpy(newname->str, blankstring, sizeof(stryngar));
    newname->len = 0;
  }
  if (newname->len < maxstringchars)
    insertstring(newname, &name, newname->len + 1);
  if (ext.len <= 0)
    return;
  concatchar(newname, '.');
  if (newname->len < maxstringchars)
    insertstring(newname, &ext, newname->len + 1);
}


static void splitname(origname, dev, name, ext)
stryng *origname, *dev, *name, *ext;
{
  int pos, len;

  /* SplitName */
  *name = *origname;
  pos = findlastchar('.', name);
  if (pos > 0) {
    len = name->len;
    substring(ext, name, pos + 1, len);
    deletestring(name, pos, len);
  } else {
    mymemcpy(ext->str, blankstring, sizeof(stryngar));
    ext->len = 0;
  }
  pos = 0;
  if (pos > 0) {
    substring(dev, name, 1, pos - 1);
    deletestring(name, 1, pos);
  } else {
    mymemcpy(dev->str, blankstring, sizeof(stryngar));
    dev->len = 0;
  }
}


static void defaultfilename(name, defname)
stryng *name, *defname;
{
  stryng namedev, namenom, nameext, defdev, defnom, defext;

  /* DefaultFileName */
  splitname(name, &namedev, &namenom, &nameext);
  splitname(defname, &defdev, &defnom, &defext);
  if (namedev.len == 0)
    namedev = defdev;
  if (namenom.len == 0)
    namenom = defnom;
  if (nameext.len == 0)
    nameext = defext;
  buildname(name, namedev, namenom, nameext);
}


/*
**  The rest of the functions tend to be system specific
*/
boolean openread(fil, nom)
FILE **fil;
stryng *nom;
{
  boolean Result;
  stryng s;
  int mode, filedescriptor;
  Char STR1[256];

  s = *nom;
  stripspaces(&s);
  concatchar(&s, '\0');
  mode = 0;   /* mode=0 to read */
  filedescriptor = open(s.str, mode);
  if (filedescriptor == -1)
    return false;
  Result = true;
  filedescriptor = close(filedescriptor);
  if (*fil != NULL) {
    sprintf(STR1, "%.*s", maxstringchars, s.str);
    *fil = freopen(STR1, "r", *fil);
  } else {
    sprintf(STR1, "%.*s", maxstringchars, s.str);
    *fil = fopen(STR1, "r");
  }
  if (*fil == NULL)
    _EscIO(FileNotFound);
  return Result;
}


boolean openintread(fil, nom)
FILE **fil;
stryng *nom;
{
  boolean Result;
  stryng s;
  int mode, filedescriptor;
  Char STR1[256];

  s = *nom;
  stripspaces(&s);
  concatchar(&s, '\0');
  mode = 0;   /* mode=0 to read */
  filedescriptor = open(s.str, mode);
  if (filedescriptor == -1)
    return false;
  Result = true;
  filedescriptor = close(filedescriptor);
  if (*fil != NULL) {
    sprintf(STR1, "%.*s", maxstringchars, s.str);
    *fil = freopen(STR1, "r", *fil);
  } else {
    sprintf(STR1, "%.*s", maxstringchars, s.str);
    *fil = fopen(STR1, "r");
  }
  if (*fil == NULL)
    _EscIO(FileNotFound);
  return Result;
}



/* procedure CloseRead( var Fil: Text ); is a no-op on Unix*/
boolean openwrite(fil, nom)
FILE **fil;
stryng *nom;
{
  boolean Result;
  int mode, filedescriptor;
  stryng s;
  Char STR1[256];

  s = *nom;
  stripspaces(&s);
  concatchar(&s, '\0');
  mode = 1;   /* mode=1 to write */
  filedescriptor = open(s.str, mode);
  if (filedescriptor == -1) {
    mode = 438;
    filedescriptor = creat(s.str, mode);
    if (filedescriptor == -1)
      return false;
    Result = true;
    filedescriptor = close(filedescriptor);
    if (*fil != NULL) {
      sprintf(STR1, "%.*s", maxstringchars, s.str);
      *fil = freopen(STR1, "w", *fil);
    } else {
      sprintf(STR1, "%.*s", maxstringchars, s.str);
      *fil = fopen(STR1, "w");
    }
    if (*fil == NULL)
      _EscIO(FileNotFound);
    return Result;
  }
  Result = true;
  filedescriptor = close(filedescriptor);
  if (*fil != NULL) {
    sprintf(STR1, "%.*s", maxstringchars, s.str);
    *fil = freopen(STR1, "w", *fil);
  } else {
    sprintf(STR1, "%.*s", maxstringchars, s.str);
    *fil = fopen(STR1, "w");
  }
  if (*fil == NULL)
    _EscIO(FileNotFound);
  return Result;
}


boolean canwrite(nom)
stryng *nom;
{
  boolean Result;
  int mode, filedescriptor;
  stryng s;

  s = *nom;
  stripspaces(&s);
  concatchar(&s, '\0');
  mode = 1;   /* mode=1 to write */
  filedescriptor = open(s.str, mode);
  if (filedescriptor != -1) {
    Result = true;
    filedescriptor = close(filedescriptor);
    return Result;
  }
  mode = 0;   /* mode=0 to read */
  filedescriptor = open(s.str, mode);
  if (filedescriptor != -1) {   /*can read but can't write*/
    filedescriptor = close(filedescriptor);
    return false;
  }
  mode = 438;
  filedescriptor = creat(s.str, mode);
  if (filedescriptor == -1)
    return false;
  Result = true;
  filedescriptor = close(filedescriptor);
  return Result;

  /*can't read or write; try to create it*/
}


/* procedure CloseWrite( var Fil: Text ); is a no-op on Unix*/


/* procedure Page( var Fil: Text ); is defined on unix */
static void gettermline(termline, termtext)
stryng *termline, *termtext;
{
  writestring(stdout, termtext);
  readstring(stdin, termline);
}


static void getcommandline(cmdline)
stryng *cmdline;
{
  stryng sarg;
  stryngar arg;
  int narg, i;

  /* GetCommandLine */
  mymemcpy(cmdline->str, blankstring, sizeof(stryngar));
  cmdline->len = 0;
  narg = P_argc - 1;
  /* narg is the number of arguments */
  for (i = 1; i <= narg; i++) {
    P_sun_argv(arg, sizeof(stryngar), i);
        /* assigns the i-th argument to arg */
    mymemcpy(sarg.str, arg, sizeof(stryngar));
    sarg.len = maxstringchars;
    stripspaces(&sarg);
    concatchar(&sarg, ' ');
    if (cmdline->len < maxstringchars)
      insertstring(cmdline, &sarg, cmdline->len + 1);
  }
}


/* TO FIX A FILE REMOVAL BUG: CANN 1/92 */
static void CANN_exit(status)
int status;
{
   static char dummystring[1024];
 if (CANN_source != NULL ) {
    fclose(CANN_source);
    sprintf(dummystring, "rm %s", CANN_source_file );
    system(dummystring);
    }

  exit(status);
}


/*#TITLE  PARUTL  ROUTINES        Oct82   Parameter Handling Routines.*/
parrec *defineparameter(parlist, long_, short_, parsort, pos1, pos2)
parrec **parlist;
Char *long_, *short_;
partyp parsort;
int pos1, pos2;
{
  parrec *newpar;
  PBBLOCK b;

  /* DefineParameter */
  /* newpar = (parrec *)Malloc(sizeof(parrec)); */
  b = MyBBlockAlloc(); /* CANN */
  newpar = &(b->pr); /* CANN */

  mymemcpy(newpar->longname, long_, sizeof(str10));
  mymemcpy(newpar->shortname, short_, sizeof(str10));
  newpar->partype = parsort;
  newpar->normpos = pos1;
  newpar->specpos = pos2;
  newpar->nextpar = NULL;
  mymemcpy(newpar->parvalue.str, blankstring, sizeof(stryngar));
  newpar->parvalue.len = 0;
  newpar->nextpar = *parlist;
  *parlist = newpar;
  return newpar;
}


/*macro procedure InitParameter( Param: ParRef ); */
static void setparameter(param, paramvalue)
parrec *param;
stryng *paramvalue;
{
  int pos;

  /* SetParameter */
  if (((1L << ((long)param->partype)) &
       ((1L << ((long)ifilpar)) | (1L << ((long)ofilpar)))) != 0)
    defaultfilename(&param->parvalue, paramvalue);
  else if (param->parvalue.len == 0) {
    switch (param->partype) {   /* Case */

    case restpar:
    case strpar:
      param->parvalue = *paramvalue;
      break;

    case flagpar:
    case boolpar:
      stringuppercase(paramvalue);
      string10(&param->parvalue, "YES       ");
      if (!equalstrings(paramvalue, &param->parvalue)) {
        string10(&param->parvalue, "NO        ");
        if (!equalstrings(paramvalue, &param->parvalue))
          deletestring(&param->parvalue, 1, 2);
      }
      break;

    case intpar:
      pos = 1;
      (void)stringnumber(paramvalue, &pos, 10);
      if (pos == paramvalue->len + 1)
        param->parvalue = *paramvalue;
      break;
    default:
       ;
    }
  }
  *paramvalue = param->parvalue;
}


/*macro function ParamSet( Par: ParRef ): Boolean; */
/*macro procedure StrParValue( var Str: Stryng; Par: ParRef ); */
Char gettoken(token, cmd)
stryng *token, *cmd;
{
  int pos;
  boolean quote, done;
  Char leadchar, ch;
  Char STR1[256], STR2[256];

  /* GetToken */
  quote = false;
  done = false;
  pos = 1;
  while ((cmd->len > 0) & (stringchar(cmd, 1) == ' '))
    deletestring(cmd, 1, 1);
  leadchar = stringchar(cmd, 1);
  if (leadchar == ' ' || leadchar == ' ' || leadchar == '-')
    deletestring(cmd, 1, 1);
  else
    leadchar = ' ';
  do {
    ch = stringchar(cmd, pos);
    if (pos > cmd->len)
      done = true;
    else {
      if (ch == '\'') {
        deletestring(cmd, pos, pos);
        if (quote & (stringchar(cmd, pos) == '\''))
          pos++;
        else
          quote = !quote;
      } else {
        if (quote)
          pos++;
        else {
          sprintf(STR1, "%c", ch);
          sprintf(STR2, "%c", leadchar);
          if ( ( ch == ' ' ) |  /* CHANGED PJM - 921003 (dash arg problem) */
              ((strcmp(STR1, parargchar) == 0) & (strcmp(STR2, parflagchar) == 0)))
            done = true;
          else {
            if (ch == ' ')
              deletestring(cmd, pos, pos);
            else
              pos++;
          }
        }
      }
    }
  } while (!done);
  substring(token, cmd, 1, pos - 1);
  deletestring(cmd, 1, pos - 1);
  return leadchar;
}


boolean parsecommandline(parlist)
parrec *parlist;
{
  boolean Result;
  stryng commline, flagline, testline, tokenline;
  parrec *parpoint, *foundpar;
  int pospar;
  Char leadchar;
  boolean firsthalf;
  Char STR1[256], STR2[256], STR3[256];

  /* ParseCommandLine */
  getcommandline(&commline);
  stripspaces(&commline);
  Result = (commline.len > 0);
  insertchar(&commline, ' ', 1);
  firsthalf = true;
  pospar = 0;
  while (commline.len > 0) {
    leadchar = gettoken(&tokenline, &commline);
    foundpar = NULL;
    sprintf(STR1, "%c", leadchar);
    /* See if this could be a Flag */
    if (!strcmp(STR1, parflagchar)) {
      parpoint = parlist;
      flagline = tokenline;
      stringuppercase(&flagline);
      /* Try to Locate the Flag */
      while (parpoint != NULL && foundpar == NULL) {
        string10(&testline, parpoint->longname);
        if (equalstrings(&flagline, &testline))
          foundpar = parpoint;
        else {
          string10(&testline, parpoint->shortname);
          if (equalstrings(&flagline, &testline))
            foundpar = parpoint;
        }
        parpoint = parpoint->nextpar;
      }
      if (foundpar == NULL) {
        /* No Flag found so convert to Positional parameter */
        insertchar(&tokenline, '-', 1);
        leadchar = ' ';
      } else {
        if (foundpar->partype == flagpar)
          string10(&tokenline, "YES       ");
        else {
          /* Check for an argument separator if one is required */
          if (strcmp(parargchar, " ")) {
            sprintf(STR2, "%c", stringchar(&commline, 1));
            if (!strcmp(STR2, parargchar))
              deletestring(&commline, 1, 1);
            else
              foundpar = NULL;
          }
          /* Pick up argument */
          if (foundpar != NULL) {
            if (foundpar->partype == restpar) {
              while (stringchar(&commline, 1) == ' ')
                deletestring(&commline, 1, 1);
              tokenline = commline;
              mymemcpy(commline.str, blankstring, sizeof(stryngar));
              commline.len = 0;
            } else {
              leadchar = gettoken(&tokenline, &commline);
              sprintf(STR2, "%c", leadchar);
              if (!strcmp(STR2, parflagchar))
                insertchar(&tokenline, '-', 1);
              else
                leadchar = '-';
            }
          }
        }
      }
    }
    sprintf(STR1, "%c", leadchar);
    /* If no Suitable Parameter found, assume Positional */
    if (strcmp(STR1, parflagchar)) {
      sprintf(STR2, "%c", leadchar);
      /* Deal with Seperators */
      if (!strcmp(STR2, parsepchar))
        pospar++;
      else {
        sprintf(STR3, "%c", leadchar);
        if (!strcmp(STR3, parsplitchar)) {
          pospar = 1;
          firsthalf = false;
        }
      }
      parpoint = parlist;
      while (parpoint != NULL && foundpar == NULL) {
        if (!strcmp(parsplitchar, " ")) {
          if (parpoint->normpos == pospar)
            foundpar = parpoint;
        } else {
          if (parpoint->specpos == pospar &&
              firsthalf == (parpoint->partype == ofilpar))
            foundpar = parpoint;
        }
        parpoint = parpoint->nextpar;
      }
    }
    /* If Parameter found then set any argument */
    if (foundpar != NULL)
      setparameter(foundpar, &tokenline);
  }
  return Result;
}


static void getparamvalue(param, prompt)
parrec *param;
stryng prompt;
{
  stryng parvalue;

  concatchar(&prompt, ':');
  concatchar(&prompt, ' ');
  gettermline(&parvalue, &prompt);
  setparameter(param, &parvalue);
}


static void defaultext(name, oldname, ext)
stryng *name, *oldname;
Char *ext;
{
  stryng dev, nom;

  splitname(oldname, &dev, &nom, name);
  string10(name, ext);
  buildname(name, dev, nom, *name);
}



static void askordefault(par, def, inter, prompt)
parrec *par;
stryng *def;
boolean inter;
Char *prompt;
{
  stryng prstring;

  /* AskOrDefault */
  if (par->parvalue.len <= 0) {
    if (inter) {
      string20(&prstring, prompt);
      if (def->len > 0) {
        concatchar(&prstring, ' ');
        concatchar(&prstring, '[');
        if (prstring.len < maxstringchars)
          insertstring(&prstring, def, prstring.len + 1);
        concatchar(&prstring, ']');
      }
      getparamvalue(par, prstring);
    }
    if (par->parvalue.len <= 0)
      setparameter(par, def);
  }
  *def = par->parvalue;
}


static void readcommandline(infile, outfile, paramlist)
parrec **infile;
parrec **outfile, **paramlist;
{
  boolean interact;
  stryng infilename;
  int i, zero;
  Char ch;
  Char s1[10], s2[10];

  zero = '0';
  for (i = 1; i <= maxinfile; i++) {
    mymemcpy(s1, "IN        ", 10L);
    mymemcpy(s2, "I         ", 10L);
    ch = i + zero;
    s1[2] = ch;
    s2[1] = ch;
    infile[i - 1] = defineparameter(paramlist, s1, s2, ifilpar, i, 1);
  }
  *outfile = defineparameter(paramlist, "OUT       ", "O         ", ofilpar,
                             11, 1);
  interact = parsecommandline(*paramlist);
  interact = (infile[0]->parvalue.len <= 0);
  mymemcpy(infilename.str, blankstring, sizeof(stryngar));
  infilename.len = 0;
  askordefault(infile[0], &infilename, interact, "Input file name     ");
  if (interact)
    infile[0]->parvalue = infilename;
  if ((*outfile)->parvalue.len <= 0) {
    if (infile[0]->parvalue.len > 0)
      (*outfile)->parvalue = infile[0]->parvalue;
  }

/* CANN 1/92 for tmp-file management */
{
stryng hohoho;
stryng s;

defaultext(&hohoho, &(infile[0]->parvalue), "spp       ");
s = hohoho;
stripspaces(&s);
concatchar(&s, '\0');
strcpy( CANN_source_file, s.str );
}
/* CANN 1/92 */
}  /* ReadCommandLine */



boolean openoutputfile(filename, source)
stryng *filename;
FILE **source;
{
  /* Insures an '.if1' extension is on the file name and then tries to
     open it for writing.  Returns true if file opens properly.
   */
  defaultext(filename, filename, "if1       ");
  return (openwrite(source, filename));
}  /* OpenOutputFile */



stentry *newtypealloc(sort)
char sort;
{
  /*Allocates new type record, initializes fields, returns pointer*/
  stentry *t;
  PBBLOCK b;

  /* t = (stentry *)Malloc(sizeof(stentry)); */
  b = MyBBlockAlloc(); /* CANN */
  t = &(b->i); /* CANN */

  t->stid = -1;
  t->stlabel = -1;
  t->stequivchain = t;
  mymemcpy(t->stliteral.str, blankstring, sizeof(stryngar));
  t->stliteral.len = 0;
  t->stsize = 0;
  t->strecurflag = false;
  t->stsort = sort;
  switch (t->stsort) {   /*with*/

  case iftwild:   /*nothing*/
    break;

  case iftbasic:
    t->UU.stbasic = ifbwild;
    break;

  case iftfunctiontype:
    t->UU.U3.starg = NULL;
    t->UU.U3.stres = NULL;
    break;

  case iftarray:
  case iftstream:
  case iftmultiple:
  case iftrecord:
  case iftunion:
  case iftbuffer:
    t->UU.stbasetype = NULL;
    break;

  case iftfield:
  case ifttuple:
  case ifttag:
    t->UU.U2.stelemtype = NULL;
    t->UU.U2.stnext = NULL;
    break;
  }/*case*/
  return t;
}  /*NewTypeAlloc*/


port *newedgealloc(sort)
portsort sort;
{
  /*Allocates new Edge (Port) record, initializes fields, returns pointer*/
  port *e;
  PBBLOCK b;

  switch (sort) {

  case ptlit:
    /* e = (port *)Malloc(sizeof(port)); */
    b = MyBBlockAlloc(); /* CANN */
    e = &(b->p); /* CANN */
    break;

/* p2c: mono.bin.noblank.p, line 3070:
 * Note: No SpecialMalloc form known for PORT.PTLIT [187] */
  case ptedge:
    /* e = (port *)Malloc(sizeof(port)); */
    b = MyBBlockAlloc(); /* CANN */
    e = &(b->p); /* CANN */
    break;

/* p2c: mono.bin.noblank.p, line 3071:
 * Note: No SpecialMalloc form known for PORT.PTEDGE [187] */
  case ptdep:
    /* e = (port *)Malloc(sizeof(port)); */
    b = MyBBlockAlloc(); /* CANN */
    e = &(b->p); /* CANN */
    break;

/* p2c: mono.bin.noblank.p, line 3072:
 * Note: No SpecialMalloc form known for PORT.PTDEP [187] */
  case ptundef:
    /* e = (port *)Malloc(sizeof(port)); */
    b = MyBBlockAlloc(); /* CANN */
    e = &(b->p); /* CANN */
    break;
  }/*case*/
  e->pttype = NULL;
  e->pttonode = NULL;
  e->pttoport = -1;
  e->ptid = -1;
  e->ptmark = byval;
  e->ptclass = pcuncoded;
  e->ptif1line = -1;
  e->ptsrcline = -1;
  e->ptwiline = -1;
  mymemcpy(e->ptname.str, blankstring, sizeof(stryngar));
  e->ptname.len = 0;
  e->ptlbound = -SHORT_MAX;
  e->ptubound = -SHORT_MAX;   /*dlz - ???, but canonical*/
  e->ptsetrc = -SHORT_MAX;
  e->ptconmodrc = -SHORT_MAX;
  e->ptprodmodrc = -SHORT_MAX;
  e->ptdfaddr = -SHORT_MAX;
  e->ptmraddr = 0;
  e->pttonext = NULL;
  e->ptnextedge = NULL;
  e->ptsort = sort;
  switch (e->ptsort) {   /*with*/

  case ptedge:
    e->UU.U1.ptfrnode = NULL;
    e->UU.U1.ptfrnext = NULL;
    e->UU.U1.ptfrport = -1;
    break;

  case ptdep:
    e->UU.U1.ptfrnode = NULL;
    e->UU.U1.ptfrnext = NULL;
    e->UU.U1.ptfrport = 0;
    e->pttoport = 0;
    string10(&e->ptname, "DEPENDENCE");
    break;

  case ptlit:
    mymemcpy(e->UU.ptlitvalue.str, blankstring, sizeof(stryngar));
    e->UU.ptlitvalue.len = 0;
    break;

  case ptundef:   /*nothing*/
    break;
  }/*case*/
  return e;
}  /*NewEdgeAlloc*/


node *newnodealloc(sort)
nodesort sort;
{
  /*Allocates new Node record, initializes fields, returns pointer*/
  node *n;
  PBBLOCK b; /* CANN */

  switch (sort) {

  case ndatomic:
    /* n = (node *)Malloc(sizeof(node)); */
    b = MyBBlockAlloc(); /* CANN */
    n = &(b->n); /* CANN */
    break;

/* p2c: mono.bin.noblank.p, line 3109:
 * Note: No SpecialMalloc form known for NODE.NDATOMIC [187] */
  case ndgraph:
    /* n = (node *)Malloc(sizeof(node)); */
    b = MyBBlockAlloc(); /* CANN */
    n = &(b->n); /* CANN */
    break;

/* p2c: mono.bin.noblank.p, line 3110:
 * Note: No SpecialMalloc form known for NODE.NDGRAPH [187] */
  case ndcompound:
    /* n = (node *)Malloc(sizeof(node)); */
    b = MyBBlockAlloc(); /* CANN */
    n = &(b->n); /* CANN */
    break;

/* p2c: mono.bin.noblank.p, line 3111:
 * Note: No SpecialMalloc form known for NODE.NDCOMPOUND [187] */
  case ndundef:
    /* n = (node *)Malloc(sizeof(node)); */
    b = MyBBlockAlloc(); /* CANN */
    n = &(b->n); /* CANN */
    break;
  }/*case*/
  n->ndid = -1;
  n->ndlabel = -1;
  n->ndcode = -1;
  n->ndmisc.numb = 0;
  n->ndline = -1;
  n->ndsrcline = -1;
  n->ndwiline = -1;
  n->ndxcoord = -SHORT_MAX;
  n->ndycoord = -SHORT_MAX;
  n->ndparent = NULL;
  n->ndnext = NULL;
  n->ndnextinline = NULL;
  n->ndilist = NULL;
  n->ndolist = NULL;
  n->nddepilist = NULL;
  n->nddepolist = NULL;
  n->ndfrequency = -1.0;
  n->ndexpanded = -1;
  n->ndsort = sort;
  switch (n->ndsort) {   /*with*/

  case ndatomic:   /*nothing*/
    break;

  case ndgraph:
    n->UU.U1.ndlink = NULL;
    n->UU.U1.ndtype = NULL;
    n->UU.U1.ndfirstmro = 0;
    n->UU.U1.ndlastmro = 0;
    n->ndlabel = 0;
    break;

  case ndcompound:
    n->UU.U2.ndsubsid = NULL;
    n->UU.U2.ndassoc = NULL;
    break;

  case ndundef:   /*nothing*/
    break;
  }/*case*/
  return n;
}  /*NewNodeAlloc*/


static void initstamps()
{
  Char c;
  stryng name;

  mymemcpy(name.str, blankstring, sizeof(stryngar));
  name.len = 0;
  for (c = 'A'; c <= 'Z'; c++) {
    P_addset(stampset, c);
    stamp[c - 'A'] = name;
  }
}  /* InitStamps */


static void removestamp(ch)
Char ch;
{
  P_remset(stampset, ch);
}  /* RemoveStamp */


static void addstamp(ch, str)
Char ch;
stryng str;
{
  P_addset(stampset, ch);
  stamp[ch - 'A'] = str;
}  /* AddStamp */


/* The following function give information about Nodes */
/* macro function NodeId ( gnode : NDPtr) : integer; */
/* macro function IsSimple( N: NdPtr ) : boolean */
/* macro function IsCompound( N: NdPtr ) : boolean */
/* macro function IsGraph( N: NdPtr ) : boolean */
/* macro function IsEmptyGraph( N: NdPtr ) : boolean */
/* IsEmptyGraph returns true if the graph has no internal nodes
   Assumes:(graph^.NDSort = NDGraph)       */
/*macro function IsLastNodeInGraph( N: NdPtr ) : boolean */
/*macro function NotEndOfGraph( N: NdPtr ) : boolean */
/*macro function IsFirstNodeInGraph( N: NdPtr ) : boolean */
/* assumes N <> nil */
static int numbofsubgraphs(cnode)
node *cnode;
{
  /* Assumes cnode <> nil and (cnode^.NDSort = NDCompound)
     returns the number of subgraphs of this compound node,
     if a value of zero is returned, you know something is wrong.  */
  int count;
  graph *tmp;

  count = 0;
  tmp = cnode->UU.U2.ndsubsid;
  while (tmp != NULL) {
    count++;
    tmp = tmp->grnext;
  }
  return count;
}  /* NumbOfSubgraphs */


int numbnodesingraph(gnode)
node *gnode;
{
  /* Assumes gnode <> nil and (gnode^.NDSort = NDGraph)
     returns the number of nodes within this graph, the
     graphnode itself is not counted and and the compound
     nodes are counted only once (ie, we do not dive inside
     compounds. Empty graphs return a count of zero.  */
  int count;
  node *tmp;

  count = 0;
  tmp = gnode->ndnext;
  while (tmp != NULL) {
    count++;
    tmp = tmp->ndnext;
  }
  return count;
}  /* NumbNodesInGraph */


/* macro procedure NameOfGraph( var S: stryng; G: NdPtr ) */
/* macro function NumbOfAlternatives( N: NDPtr ) : integer */
/* NumbOfAlternatives assumes (N^.NDSort = NDCompound)
 One child graph is the selector graph, the others are Alternatives */
/* macro function NodeKind( N: NDPtr ) : integer */

int numberofwiredoutputports(n)
node *n;
{
  /* Assumes N <> nil and edges are ordered by port numbers */
  port *e;
  int count, portnum;

  e = n->ndolist;
  count = 0;
  portnum = -1;
  while (e != NULL) {
    /* assumes edges are in order by port number */
    if (portnum != e->UU.U1.ptfrport) {
      count++;
      portnum = e->UU.U1.ptfrport;
    }
    e = e->UU.U1.ptfrnext;
  }
  return count;
}  /* NumberOfWiredOutputPorts */


int largestinputportnumber(n)
node *n;
{
  /* Assumes N <> nil
     returns the largest port number on the nodes input port list.
     NOTE: edges are ordered in the list by increasing port number */
  port *e;

  e = n->ndilist;
  if (e == NULL)
    return 0;
  else {
    while (e->pttonext != NULL)
      e = e->pttonext;
    return (e->pttoport);
  }
}  /* LargestInputPortNumber */


int largestoutputportnumber(n)
node *n;
{
  /* Assumes N <> nil
     returns largest port number on nodes output list */
  port *e;

  e = n->ndolist;
  if (e == NULL)
    return 0;
  else {
    while (e->UU.U1.ptfrnext != NULL)
      e = e->UU.U1.ptfrnext;
    return (e->UU.U1.ptfrport);
  }
}  /* LargestOutputPortNumber */


int nodelabel(n)
node *n;
{
  if (n == NULL)
    return -1;
  else
    return (n->ndlabel);
}  /* NodeLabel */


/* macro function FunctionKind( F : NDPtr ) : LinkSort; */
/* macro function IsstaticFunction( fungraph: NDPtr) : boolean; */
/* Assumes fungraph <> nil and fungraph is a function graph */
/* macro function IsGlobalFunction( fungraph: NDPtr) : boolean; */
/* Assumes fungraph <> nil and fungraph is a function graph */
/* The following functions give information about edges */
/* macro function IsEdge( E: EGPtr ) : boolean */
/* macro function IsLiteral( E: EGPtr ) : boolean */
/* macro function IsDependence( E: EGPtr ) : boolean */

/* macro function EdgeId( E: EGPtr ) : integer */
/* macro procedure NameOfEdge( var S: stryng; E: EGPtr ) */
/* macro procedure ValueOfLiteral( var S: stryng; E: EGPtr ) */
/* macro function ValueOfSetRC( E : EGPtr ) : integer; */
/* macro function ValueOfModRC(E : EGPtr ) : integer; */
/* macro function ValueOfProdRC(E : EGPtr ) : integer; */
/* macro function ConsumerNodeOfEdge( E : EGPtr ) : NDPtr; */
node *producernodeofedge(e)
port *e;
{
  /* Assumes E <> nil
     if edge is a literal there is no producer node and nil is returned */
  if (e->ptsort == ptedge || e->ptsort == ptdep)
    return (e->UU.U1.ptfrnode);
  else
    return NULL;
}  /* ProducerNodeOfEdge */


/* macro TypeOfEdge( E: EGPtr ) : STPtr */
/* macro DataSizeOfEdge( E: EGPtr ) : real */
/* macro SetDataSizeOfEdge( E : EGPtr; Value : real ); */
/* macro CardinalityOfEdge( E: EGPtr ) : real */
/* macro SetCardinalityOfEdge( E : EGPtr; Value : real ); */
/* macro SetCommOfEdge( E : EGPtr; Value : boolean); */
/* macro IsEdgeCommunicated( E : EGptr) : boolean;  */
/* macro SetRCOfEdge( E : EGPtr; Value : integer); */
/* macro SetProdModRCOfEdge( E : EGPtr; Value : integer); */
/* macro SetConModRCOfEdge( E : EGPtr; Value : integer); */
int producerportnumber(e)
port *e;
{
  /* Assumes E <> nil */
  if (e->ptsort == ptedge)
    return (e->UU.U1.ptfrport);
  else
    return -1;
}  /* ProducerPortNumber */


/* macro ConsumerPortNumber( E: EGPtr ) : integer */
/* Assumes E <> nil */
/* The following functions are used to traverse the graph */


/* macro function ToFirstNodeInGraph( N: NdPtr ) : integer */
/* toFirstNodeInGraph assumes (graph^.NDSort = NDGraph)
 returns the first scheduled to be executed in this graph,
 if the Graph is empty thein it returns nil       */
/* macro ExecTimeOfNode( N : NDPtr ) : real */
/* macro SetExecTimeOfNode( N : NDPtr; Value : real ); */
/* macro ProcNumberOfNode( N : NDPtr ) : integer */
/* macro SetProcNumberOfNode( N : NDPtr; Value : integer ); */
/* macro SchedNumberOfNode( N : NDPtr ) : integer */
/* macro SetSchedNumberOfNode( N : NDPtr; Value : integer ); */
/* macro FrequencyOfNode( N : NDPtr ) : real */
/* macro SetFrequencyOfNode( N : NDPtr; Value : real ); */
/* macro IsNodeExpanded( N : NDPtr) : boolean; */
/* macro SetExpandedValueOfNode(N : NDPtr; Val : boolean); */
node *tolastnodeingraph(n)
node *n;
{
  /* assumes N <> nil and (N^.NDSort = NDGraph) */
  /* IfEmptyGraph(N) then it returns nil */
  node *last;

  if (n->ndnext == NULL)
    return NULL;
  else {
    last = n->ndnext;
    while (last->ndnext != NULL)
      last = last->ndnext;
    return last;
  }
}  /* ToLastNodeInGraph */


/*macro function ToNextNode( N: NdPtr ) : NdPtr */
/* ToNextNode assumes gnode <> nil
   Returns next node in this graph to be executed,
   returns nil if no next node*/
node *toprevnode(n)
node *n;
{
  /* Assumes N <> nil */
  /* if (N^.NDSort = NDGraph) or (n = n^.NDParent^.NDNext) then returns nil
     otherwise it returns the node previously scheduled to be
     executed. */
  node *prev;

  if (n->ndsort == ndgraph)
    return NULL;
  else if (n->ndparent->ndnext == n)
    return NULL;
  else {
    prev = n->ndparent->ndnext;
    while (prev->ndnext != n)
      prev = prev->ndnext;
    return prev;
  }
}  /* ToPrevNode */


/*macro ToEnclosingGraph( GNode: NdPtr ) : NdPtr */
/* ToEnclosingGraph assumes gnode <> nil and ( not (gnode^.NDSort = NDGraph))
 returns a pointer to the graphnode surrounding this one. */
/*macro function N: NdPtr ^.NDNext : NdPtr */
/* ^.NDNext assumes gnode <> nil
   Returns next node in this graph to be executed,
   returns nil if no next node*/
/*macro function ToFirstChildGraph( cnode : NDPtr) : NDPtr */
/* Assumes (cnode^.NDSort = NDCompound), with at least one subgraph.
   Result is a pointer to first subgraph of this compound node.  rky 8/87 */
node *tochildgraph(cnode, gindex)
node *cnode;
int gindex;
{
  /* Assumes (cnode^.NDSort = NDCompound) and Gindex >= 0
     returns a pointer to the i'th subgraph of this compound
     node where i is the value of Gindex.  If no such subgraph
     exists, it returns the nill pointer.      */
  graph *tmp;

  tmp = cnode->UU.U2.ndsubsid;
  while (tmp != NULL && gindex > 0) {
    gindex--;
    tmp = tmp->grnext;
  }
  if (tmp == NULL)
    return NULL;
  else
    return (tmp->grnode);
}  /* ToChildGraph */


node *toenclosingcompound(gnode)
node *gnode;
{
  /* Assumes gnode <> nil
     returns a pointer to the closest enclosing Compound node
     if one exists.  Returns nil if such a node doesn't exist.
   */
  if (gnode == module)
    return NULL;
  else {
    if (gnode->ndsort != ndgraph)
      gnode = gnode->ndparent;
    /* gnode now points to a graph node */
    gnode = gnode->ndparent;
    /* gnode now points to a compound node */
    if (gnode == module)
      return NULL;
    else
      return gnode;
  }
}  /* ToEnclosingCompound */


node *toenclosingfunction(n)
node *n;
{
  /* ToEnclosingFunction assumes N <> nil and N <> Module,
     it returns a pointer to the function graph that properly contains
     the node N. */
  if (n == NULL || n == module)
    return NULL;
  else {
    if (n->ndsort != ndgraph)
      n = n->ndparent;
    /* from this point on N will always point to a graph node */
    while (n->UU.U1.ndlink == NULL) {
      /* N points to a subgraph of a compound node */
      n = n->ndparent->ndparent;
    }
    return n;
  }
}  /* ToEnclosingFunction */


node *toinitgraph(n)
node *n;
{
  /* Assumes (N^.NDSort = NDCompound)
     If the node is not a LoopB or LoopA node then return nil */
  if (n->ndcode == ifnloopa || n->ndcode == ifnloopb)
    return (n->UU.U2.ndsubsid->grnode);
  else
    return NULL;
}  /* ToInitGraph */


node *tobodygraph(n)
node *n;
{
  /* Assumes (N^.NDSort = NDCompound)
     If the node is not a LoopB or LoopA node then return nil */
  if (n->ndcode == ifnloopa || n->ndcode == ifnloopb)
    return (n->UU.U2.ndsubsid->grnext->grnext->grnode);
  else
    return NULL;
}  /* ToBodyGraph */


node *totestgraph(n)
node *n;
{
  /* Assumes (N^.NDSort = NDCompound)
     If the node is not a LoopB or LoopA node then return nil */
  if (n->ndcode == ifnloopa || n->ndcode == ifnloopb)
    return (n->UU.U2.ndsubsid->grnext->grnode);
  else
    return NULL;
}  /* ToTestGraph */


node *toreturnsgraph(n)
node *n;
{
  /* Assumes (N^.NDSort = NDCompound)
     If the node is not a LoopB or LoopA node then return nil */
  if (n->ndcode == ifnloopa || n->ndcode == ifnloopb)
    return (n->UU.U2.ndsubsid->grnext->grnext->grnext->grnode);
  else
    return NULL;
}  /* ToReturnsGraph */


node *toiterbodygraph(n)
node *n;
{
  /* Assumes (N^.NDSort = NDCompound)
     if N is not a Iter node, then return nil */
  if (n->ndcode == ifniter)
    return (n->UU.U2.ndsubsid->grnode);
  else
    return NULL;
}  /* ToIterBodyGraph */


node *toselectorgraph(n)
node *n;
{
  /* Assumes (N^.NDSort = NDCompound)
     If N is not a Select node, then return nil */
  if (n->ndcode == ifnselect)
    return (n->UU.U2.ndsubsid->grnode);
  else
    return NULL;
}  /* ToSelectorGraph */


node *toforallgeneratorgraph(n)
node *n;
{
  /* Assumes (N^.NDSort = NDCompound)
     if N is not a Forall node, then return nil */
  if (n->ndcode == ifnforall)
    return (n->UU.U2.ndsubsid->grnode);
  else
    return NULL;
}  /* ToForallGeneratorGraph */


node *toforallbodygraph(n)
node *n;
{
  /* Assumes (N^.NDSort = NDCompound)
     if N is not a Forall node, then return nil */
  if (n->ndcode == ifnforall)
    return (n->UU.U2.ndsubsid->grnext->grnode);
  else
    return NULL;
}  /* ToForallBodyGraph */


node *toforallreturnsgraph(n)
node *n;
{
  /* Assumes (N^.NDSort = NDCompound)
     if N is not a Forall node, then return nil */
  if (n->ndcode == ifnforall)
    return (n->UU.U2.ndsubsid->grnext->grnext->grnode);
  else
    return NULL;
}  /* ToForallReturnsGraph */


/* macro function NumberOfPredicates( C : NDPtr ) : integer */
/*C is an IfThenElse node.  Returns the number of predicate subgraphs */
/* macro function ToNthPredicateGraph( C : NDPtr; N : integer ) : NDPtr */
/*C is an IfThenElse node, N = 1, 2, ....      */
/*Returns a pointer to the N'th predicate subgraph      */
/* macro function ToNthTrueGraph( C : NDPtr; N : integer ) : NDPtr */
/*C is an IfThenElse node, N = 0, 1, ....      */
/*Returns a pointer to the N'th true subgraph      */
/* macro function ToFalseGraph( N : NDPtr ) : NDPtr */
/* N is an IfThenElse node.Returns a pointer to the false subgraph */
port *getinputedge(n, portnum)
node *n;
int portnum;
{
  /* If no edge is connected to this port number then nil is returned */
  port *eptr;
  boolean found;

  eptr = n->ndilist;
  found = false;
  while (!found) {
    if (eptr == NULL) {
      found = true;
      break;
    }
    if (eptr->pttoport == portnum)
      found = true;
    else
      eptr = eptr->pttonext;
  }
  return eptr;
}  /* GetInputEdge */


port *getoutputedge(n, portnum)
node *n;
int portnum;
{
  /* If no edge is connected to this port number then nil is returned */
  port *eptr;
  boolean found;

  eptr = n->ndolist;
  found = false;
  while (!found) {
    if (eptr == NULL) {
      found = true;
      break;
    }
    if (eptr->UU.U1.ptfrport == portnum)
      found = true;
    else
      eptr = eptr->UU.U1.ptfrnext;
  }
  return eptr;
}  /* GetOutputEdge */


port *nextoutputedgesameport(e)
port *e;
{
  /* Returns nil if no next edge exists */
  int portnum;

  portnum = e->UU.U1.ptfrport;
  e = e->UU.U1.ptfrnext;
  if (e != NULL) {
    if (e->UU.U1.ptfrport > portnum)
      e = NULL;
  }
  return e;
}  /* NextOutputEdgeSamePort */


/* Assumes N <> nil */
/* Assumes N <> nil */
/* Assumes E <> nil */
/* Assumes N <> nil */
/* Assumes N <> nil */
/* Assumes E <> nil */
/* dlz - 8/87 instead of for-loops */
/* over port range      */


port *outputedgegeport(n, p)
node *n;
int p;
{
  port *e;
  boolean found;

  e = n->ndolist;
  found = false;
  while (!found) {
    if (e == NULL) {
      found = true;
      break;
    }
    if (producerportnumber(e) >= p)
      found = true;
    else
      e = e->UU.U1.ptfrnext;
  }
  return e;
}  /* OutputEdgeGEPort */


node *getnodewithlabel(n, l)
node *n;
int l;
{
  boolean found, finished;

  found = false;
  finished = false;
  while (!(finished || found)) {
    if (n == NULL) {
      finished = true;
      break;
    }
    if (n->ndlabel == l) {
      found = true;
      break;
    }
    if (n->ndlabel > l)
      finished = true;
    else
      n = n->ndnext;
  }
  if (found)
    return n;
  else
    return NULL;
}  /* GetNodeWithLabel */


node *getnodewithid(f, id)
node *f;
int id;
{
  node *n, *gn;
  graph *g;
  boolean found;

  n = f;
  found = false;
  while (!found && n != NULL) {
    if (n->ndid == id) {
      found = true;
      break;
    }
    if (n->ndsort != ndcompound) {
      n = n->ndnext;
      continue;
    }  /* N is compound */
    g = n->UU.U2.ndsubsid;
    while (!found && g != NULL) {
      gn = getnodewithid(g->grnode, id);
      if (gn == NULL)   /*not found .. go to next subgraph*/
        g = g->grnext;
      else {
        /*found .. save the node and signal completion*/
        n = gn;
        found = true;
      }  /* else */
    }  /* while */
    if (!found)   /*move to next node*/
      n = n->ndnext;
  }
  return n;

  /* N is simple or a graph node .. move to next */
}  /* GetNodeWithID */


node *tonextfunction(f)
node *f;
{
  if (f == NULL)
    return NULL;
  else if (f->UU.U1.ndlink->lknext == NULL)
    return NULL;
  else
    return (f->UU.U1.ndlink->lknext->lkgraph);
}  /* ToNextFunction */


/* Functions used to examine and add to the type table */
/* macro function NameOfType( T: STPtr ) : Stryng */
/* macro WhichEntryType( S: STPtr ) : STENtry */
/* macro WhichBasicType( S: STPtr ) : STPtr */
/* macro function TypeOfGraph( G : NDPtr ) : STPtr; */
/* macro function BaseOfMultipleType( M: STPtr ) : STPtr; */
/* macro function BaseOfArrayType( M: STPtr ) : STPtr; */
/* macro function BaseOfTupleType( M: STPtr ) : STPtr; */
/* macro function BaseOfBufferType( M: STPtr ) : STPtr; */
/* macro function BaseOfStreamType( S: STPtr ) : STPtr; */
/* macro function GetFirstFunRes( N: NDPtr ) : STPtr; */
/* macro function GetFirstFunArg( N: NDPtr ) : STPtr; */


/* The following is a collection of functions that allow run-time additions
   to the Type Table.  Entries are constructed, then smashed into the table
   before being assigned to data objects.
 */
/*macro function MakeFunctionType () : STPtr;*/
/*macro function MakeRecordType () : STPtr;*/
/*macro function MakeUnionType () : STPtr;*/
stentry *searchtypetable(kind, x, y, name)
char kind;
stentry *x, *y;
stryng name;
{
  /* Search the Type Table for an entry of the given Kind that has:
      if Kind in [Stream, Array, Multiple, Record, Union, Buffer ] then
        X is its STBaseType
      if Kind in [Field, Tag] then
        X is its STElemType and Y is its STNext
    If an entry is not found, then return nil
  */
  int i;
  stentry *tbl;
  boolean found;

  found = false;
  i = 1;
  while (!found && i <= tthwm) {
    tbl = typetable[i - 1];
    if (tbl == NULL) {
      i++;
      continue;
    }
    if (tbl->stsort != kind) {
      i++;
      continue;
    }
    switch (kind) {

    case iftwild:
    case iftbasic:
      found = true;
      break;

    case iftmultiple:
    case iftarray:
    case iftstream:
    case iftrecord:
    case iftunion:
    case iftbuffer:
      if (tbl->UU.stbasetype == x)
        found = true;
      else
        i++;
      break;

    case iftfield:
    case ifttag:
      if ((tbl->UU.U2.stelemtype == x && tbl->UU.U2.stnext == y) &
          equalstrings(&tbl->stliteral, &name))
        found = true;
      else
        i++;
      break;

    case ifttuple:
      if (tbl->UU.U2.stelemtype == x && tbl->UU.U2.stnext == y)
        found = true;
      else
        i++;
      break;

    case iftfunctiontype:
      if (tbl->UU.U3.starg == x && tbl->UU.U3.stres == y)
        found = true;
      else
        i++;
      break;
    }/* case */
  }  /* while */
  if (found)
    return tbl;
  else
    return NULL;
}  /* SearchTypeTable */





static int equivclass(s, LINK)
stentry *s;
struct LOC_smashtypes *LINK;
{
  /* EquivClass */
  if (s != NULL)
    return (s->stid);
  else
    return (-SHORT_MAX);
}

static boolean sameequivclass(a, b, LINK)
stentry *a, *b;
struct LOC_smashtypes *LINK;
{
  boolean Result, first;

  /* SameEquivClass */
  switch (a->stsort) {   /* case */

  case iftwild:
    Result = true;
    break;

  case iftbasic:
    Result = (a->UU.stbasic == b->UU.stbasic);
    break;

  case iftfunctiontype:
    Result = (equivclass(a->UU.U3.starg, LINK) == equivclass(b->UU.U3.starg,
                LINK)) & (equivclass(a->UU.U3.stres, LINK) ==
                          equivclass(b->UU.U3.stres, LINK));
    break;

  case iftarray:
  case iftstream:
  case iftmultiple:
  case iftrecord:
  case iftunion:
  case iftbuffer:
    Result = (equivclass(a->UU.stbasetype, LINK) ==
              equivclass(b->UU.stbasetype, LINK));
    break;

  case iftfield:
  case ifttag:
    if (equivclass(a->UU.U2.stelemtype, LINK) ==
        equivclass(b->UU.U2.stelemtype, LINK)) {
      if (a->UU.U2.stnext != NULL && b->UU.U2.stnext != NULL)
        first = (equivclass(a->UU.U2.stnext, LINK) ==
                 equivclass(b->UU.U2.stnext, LINK));
      else
        first = (a->UU.U2.stnext == NULL && b->UU.U2.stnext == NULL);
    } else
      first = false;
    Result = first & equalstrings(&a->stliteral, &b->stliteral);
    break;

  case ifttuple:
    if (equivclass(a->UU.U2.stelemtype, LINK) ==
        equivclass(b->UU.U2.stelemtype, LINK)) {
      if (a->UU.U2.stnext != NULL && b->UU.U2.stnext != NULL)
        Result = (equivclass(a->UU.U2.stnext, LINK) ==
                  equivclass(b->UU.U2.stnext, LINK));
      else
        Result = (a->UU.U2.stnext == NULL && b->UU.U2.stnext == NULL);
    } else
      Result = false;
    break;
  }
  return Result;
}

static void createnewequivclass(r, LINK)
stentry *r;
struct LOC_smashtypes *LINK;
{
  /* CreateNewEquivClass */
  if (LINK->lastclass < maxclass)
    LINK->lastclass++;
  else
    printf("SmashType: Out of room for equivalence classes\n");
  r->stid = LINK->lastclass;
  r->stequivchain = NULL;
  LINK->classtable[LINK->lastclass] = r;
  LINK->lastinclass[LINK->lastclass] = r;
}

static void removefromequivclass(old, exile, LINK)
stentry *old, *exile;
struct LOC_smashtypes *LINK;
{
  /* RemoveFromEquivClass */
  if (exile == LINK->lastinclass[old->stid])
    LINK->lastinclass[old->stid] = old;
  old->stequivchain = exile->stequivchain;
}

static void addtoequivclass(representative, newmember, LINK)
stentry *representative, *newmember;
struct LOC_smashtypes *LINK;
{
  int classnum;

  /* AddToEquivClass */
  classnum = representative->stid;
  newmember->stid = classnum;
  newmember->stequivchain = NULL;
  LINK->lastinclass[classnum]->stequivchain = newmember;
  LINK->lastinclass[classnum] = newmember;
}

static void initequivclasses(LINK)
struct LOC_smashtypes *LINK;
{
  /* InitEquivClasses looks at every entry in the type table and places*/
  /* then non-nil ones into one of 12 equivilence classes:*/
  /*IFTBasicIFTRecord*/
  /*IFTFunctionTypeIFTUnion*/
  /*IFTArrayIFTField*/
  /*IFTStreamIFTTuple*/
  /*IFTMultipleIFTTag*/
  /*IFTWildIFTBuffer*/
  /* WARNING: Some equivalence classes may be left empty! */
  /* imports TypeTable, EntryMax*/
  /* exports LastClass (set to highest class USED */
  stentry *s;
  int entry_, class_, FORLIM;

  /* InitEquivClasses */
  for (class_ = 1; class_ <= maxclass; class_++) {
    LINK->classtable[class_] = NULL;
    LINK->lastinclass[class_] = NULL;
  }
  FORLIM = tthwm;
  for (entry_ = 1; entry_ <= FORLIM; entry_++) {
    if (typetable[entry_ - 1] != NULL) {
      s = typetable[entry_ - 1];
      s->stlabel = entry_;
      s->stid = s->stsort + 1;
      s->stequivchain = NULL;
      if (LINK->classtable[s->stid] == NULL) {  /* First in list */
        LINK->classtable[s->stid] = s;
        LINK->lastinclass[s->stid] = s;
      } else {  /* Insert at end of list */
        LINK->lastinclass[s->stid]->stequivchain = s;
        LINK->lastinclass[s->stid] = s;
      }
    }
  }
  for (class_ = 1; class_ <= ifmaxtype + 1; class_++) {
    if (LINK->classtable[class_] != NULL)
      LINK->lastclass = class_;
  }
}

/* macro function NextInEquivClass( M : STPtr ) : STPtr; */
/* macro function MoreInEquivClass( M : STPtr ) : boolean; */
static void gatherothers(prev, representative, LINK)
stentry *prev, **representative;
struct LOC_smashtypes *LINK;
{
  /* GatherOthers tries to remove elements in the Class headed by */
  /* Prev and moves them to the class headed by Representative*/
  stentry *potentialmember;

  /* macro procedure Mark( Entry : STPtr ); */
  /* macro function IsMarked( Entry : STPtr ): boolean; */
  /* macro procedure RemoveMark( var Entry : STPtr ); */
  /* GatherOthers */
  /* ^.STLabel := -^.STLabel all entries equivalent to Representative */
  potentialmember = (*representative)->stequivchain;
  while (potentialmember != NULL) {
    if (sameequivclass(*representative, potentialmember, LINK))
      potentialmember->stlabel = -potentialmember->stlabel;
    potentialmember = potentialmember->stequivchain;
  }
  /* remove all marked entries */
  removefromequivclass(prev, *representative, LINK);
  createnewequivclass(*representative, LINK);
  while (prev->stequivchain != NULL) {
    potentialmember = prev->stequivchain;
    if (potentialmember->stlabel < 0) {
      potentialmember->stlabel = -potentialmember->stlabel;
      removefromequivclass(prev, potentialmember, LINK);
      addtoequivclass(*representative, potentialmember, LINK);
    } else
      prev = potentialmember;
  }
}

static void pointtohead(LINK)
struct LOC_smashtypes *LINK;
{
  /* PointToHead makes the STEquivChain of each entry point at the */
  /*  representative of the equivalence class, and places a -1*/
  /*  in the representative's STId field (so that it will be*/
  /*  dumped in the node dumping process*/
  /* 83/10/4  sks*/
  int thisclass;
  stentry *temp, *member, *representative;
  int FORLIM;
  stentry *WITH;

  /* PointToHead */
  FORLIM = LINK->lastclass;
  for (thisclass = 1; thisclass <= FORLIM; thisclass++) {
    if (LINK->classtable[thisclass] != NULL) {
      representative = LINK->classtable[thisclass];
      representative->stid = -1;
      member = representative;
      while (member != NULL) {
        WITH = member;
        temp = WITH->stequivchain;
        WITH->stequivchain = representative;
        member = temp;   /* with */
      }
    }  /* if */
  }
}


/* -------------------------------------------------------------------- */
/* --------------------------- SmashTypes ----------------------------- */
static void smashtypes()
{
  /* Smashtypes maps types that are structurally equivalent into the same*/
  /* type number.Note that SISAL type equivalence is not guaranteed, since */
  /* the names of fields and tags of smashed types may not be the same.*/
  /* imports:TypeTable*/
  /* exports:LastClass*/
  /*ClassTable*/
  /*.STEquivChain*/
  /*.STLabel*/
  /*.STId*/
  /* 83/10/1 sks*/
  struct LOC_smashtypes V;
  boolean changed;
  int class_;
  stentry *member, *previous, *representative;
  int FORLIM;

  /* SmashTypes */
  initequivclasses(&V);
  changed = true;
  while (changed) {   /* while */
    changed = false;
    FORLIM = V.lastclass;
    for (class_ = 1; class_ <= FORLIM; class_++) {
      representative = V.classtable[class_];
      previous = representative;
      if (previous == NULL)
        member = NULL;
      else
        member = previous->stequivchain;
      while (member != NULL) {
        if (sameequivclass(representative, member, &V)) {
          previous = member;
          member = previous->stequivchain;
        } else {
          /* Begin another class and grab all others */
          /* from this one that belong in it */
          changed = true;
          gatherothers(previous, &member, &V);
          member = NULL;
        }
      }  /* while Member<>nil */
    }  /* for */
  }
  pointtohead(&V);
}


/* --------------------------- SmashTypes ----------------------------- */
/* -------------------------------------------------------------------- */
static void adjustgraphptrs()
{
  int typenum, FORLIM;
  stentry *WITH;

  FORLIM = tthwm;
  for (typenum = 0; typenum < FORLIM; typenum++) {
    if (typetable[typenum] != NULL) {
      WITH = typetable[typenum];
      switch (WITH->stsort) {

      case iftwild:
      case iftbasic:
        /* blank case */
        break;

      case iftfunctiontype:
        if (WITH->UU.U3.starg != NULL)
          WITH->UU.U3.starg = WITH->UU.U3.starg->stequivchain;
        if (WITH->UU.U3.stres != NULL)
          WITH->UU.U3.stres = WITH->UU.U3.stres->stequivchain;
        break;

      case iftarray:
      case iftstream:
      case iftmultiple:
      case iftrecord:
      case iftunion:
      case iftbuffer:
        if (WITH->UU.stbasetype != NULL)
          WITH->UU.stbasetype = WITH->UU.stbasetype->stequivchain;
        break;

      case iftfield:
      case ifttuple:
      case ifttag:
        if (WITH->UU.U2.stelemtype != NULL)
          WITH->UU.U2.stelemtype = WITH->UU.U2.stelemtype->stequivchain;
        if (WITH->UU.U2.stnext != NULL)
          WITH->UU.U2.stnext = WITH->UU.U2.stnext->stequivchain;
        break;
      }/* case */
    }
  }
}  /* AdjustGraphPtrs */


static void compacttypetable(tthwm, oldtthwm)
int *tthwm, oldtthwm;
{
  /*  Pre:  The TypeTable has been extended beyond OldTTHWM (Old Symbol
           Table High Water Mark) and the new types added have been
           smashed into the existing types and some new ones.  At this
           point, the STEquivChain of each entry of the table points to
           its equivalence class representative.  Also, the new graph
           has been walked and all pointers to symbol table entries have
           been changed to the class representatives.
     Post: The Symbol Table below OldTTHWM is scanned and all entries
           which are not equivalence class representatives are removed.
           The resulting entries are compacted and the TTHWM is reset.
  */
  int lastincompacted, current;
  stentry *rep, *s;
  int FORLIM;

  lastincompacted = oldtthwm;
  FORLIM = *tthwm;
  for (current = oldtthwm; current < FORLIM; current++) {
    s = typetable[current];
    if (s != NULL) {
      if (s->stequivchain != s) {
        /* Make sure representative has name */
        rep = s->stequivchain;
        if (rep != NULL) {
          if (rep->stliteral.len == 0) {
            if (s->stliteral.len != 0)
              rep->stliteral = s->stliteral;
          }
        }
        /* Not a class representative, remove it */
        typetable[current] = NULL;
      } else {
        /* Is a class representative */
        lastincompacted++;
        if (current + 1 > lastincompacted) {
          /* Compact list */
          s->stlabel = lastincompacted;
          typetable[lastincompacted - 1] = s;
          typetable[current] = NULL;
        }
      }
    }
  }
  *tthwm = lastincompacted;
}  /* CompactTypeTable */


stentry *getbasictype(base)
char base;
{
  /* returns a pointer to the type table entry corresponding to
     the basic type specified by Base.  An entry MUST exist for
     all basic types, this is required by LoadProgram.
   */
  return (typetable[(int)base]);
}  /* GetBasicType */


stentry *getwildtype()
{
  /* Returns a type table entry corresponding to the Wild Card type.
     Note that this is NOT the BASIC Wild Card (IFBWild) but the
     higher level wild card (IFTWild).
   */
  stentry *wld;
  stryng name;

  mymemcpy(name.str, blankstring, sizeof(stryngar));
  name.len = 0;
  wld = searchtypetable(iftwild, NULL, NULL, name);
  if (wld != NULL) {
    return wld;
  }  /* if */
  wld = newtypealloc(iftwild);
  if (tthwm == entrymax) {
    printf("ERROR: (GetWildType) Type Table Overflow\n");
    wld = NULL;
    return wld;
  }
  tthwm++;
  wld->stlabel = tthwm;
  typetable[tthwm - 1] = wld;
  return wld;

  /* else */
}  /* GetWildType */


stentry *getconstructortype(kind, base)
char kind;
stentry *base;
{
  /* Requires that the Base type already be in the table - if not,
     an error message is printed and Nil is returned.
     If the base is in the table, then it searches the table for
     this constructor.  If it finds one, it returns this type, otherwise
     it returns a newly constructed type and adds it to the table.
   */
  stentry *con;
  stryng name;

  if (((1L << kind) & ((1L << iftarray) | (1L << iftstream) |
                       (1L << iftmultiple) | (1L << iftbuffer))) == 0) {
    printf("ERROR (GetConstructorType) only works with: \n");
    printf(" --->  Arrays, Streams, and Multiples\n");
    return NULL;
  } else if (base->stlabel <= 0) {
    printf("ERROR (GetConstructorType) Base type not in table\n");
    return NULL;
  } else {
    /* Base is in type table, search for Array[ Base ] or
       Stream[ Base ], or Multiple[ Base ] or Buffer[ Base ] entry */
    mymemcpy(name.str, blankstring, sizeof(stryngar));
    name.len = 0;
    con = searchtypetable(kind, base, NULL, name);
    if (con != NULL)  /* Not in table, construct one and add it */
      return con;
    con = (stentry *)Malloc(sizeof(stentry));  /* CANN: ??? */ 
    con = newtypealloc(kind);
    con->UU.stbasetype = base;
    if (tthwm == entrymax) {
      printf("ERROR: (GetConstructorType) Type Table Overflow\n");
      return con;
    }
    tthwm++;
    con->stlabel = tthwm;
    typetable[tthwm - 1] = con;
    return con;
  }

  /* else */
}  /* GetConstructorType */


static void putintable(typ)
stentry **typ;
{
  /* Enter Typ into the type table.
     If no room is left, send an error message
   */
  if (tthwm == entrymax) {
    printf("ERROR: (AddToTypeTable) Type Table Overflow\n");
    *typ = NULL;
    return;
  }
  tthwm++;
  (*typ)->stlabel = tthwm;
  typetable[tthwm - 1] = *typ;
}  /* PutInTable */


static void putstruct(tt)
stentry *tt;
{
  if (tt == NULL) {
    return;
  }  /* if TT <> nil */
  if (tt->stlabel != -1) {
    return;
  }  /* if */
  putintable(&tt);
  switch (tt->stsort) {

  case iftbasic:
  case iftwild:
    /* blank case */
    break;

  case iftfunctiontype:
    putstruct(tt->UU.U3.starg);
    putstruct(tt->UU.U3.stres);
    break;

  case ifttuple:
  case iftfield:
  case ifttag:
    if (!tt->strecurflag)
      putstruct(tt->UU.U2.stelemtype);
    putstruct(tt->UU.U2.stnext);
    break;

  case iftarray:
  case iftstream:
  case iftbuffer:
  case iftmultiple:
    if (!tt->strecurflag)
      putstruct(tt->UU.stbasetype);
    break;

  case iftrecord:
  case iftunion:
    putstruct(tt->UU.stbasetype);
    break;
  }/* case */
}  /* PutStruct */


stentry *addtotypetable(typ)
stentry *typ;
{
  stentry *Result, *newtyp, *elem, *nxt, *arg, *rets;
  stryng name;
  int oldtthwm;

  if (typ == NULL)
    return NULL;
  if (typ->stlabel > 0)
    return typ;
  mymemcpy(name.str, blankstring, sizeof(stryngar));
  name.len = 0;
  switch (typ->stsort) {

  case iftbasic:
    Result = searchtypetable(typ->stsort, NULL, NULL, name);
    break;

  case iftfunctiontype:
    if (typ->UU.U3.starg == NULL)
      arg = NULL;
    else
      arg = addtotypetable(typ->UU.U3.starg);
    if (typ->UU.U3.stres == NULL)
      rets = NULL;
    else
      rets = addtotypetable(typ->UU.U3.stres);
    newtyp = searchtypetable(typ->stsort, arg, rets, name);
    if (newtyp == NULL) {
      newtyp = typ;
      newtyp->UU.U3.starg = arg;
      newtyp->UU.U3.stres = rets;
      putintable(&newtyp);
    }
    Result = newtyp;
    break;

  case iftarray:
  case iftstream:
  case iftmultiple:
  case iftbuffer:
    /* this should never happen, all arrays, streams,
            and tuples should already be built into the table */
    elem = addtotypetable(typ->UU.stbasetype);
    newtyp = searchtypetable(typ->stsort, elem, NULL, name);
    if (newtyp == NULL) {  /* not in the table */
      newtyp = typ;
      newtyp->UU.stbasetype = elem;
      putintable(&newtyp);
    }
    Result = newtyp;
    break;

  case iftrecord:
    if (typ->UU.stbasetype == NULL)
      nxt = NULL;
    else
      nxt = addtotypetable(typ->UU.stbasetype);
    newtyp = searchtypetable(typ->stsort, nxt, NULL, name);
    if (newtyp == NULL) {  /* Not found in table */
      newtyp = typ;
      newtyp->UU.stbasetype = nxt;
      putintable(&newtyp);
    }
    Result = newtyp;
    break;

  case iftunion:
    if (typ->strecurflag) {
      oldtthwm = tthwm;
      putstruct(typ);
      smashtypes();
      adjustgraphptrs();
      Result = typetable[oldtthwm]->stequivchain;
      compacttypetable(&tthwm, oldtthwm);
    } else {
      if (typ->UU.stbasetype == NULL)
        nxt = NULL;
      else
        nxt = addtotypetable(typ->UU.stbasetype);
      newtyp = searchtypetable(typ->stsort, nxt, NULL, name);
      if (newtyp == NULL) {
        newtyp = typ;
        newtyp->UU.stbasetype = nxt;
        putintable(&newtyp);
      }
      Result = newtyp;
    }
    break;

  case ifttuple:
    elem = addtotypetable(typ->UU.U2.stelemtype);
    if (typ->UU.U2.stnext != NULL)
      nxt = addtotypetable(typ->UU.U2.stnext);
    else
      nxt = NULL;
    newtyp = searchtypetable(typ->stsort, elem, nxt, name);
    if (newtyp == NULL) {  /* not found in table */
      newtyp = typ;
      newtyp->UU.U2.stnext = nxt;
      newtyp->UU.U2.stelemtype = elem;
      putintable(&newtyp);
    }
    Result = newtyp;
    break;

  case ifttag:
  case iftfield:
    elem = addtotypetable(typ->UU.U2.stelemtype);
    if (typ->UU.U2.stnext != NULL)
      nxt = addtotypetable(typ->UU.U2.stnext);
    else
      nxt = NULL;
    newtyp = searchtypetable(typ->stsort, elem, nxt, typ->stliteral);
    if (newtyp == NULL) {  /* not found in table */
      newtyp = typ;
      newtyp->UU.U2.stnext = nxt;
      newtyp->UU.U2.stelemtype = elem;
      putintable(&newtyp);
    }
    Result = newtyp;
    break;
  }/* case */
  return Result;
}  /* AddToTypeTable */



/* Functions that read and set pragma values */
/* GetEdgeBounds( E : EGPtr; var Lo, Hi : integer );   Assumes E <> nil */
/* macro function GetSourceLine( N: NDPtr ) : integer assumes N <> nil */
/* macro function GetWithinLine ( N : NDPtr) : integer; Assumes N <> nil */
/* macro function EdgeMark( E: EGPtr ) : EGMark */
/* macro procedure SetEdgeMark( var E: EGPtr ; M: EGMark */
/* macro function IsInlineExpandable( fungraph: NDPtr) : boolean; */
/* Assumes fungraph <> nil and fungraph is a function graph */
/* macro procedure SetInlinePragma( fungraph: NDPtr; V: boolean ); */
/* Assumes fungraph <> nil and fungraph is a function graph */
/* Functions needed specifically by the interpreter (DI) */
/* macro function NumbFunstatics( F: NdPtr ) : integer */
/* NumbFunstatics assumes funnode is the graph node of a function */
/* macro procedure SetNumbFunstatics( F: NdPtr, n: integer ) */
/* SetNumbFunstatics assumes funnode is the graph node of a function */
/* macro function DatumAddr ( E : EGPtr) : integer; */
/* Assumes E is not nil */
/* macro procedure SetDatumAddr( E: EGPtr, n: integer ) */
/* SetDatumAddr assumes E is not nil */
/* macro function MRDatumAddr ( E : EGPtr ) : integer */
/* macro procedure SetMRDatumAddr( E : EGPtr, N : integer ) */
/* ^.NDLink^.LKARIndex :=  assumes F <> nil and F points to a function graph */
/* ^.NDLink^.LKARIndex assumes F <> nil and F points to a function graph */
/* macro function NextSimilarEdge( E : EGPtr ) : EGPtr; */
/* macro procedure LinkToSimilarEdge( List, NewLink : EGPtr ); */
/* macro function NextNodeInLine( N : NDPtr ) : NDPtr; */
/* macro procedure LinkToNextNodeInLine( List, NewLink : NDPtr ); */
/* macro procedure SetFunctionModule( F : NDPtr; Name : Stryng ); */
/* macro procedure ModuleNameOfFunction( var Name : Stryng; F : NDPtr); */
/******************************************************************/
/* These function must come last in the files due to dependencies */
ifgraphtype graphkind(g)
node *g;
{
  /* Assumes (G^.NDSort = NDGraph)
     Analyses a graph node to determine its IFGraphType */
  ifgraphtype Result;
  node *parent;
  graph *gptr;
  int count;

  parent = toenclosingcompound(g);
  if (parent == NULL)
    return ifgfunction;
  switch (parent->ndcode) {

  case ifnselect:
    if (g == toselectorgraph(parent))
      Result = ifgselector;
    else
      Result = ifgalternative;
    break;

  case ifntagcase:
    Result = ifgvariant;
    break;

  case ifnloopb:
    if (g == toinitgraph(parent))
      Result = ifgloopbinit;
    else if (g == totestgraph(parent))
      Result = ifgloopbtest;
    else if (g == tobodygraph(parent))
      Result = ifgloopbbody;
    else
      Result = ifgloopbreturns;
    break;

  case ifnloopa:
    if (g == toreturnsgraph(parent))
      Result = ifgloopareturns;
    else if (g == toinitgraph(parent))
      Result = ifgloopainit;
    else if (g == totestgraph(parent))
      Result = ifgloopatest;
    else
      Result = ifgloopabody;
    break;

  case ifnforall:
    gptr = parent->UU.U2.ndsubsid;
    if (g == gptr->grnode)
      Result = ifgforallgenerator;
    else if (g == gptr->grnext->grnode)
      Result = ifgforallbody;
    else
      Result = ifgforallreturns;
    break;
    /* IFNForall */

  case ifnifthenelse:
    gptr = parent->UU.U2.ndsubsid;
    count = 1;
    while (gptr->grnode != g) {
      gptr = gptr->grnext;
      count++;
    }
    if (gptr->grnext == NULL)
      Result = ifgiffalse;
    else if ((count & 1) == 0)
      Result = ifgifpredicate;
    else
      Result = ifgiftrue;
    break;

  case ifniter:
    Result = ifgiterbody;
    break;
  }/* case */
  return Result;
}  /* GraphKind */



/* Graph2.m4 contains graph routines that alter the structure of the
   graph and are only used by some of the optimization routines.
   These were removed from the graph.m4 file since they are "Special"
   and not everyone needs them. */
/*dlz - 8/87 updated to use new allocation routines in graph.m4,
  some cleanup, ***still confusion/glitch (?) in CopyEdges, CopyGraph*/
static void disconnectedgefromsource(e)
port *e;
{
  /*in out*/
  /* ----------------------------------------------------
     DisconnectEdgeFromSource
          - Completely unlinks E from it's source node's
            output edge list
          - nills out all pointer fields having to do with
            it's source node.
     ---------------------------------------------------- */
  port *temp;

  if (e->ptsort != ptedge)
    return;
  if (e->UU.U1.ptfrnode == NULL)
    return;
  temp = e->UU.U1.ptfrnode->ndolist;
  if (temp == e)
    e->UU.U1.ptfrnode->ndolist = e->UU.U1.ptfrnext;
  else {
    while (temp->UU.U1.ptfrnext != e)
      temp = temp->UU.U1.ptfrnext;
    temp->UU.U1.ptfrnext = e->UU.U1.ptfrnext;
  }
  e->UU.U1.ptfrnode = NULL;
  e->UU.U1.ptfrnext = NULL;
  e->UU.U1.ptfrport = 0;
}  /* DisconnectEdgeFromSource */


static void disconnectedgefromdest(e)
port *e;
{
  /*in out*/
  /* -------------------------------------------------------
     DisconnectEdgeFromDest
         - Unlinks E from it's destination node's input list
         - nills out all pointer fields having to do with
           E's destination node
     ------------------------------------------------------- */
  port *temp;

  if (e->pttonode == NULL)
    return;
  temp = e->pttonode->ndilist;
  if (temp == e)
    e->pttonode->ndilist = e->pttonext;
  else {
    while (temp->pttonext != e)
      temp = temp->pttonext;
    temp->pttonext = e->pttonext;
  }
  e->pttonode = NULL;
  e->pttonext = NULL;
  e->pttoport = 0;
}  /* DisconnectEdgeFromDest */


static void removeedge(e)
port **e;
{
  /* -------------------------------------------------
     RemoveEdge
         - Removes E from graph leaving graph valid
         - nills out all pointer fields
         - returns pointer to completely unlinked edge
     ------------------------------------------------- */
  disconnectedgefromsource(*e);
  disconnectedgefromdest(*e);
  (*e)->pttype = NULL;
}  /* RemoveEdge */


static void removeinputedges(n)
node *n;
{
  port *e, *tmpe;

  e = n->ndilist;
  while (e != NULL) {
    tmpe = e;
    e = e->pttonext;
    removeedge(&tmpe);
  }
}  /* RemoveInputEdges */


static void removegraph(g)
node *g;
{
  /* Walk the nodes of the graph G removing each in turn */
  node *tmpn, *nd;

  nd = g->ndnext;
  while (nd != NULL) {
    tmpn = nd;
    nd = nd->ndnext;
    removenode(tmpn);
  }
  removenode(g);
}  /* RemoveGraph */


/* macro procedure ChangeEdgeName( E : EGPtr; S : Stryng ) */
/* macro procedure ChangeLiteralValue( E : EGPtr; S : Stryng ) */
static void removenode(n)
node *n;
{
  /*  Remove Node :
        - if N is a compound node it removes the subgraphs first.
        - removes all input edges
        - removes all output edges
        - completely disconnects N from the graph
  */
  graph *grtmp;
  node *prev;
  port *temp;

  if (n->ndsort == ndcompound) {
    grtmp = n->UU.U2.ndsubsid;
    while (grtmp != NULL) {
      removegraph(grtmp->grnode);
      grtmp = grtmp->grnext;
    }
  }
  /* Remove input edges */
  while (n->ndilist != NULL) {
    temp = n->ndilist;
    removeedge(&temp);
  }
  /* Remove output edges */
  while (n->ndolist != NULL) {
    temp = n->ndolist;
    removeedge(&temp);
  }
  /* Remove the node from the graph */
  if (n->ndsort != ndgraph) {
    prev = n->ndparent;
    while (prev->ndnext != n)
      prev = prev->ndnext;
    prev->ndnext = n->ndnext;
  }
  n->UU.U2.ndsubsid = NULL;
  n->ndnext = NULL;
  n->ndparent = NULL;
}  /* RemoveNode */


node *createsimplenode(opcode)
int opcode;
{
  /* Create a Simple node with the opcode given.
     The new node will have no input or output edges and will
     not be connected to any graph.
   */
  node *newnode;

  newnode = newnodealloc(ndatomic);
  univnodecnt++;
  newnode->ndid = univnodecnt;
  newnode->ndcode = opcode;
  return newnode;
}  /* CreateSimpleNode */


node *createcompoundnode(opcode)
int opcode;
{
  /* Create a Compound node with the opcode given.
     The new node will have no input or output edges and will
     not be connected to any graph.
   */
  node *newnode;

  newnode = newnodealloc(ndcompound);
  univnodecnt++;
  newnode->ndid = univnodecnt;
  newnode->ndcode = opcode;
  return newnode;
}  /* CreateCompoundNode */


static void insertnode(parentnode, prevnode, newnode)
node *parentnode, *prevnode, *newnode;
{
  /* Inserts NewNode into graph of ParentNode after PrevNode.
     If Prevnode = nil then the NewNode is inserted as the first
     in the graph headed by ParentNode.
   */
  node *ntemp, *WITH;

  newnode->ndparent = parentnode;
  if (prevnode == NULL) {   /* with */
    newnode->ndnext = parentnode->ndnext;
    parentnode->ndnext = newnode;
    if (newnode->ndnext == NULL)
      newnode->ndlabel = 1;
    else
      newnode->ndlabel = newnode->ndnext->ndlabel;
  } else {
    newnode->ndnext = prevnode->ndnext;
    prevnode->ndnext = newnode;
    newnode->ndlabel = prevnode->ndlabel + 1;
  }
  /* Now change the Labels of all nodes following NewNode */
  ntemp = newnode->ndnext;
  while (ntemp != NULL) {
    WITH = ntemp;
    WITH->ndlabel++;
    ntemp = WITH->ndnext;
  }
}  /* InsertNode*/


static void changeedgedest(e, newdestnode, newdestport)
port *e;
node *newdestnode;
int newdestport;
{
  /* -----------------------------------------------------------------
     Step 1  Removes E from it's current destination node's input list
             ( if it is in one) and
     Step 2  Adds it to NewDestNode's input list at port number
             NewDestPort
     NOTE:   This operation may cause Fan-In.
     ----------------------------------------------------------------- */
  port *nedge;
  boolean found;

  disconnectedgefromdest(e);
  /* Now Link E into input edge list of NewDestNode */
  e->pttonode = newdestnode;
  e->pttoport = newdestport;
  nedge = newdestnode->ndilist;
  if (nedge == NULL) {  /* List was empty, adding first edge */
    newdestnode->ndilist = e;
    e->pttonext = NULL;
    return;
  }
  if (nedge->pttoport >= newdestport) {  /* Insert first in list */
    e->pttonext = newdestnode->ndilist;
    newdestnode->ndilist = e;
    return;
  }
  found = false;
  do {
    if (nedge->pttonext == NULL)
      found = true;
    else if (nedge->pttonext->pttoport >= newdestport)
      found = true;
    else
      nedge = nedge->pttonext;
  } while (!found);
  /* insert after Nedge */
  e->pttonext = nedge->pttonext;
  nedge->pttonext = e;
}  /* ChangeEdgeDest */


static void changeedgesrc(e, newsrcnode, newsrcport)
port *e;
node *newsrcnode;
int newsrcport;
{
  /* -----------------------------------------------------------------
     Step 1  Removes E from it's current source node's output list
             ( if it is in one) and
     Step 2  Adds it to NewSrcNode's input list at port number
             NewSrcPort
     ----------------------------------------------------------------- */
  port *nedge;
  boolean found;

  disconnectedgefromsource(e);
  /* Now Link E into output edge list of NewSrcNode */
  e->UU.U1.ptfrnode = newsrcnode;
  e->UU.U1.ptfrport = newsrcport;
  nedge = newsrcnode->ndolist;
  if (nedge == NULL) {  /* List was empty, adding first edge */
    newsrcnode->ndolist = e;
    e->UU.U1.ptfrnext = NULL;
    return;
  }
  if (nedge->UU.U1.ptfrport >= newsrcport) {  /* Insert first in list */
    e->UU.U1.ptfrnext = newsrcnode->ndolist;
    newsrcnode->ndolist = e;
    return;
  }
  found = false;
  do {
    if (nedge->UU.U1.ptfrnext == NULL)
      found = true;
    else if (nedge->UU.U1.ptfrnext->UU.U1.ptfrport >= newsrcport)
      found = true;
    else
      nedge = nedge->UU.U1.ptfrnext;
  } while (!found);
  /* insert after Nedge */
  e->UU.U1.ptfrnext = nedge->UU.U1.ptfrnext;
  nedge->UU.U1.ptfrnext = e;
}  /* ChangeEdgeSrc */


port *insertedge(fromnode, fromport, tonode, toport, etype, name)
node *fromnode;
int fromport;
node *tonode;
int toport;
stentry *etype;
stryng name;
{  /* Does NOT work for inserting Literals */
  port *newedge;

  newedge = newedgealloc(ptedge);
  univedgecnt++;
  newedge->ptid = univedgecnt;
  newedge->ptname = name;
  newedge->pttype = etype;   /* with */
  changeedgedest(newedge, tonode, toport);
  changeedgesrc(newedge, fromnode, fromport);
  return newedge;
}  /* InsertEdge */


port *insertliteral(tonode, toport, etype, lvalue, lname)
node *tonode;
int toport;
stentry *etype;
stryng lvalue, lname;
{
  port *newedge;

  newedge = newedgealloc(ptlit);
  univedgecnt++;
  newedge->ptid = univedgecnt;
  newedge->ptname = lname;
  newedge->UU.ptlitvalue = lvalue;
  newedge->pttype = etype;   /* with */
  changeedgedest(newedge, tonode, toport);
  return newedge;
}  /* InsertLiteral */


static void renumbergraph(g, recurse)
node *g;
boolean recurse;
{
  /* Walks the graph G renumbering then nodes as it comes to them.
     If Recurse = true then it recursively renumbers the
     subgraphs of the compound nodes of G otherwise, it simple
     renumbers the nodes of G.
   */
  int lab, graphnum;
  node *n;
  int FORLIM;

  n = g->ndnext;
  lab = 0;
  while (n != NULL) {
    lab++;
    n->ndlabel = lab;
    if (recurse) {
      if (n->ndsort == ndcompound) {
        FORLIM = numbofsubgraphs(n);
        for (graphnum = 0; graphnum < FORLIM; graphnum++)
          renumbergraph(tochildgraph(n, graphnum), recurse);
      }
    }
    n = n->ndnext;
  }
}  /* RenumberGraph */


static void shiftinputports(n, startport, amount)
node *n;
int startport, amount;
{
  /* Shifts the port numbers of the input edges of N, starting from
     port StartPort and shifting by Amount.
   */
  boolean found;
  port *e;

  found = false;
  e = n->ndilist;
  while (e != NULL && !found) {
    if (e->pttoport >= startport)
      found = true;
    else
      e = e->pttonext;
  }
  if (!found)
    return;
  while (e != NULL) {
    e->pttoport += amount;
    e = e->pttonext;
  }
}  /* ShiftInputPorts */


static void shiftoutputports(n, startport, amount)
node *n;
int startport, amount;
{
  /* Shifts the port numbers of the output edges of N, starting from
     port StartPort and shifting by Amount.
   */
  boolean found;
  port *e;

  found = false;
  e = n->ndolist;
  while (e != NULL && !found) {
    if (e->UU.U1.ptfrport >= startport)
      found = true;
    else
      e = e->UU.U1.ptfrnext;
  }
  if (!found)
    return;
  while (e != NULL) {
    e->UU.U1.ptfrport += amount;
    e = e->UU.U1.ptfrnext;
  }
}  /* ShiftOutputPorts */


node *copynode(n)
node *n;
{
  /* Create and return a new node identical to N except without any
     input or output edges and detached from any surrounding graph.
     N is not changed in any way.
     If N is a graph node or a compound node, it copys the graph
     structure or the entire compound node.
   */
  node *newnode;

  if (n->ndsort == ndgraph)
    return (copygraph(n));
  else if (n->ndsort == ndcompound)
    return (copycompound(n));
  else {
    newnode = newnodealloc(ndatomic);
    univnodecnt++;
    newnode->ndid = univnodecnt;
    newnode->ndcode = n->ndcode;
    newnode->ndlabel = n->ndlabel;

    /* NEW CANN 2/92 FOR SDBX */
    newnode->ndsrcline = n->ndsrcline;

    return newnode;
  }

  /* N is a simple node */
}  /* CopyNode */


node *copycompound(oldn)
node *oldn;
{
  /*( OldN : NDPtr ) : NDPtr*/
  /* Returns a pointer to a newly created compound node
     with the same internal structure as OldN but no
     external input or output edges.
     Note: Recursively calls CopyGraph.
   */
  node *n;
  graph *lastgraph, *graphlink;
  assoclist *tagwalk, *taglast;
  int gnum, FORLIM;
  PSBLOCK b;

  n = newnodealloc(ndcompound);
  univnodecnt++;
  n->ndid = univnodecnt;
  n->ndcode = oldn->ndcode;
  n->ndlabel = oldn->ndlabel;
  /* Copy subgraphs of compound node */
  lastgraph = NULL;
  FORLIM = numbofsubgraphs(oldn);
  for (gnum = 0; gnum < FORLIM; gnum++) {
    graphlink = newgraphptr();
    graphlink->grnode = copygraph(tochildgraph(oldn, gnum));
    graphlink->grnode->ndparent = n;
    if (lastgraph == NULL)
      n->UU.U2.ndsubsid = graphlink;
    else
      lastgraph->grnext = graphlink;
    lastgraph = graphlink;
  }
  lastgraph->grnext = NULL;
  /* copy tag list (if it exists) */
  if (n->ndcode != ifntagcase)  /* copy tag list */
    return n;
  tagwalk = oldn->UU.U2.ndassoc;
  taglast = NULL;
  while (tagwalk != NULL) {
    if (taglast == NULL) {
      /* taglast = (assoclist *)Malloc(sizeof(assoclist)); */
      b = MySBlockAlloc(); /* CANN */
      taglast = &(b->al); /* CANN */

      taglast->next = NULL;
      n->UU.U2.ndassoc = taglast;
    } else {
      /* taglast->next = (assoclist *)Malloc(sizeof(assoclist)); */
      b = MySBlockAlloc(); /* CANN */
      taglast->next = &(b->al); /* CANN */

      taglast->next->next = NULL;
      taglast = taglast->next;
    }
    taglast->graphnum = tagwalk->graphnum;
    tagwalk = tagwalk->next;
  }
  taglast->next = NULL;
  return n;
}  /* CopyCompound */


static void copyedges(newg, oldg)
node *newg, *oldg;
{
  /* NewG is a skeleton structure of OldG.  It consists of
     Nodes identical to that of OldG and connected in the
     same order, but has no edges.  This procedure walks
     both NewG and OldG in tandem and makes a copy of each
     input edge of every node of OldG for each corresponding
     node of NewG.
   */
  node *oldn, *newn, *prodn;
  port *olde, *newe;
  int port_, nlab;
  PBBLOCK b;

  newn = newg;
  oldn = oldg;
  /* Walk the nodes of OldG and NewG */
  while (oldn != NULL) {
    if (oldn->ndlabel != newn->ndlabel) {
      printf("INTERNAL ERROR, COPYGRAPH: Wrong Labels: %12d%12d\n",
             oldn->ndlabel, newn->ndlabel);
      oldn = NULL;
      break;
    }
    olde = oldn->ndilist;
    while (olde != NULL) {
      /* newe = (port *)Malloc(sizeof(port)); */
      b = MyBBlockAlloc(); /* CANN */
      newe = &(b->p); /* CANN */

      *newe = *olde;
      /* Assign a different Id to this new edge */
      univedgecnt++;
      newe->ptid = univedgecnt;
      /* dlz ***     NewE^.PTExtraInfo := nil;  temp. commented out ****/
      newe->pttonode = NULL;
      newe->pttonext = NULL;
      changeedgedest(newe, newn, olde->pttoport);
      if (olde->ptsort == ptedge) {
        newe->UU.U1.ptfrnode = NULL;
        newe->UU.U1.ptfrnext = NULL;
        port_ = producerportnumber(olde);
        nlab = olde->UU.U1.ptfrnode->ndlabel;
        prodn = getnodewithlabel(newg, nlab);
        changeedgesrc(newe, prodn, port_);
      }
      olde = olde->pttonext;
    }
    oldn = oldn->ndnext;
    newn = newn->ndnext;
  }
}  /* CopyEdges */


node *copygraph(oldg)
node *oldg;
{
  /* ( OldG : NDPtr ) : NDPtr */
  /* Returns a pointer to a new graph that is an exact copy
     of the old graph, except that the nodes and edges have
     new and unique ID's */
  node *g, *n, *prev, *marker;

  g = newnodealloc(oldg->ndsort);
  univnodecnt++;
  g->ndid = univnodecnt;
  g->ndline = 0;
  g->ndsrcline = -SHORT_MAX;
  g->ndwiline = -SHORT_MAX;
  g->ndxcoord = -SHORT_MAX;
  g->ndycoord = -SHORT_MAX;
  /*dlz*** NDExtraInfo := nil; **** temp commented out*/
  g->ndnext = NULL;
  g->ndparent = NULL;
  g->ndilist = NULL;
  g->ndolist = NULL;
  g->nddepilist = NULL;
  g->nddepolist = NULL;
  g->ndnextinline = NULL;
  g->ndcode = oldg->ndcode;
  g->ndlabel = oldg->ndlabel;
  g->ndsort = oldg->ndsort;
  switch (g->ndsort) {

  case ndgraph:
    g->UU.U1.ndlink = NULL;
    g->UU.U1.ndtype = oldg->UU.U1.ndtype;
    break;

  case ndcompound:
    g->UU.U2.ndsubsid = NULL;
    break;
  default:
     ;
  }/* case */
  prev = g;
  marker = oldg->ndnext;
  /* Walk the graph copying nodes as we go along */
  while (marker != NULL) {
    if (marker->ndsort == ndcompound)
      n = copycompound(marker);
    else  /* Simple Node */
      n = copynode(marker);
    n->ndparent = g;
    prev->ndnext = n;
    prev = n;
    marker = marker->ndnext;
  }
  prev->ndnext = NULL;
  copyedges(g, oldg);
  return g;
}  /* CopyGraph */


/* macro procedure ChangeEdgeType( E : EGPtr; T : STPtr ); */
/* Changes the type of the edge E to T */
/* macro procedure ChangeNextNode( CurrentNode, NextNode : NDPtr ); */
/* Assumes CurrentNode <> nil */
static void cleanupnewiter(loop)
node *loop;
{
  node *bodyg;
  int lstart, lend, port_, maxloopin;
  port *e, *ine, *oute;

  bodyg = toiterbodygraph(loop);
  e = bodyg->ndilist;
  e = e->pttonext;
  lstart = e->pttoport;
  lend = largestinputportnumber(bodyg);
  maxloopin = largestinputportnumber(loop);
  /* Check for unused loop input Ports */
  for (port_ = 2; port_ <= maxloopin; port_++) {
    e = getoutputedge(bodyg, port_);
    oute = getoutputedge(loop, port_);
    if (e == NULL && oute == NULL) {
      e = getinputedge(loop, port_);
      if (e != NULL) {
        disconnectedgefromsource(e);
        disconnectedgefromdest(e);
      }
      if (getinputedge(bodyg, port_) == NULL) {
        shiftinputports(loop, port_, -1);
        shiftoutputports(bodyg, port_, -1);
        shiftinputports(bodyg, port_, -1);
        shiftoutputports(loop, port_, -1);
      }
    }  /*then*/
  }  /*for*/
  /* Check for unused L ports */
  for (port_ = lstart; port_ <= lend; port_++) {
    ine = getinputedge(bodyg, port_);
    oute = getoutputedge(bodyg, port_);
    e = getoutputedge(loop, port_);
    if (e == NULL && oute == NULL && ine != NULL) {
      disconnectedgefromsource(ine);
      disconnectedgefromdest(ine);
      shiftinputports(loop, port_, -1);
      shiftoutputports(bodyg, port_, -1);
      shiftinputports(bodyg, port_, -1);
      shiftoutputports(loop, port_, -1);
    }  /*then*/
  }  /*for*/
  cleanupgraph(bodyg);
}  /*CleanUpNewIter*/


static void cleanupforall(loop)
node *loop;
{
  int port_, count, k, l, t;
  port *e;
  node *geng, *bodyg, *retg;
  int FORLIM;

  geng = toforallgeneratorgraph(loop);
  bodyg = toforallbodygraph(loop);
  retg = toforallreturnsgraph(loop);
  k = largestinputportnumber(loop);
  l = largestinputportnumber(geng);
  if (l == 0)
    l = k;
  t = largestinputportnumber(bodyg);
  if (t == 0)
    t = l;
  /* walk input edges of Returns graph, removing unused edges */
  port_ = 1;
  FORLIM = largestinputportnumber(retg);
  for (count = 1; count <= FORLIM; count++) {
    if (getoutputedge(loop, port_) == NULL) {
      e = getinputedge(retg, port_);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(retg, port_, -1);
      shiftoutputports(loop, port_, -1);
    } else
      port_++;
  }
  /* remove unused nodes of this graph */
  cleanupgraph(retg);
  /* Check for missing temporaries */
  port_ = l + 1;
  for (count = port_; count <= t; count++) {
    if (getoutputedge(retg, port_) == NULL) {
      e = getinputedge(bodyg, port_);
      if (e != NULL)
        removeedge(&e);
      shiftoutputports(retg, port_, -1);
      shiftinputports(bodyg, port_, -1);
    } else
      port_++;
  }
  /* Now remove dead code from the body graph */
  cleanupgraph(bodyg);
  /* Check for unused Loop imports */
  port_ = 1;
  for (count = port_; count <= k; count++) {
    if ((getoutputedge(geng, port_) == NULL) & (getoutputedge(bodyg, port_) ==
          NULL) & (getoutputedge(retg, port_) == NULL)) {
      e = getinputedge(loop, port_);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(loop, port_, -1);
      shiftoutputports(geng, port_, -1);
      shiftinputports(geng, port_, -1);
      shiftoutputports(bodyg, port_, -1);
      shiftinputports(bodyg, port_, -1);
      shiftoutputports(retg, port_, -1);
    } else
      port_++;
  }
}  /* CleanUpForall */


static void cleanupiterloop(loop)
node *loop;
{
  node *initg, *testg, *bodyg, *retg;
  int k, l, t, port_, count;
  port *e;
  int FORLIM;

  initg = toinitgraph(loop);
  testg = totestgraph(loop);
  bodyg = tobodygraph(loop);
  retg = toreturnsgraph(loop);
  k = largestinputportnumber(loop);
  l = largestinputportnumber(initg);
  if (l == 0)
    l = k;
  t = largestinputportnumber(bodyg);
  if (t == 0)
    t = l;
  /* walk input edges of Returns graph, removing unused edges */
  port_ = 1;
  FORLIM = largestinputportnumber(retg);
  for (count = 1; count <= FORLIM; count++) {
    if (getoutputedge(loop, port_) == NULL) {
      e = getinputedge(retg, port_);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(retg, port_, -1);
      shiftoutputports(loop, port_, -1);
    } else
      port_++;
  }
  cleanupgraph(retg);
  cleanupgraph(testg);
  port_ = l + 1;
  for (count = port_; count <= t; count++) {
    if ((getoutputedge(retg, port_) == NULL) &
        (getoutputedge(testg, port_) == NULL)) {
      e = getinputedge(bodyg, port_);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(bodyg, port_, -1);
      shiftoutputports(testg, port_, -1);
      shiftoutputports(retg, port_, -1);
    } else
      port_++;
  }
  cleanupgraph(bodyg);
  port_ = k + 1;
  for (count = port_; count <= l; count++) {
    if ((getoutputedge(testg, port_) == NULL) &
        (getoutputedge(bodyg, port_) == NULL) & (getinputedge(bodyg, port_) ==
          NULL) & (getoutputedge(retg, port_) == NULL)) {
      e = getinputedge(initg, port_);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(initg, port_, -1);
      shiftoutputports(testg, port_, -1);
      shiftoutputports(bodyg, port_, -1);
      shiftinputports(bodyg, port_, -1);
      shiftoutputports(retg, port_, -1);
    } else
      port_++;
  }
  cleanupgraph(initg);
  port_ = 1;
  for (count = port_; count <= k; count++) {
    if ((getoutputedge(initg, port_) == NULL) & (getoutputedge(testg, port_) ==
          NULL) & (getoutputedge(bodyg, port_) == NULL) &
        (getoutputedge(retg, port_) == NULL)) {
      e = getinputedge(loop, port_);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(loop, port_, -1);
      shiftoutputports(initg, port_, -1);
      shiftinputports(initg, port_, -1);
      shiftoutputports(testg, port_, -1);
      shiftoutputports(bodyg, port_, -1);
      shiftinputports(bodyg, port_, -1);
      shiftoutputports(retg, port_, -1);
    } else
      port_++;
  }
}  /* CleanUpIterLoop */


static void cleanupselect(n)
node *n;
{
  int k, r, maxr, grnum, subgr, count, port_;
  node *g;
  port *e;
  boolean empty;

  grnum = numbofsubgraphs(n) - 1;
  k = largestinputportnumber(n);
  maxr = 0;
  for (subgr = 1; subgr <= grnum; subgr++) {
    r = largestinputportnumber(tochildgraph(n, subgr));
    if (r > maxr)
      maxr = r;
  }
  port_ = 1;
  for (count = 1; count <= maxr; count++) {
    if (getoutputedge(n, port_) == NULL) {
      shiftoutputports(n, port_, -1);
      for (subgr = 1; subgr <= grnum; subgr++) {
        g = tochildgraph(n, subgr);
        e = getinputedge(g, port_);
        if (e != NULL)
          removeedge(&e);
        shiftinputports(g, port_, -1);
      }
    } else
      port_++;
  }
  /* remove dead code from subgraphs */
  for (subgr = 0; subgr <= grnum; subgr++)
    cleanupgraph(tochildgraph(n, subgr));
  /* remove unused inputs */
  port_ = 1;
  for (count = 1; count <= k; count++) {
    empty = true;
    for (subgr = 0; subgr <= grnum; subgr++)
      empty &= (getoutputedge(tochildgraph(n, subgr), port_) == NULL);
    if (empty) {
      e = getinputedge(n, port_);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(n, port_, -1);
      for (subgr = 0; subgr <= grnum; subgr++)
        shiftoutputports(tochildgraph(n, subgr), port_, -1);
    } else
      port_++;
  }
}  /* CleanUpSelect */


static void cleanuptagcase(n)
node *n;
{
  int k, r, maxr, grnum, subgr, count, port_;
  node *g;
  port *e;
  boolean empty;

  grnum = numbofsubgraphs(n) - 1;
  k = largestinputportnumber(n);
  maxr = 0;
  for (subgr = 0; subgr <= grnum; subgr++) {
    r = largestinputportnumber(tochildgraph(n, subgr));
    if (r > maxr)
      maxr = r;
  }
  /* remove unused outputs */
  port_ = 1;
  for (count = 1; count <= maxr; count++) {
    if (getoutputedge(n, port_) == NULL) {
      shiftoutputports(n, port_, -1);
      for (subgr = 0; subgr <= grnum; subgr++) {
        g = tochildgraph(n, subgr);
        e = getinputedge(g, port_);
        if (e != NULL)
          removeedge(&e);
        shiftinputports(g, port_, -1);
      }
    } else
      port_++;
  }
  /* remove dead code in all subgraphs */
  for (subgr = 0; subgr <= grnum; subgr++)
    cleanupgraph(tochildgraph(n, subgr));
  /* remove unused inputs */
  port_ = 2;
  for (count = 2; count <= k; count++) {
    empty = true;
    for (subgr = 0; subgr <= grnum; subgr++)
      empty &= (getoutputedge(tochildgraph(n, subgr), port_) == NULL);
    if (empty) {
      e = getinputedge(n, port_);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(n, port_, -1);
      for (subgr = 0; subgr <= grnum; subgr++)
        shiftoutputports(tochildgraph(n, subgr), port_, -1);
    } else
      port_++;
  }
}  /* CleanUpTagCase */


static void cleanupifthenelse(n)
node *n;
{
  int k, r, maxr, grnum, subgr, count, port_;
  node *g;
  port *e;
  boolean empty;

  grnum = numbofsubgraphs(n) - 1;
  k = largestinputportnumber(n);
  maxr = 0;
  for (subgr = 0; subgr <= grnum; subgr++) {
    if ((subgr & 1) == 0 || subgr == grnum)
    {  /* only true and false subgraphs */
      r = largestinputportnumber(tochildgraph(n, subgr));
      if (r > maxr)
        maxr = r;
    }
  }
  port_ = 1;
  for (count = 1; count <= maxr; count++) {
    if (getoutputedge(n, port_) == NULL) {
      shiftoutputports(n, port_, -1);
      for (subgr = 0; subgr <= grnum; subgr++) {
        if ((subgr & 1) == 0 || subgr == grnum)
        {  /* only true and false subgraphs */
          g = tochildgraph(n, subgr);
          e = getinputedge(g, port_);
          if (e != NULL)
            removeedge(&e);
          shiftinputports(g, port_, -1);
        }
      }
    } else
      port_++;
  }
  /* remove dead code from subgraphs */
  for (subgr = 0; subgr <= grnum; subgr++)
    cleanupgraph(tochildgraph(n, subgr));
  /* remove unused inputs */
  /* NOTE:  Input on port 1 is control information and can't be removed */
  port_ = 2;
  for (count = 2; count <= k; count++) {
    empty = true;
    for (subgr = 0; subgr <= grnum; subgr++)
      empty &= (getoutputedge(tochildgraph(n, subgr), port_) == NULL);
    if (empty) {
      e = getinputedge(n, port_);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(n, port_, -1);
      for (subgr = 0; subgr <= grnum; subgr++)
        shiftoutputports(tochildgraph(n, subgr), port_, -1);
    } else
      port_++;
  }
}  /* CleanUpIfThenElse */



static void nsinit(s)
ndstack *s;
{
  s->length = 0;
  s->firstbucket = NULL;
  s->lastbucket = NULL;
}

static boolean nsempty(s)
ndstack *s;
{
  return (s->length == 0);
}

static void nspush(s, n)
ndstack *s;
node *n;
{
  nodebucket *b;
  int ix;

  s->length++;
  ix = (s->length - 1) % stackbucketsize + 1;
/* p2c: mono.bin.noblank.p, line 6129:
 * Note: Using % for possibly-negative arguments [317] */
  if (ix == 1) {
    b = (nodebucket *)Malloc(sizeof(nodebucket));
    b->prev = NULL;
    b->next = NULL;
    if (s->lastbucket == NULL) {  /* stack was empty */
      s->firstbucket = b;
      s->lastbucket = b;
      b->prev = NULL;
    } else {
      s->lastbucket->next = b;
      b->prev = s->lastbucket;
      s->lastbucket = b;
    }
    b->next = NULL;
  }
  /* must add a new bucket */
  /* put element in */
  s->lastbucket->elems[ix - 1] = n;   /* with */
}  /* NSPush */

static node *nspop(s)
ndstack *s;
{
  node *Result;
  int ix;
  nodebucket *b;

  if (s->length == 0)   /* with */
    return NULL;
  ix = (s->length - 1) % stackbucketsize + 1;
/* p2c: mono.bin.noblank.p, line 6164:
 * Note: Using % for possibly-negative arguments [317] */
  Result = s->lastbucket->elems[ix - 1];
  s->length--;
  if (ix != 1)
    return Result;
  if (s->firstbucket == s->lastbucket) {
    b = s->lastbucket;
    s->lastbucket = NULL;
    s->firstbucket = NULL;
    /* dispose( b );   *jyu* */
    return Result;
  }
  b = s->lastbucket;
  s->lastbucket = b->prev;
  if (s->lastbucket != NULL)
    s->lastbucket->next = NULL;
  b->prev = NULL;
  /* dispose( b ); *jyu* */
  return Result;

  /* else */
  /* else */
}  /* NSPop */


static void cleanupgraph(g)
node *g;
{
  /*( G : NDPtr )*/
  ndstack stk;
  node *above, *below, *curr;

  nsinit(&stk);
  /* walk down the graph reversing pointer */
  above = g;
  curr = g->ndnext;
  while (curr != NULL) {
    below = curr->ndnext;
    curr->ndnext = above;
    above = curr;
    curr = below;
  }
  /* Walk back up, reversing the pointers again and tagging dead nodes */
  curr = above;
  above = curr->ndnext;
  below = NULL;
  while (curr != g) {
    if (curr->ndolist == NULL) {
/* CANN PEEK */ if ( curr->ndcode != ifnpeek )
if ( !(CANN_GlueMode && (curr->ndcode == ifncall)) ) { /* NEW CANN */
      removeinputedges(curr);
      nspush(&stk, curr);
} /* NEW CANN */
    } else if (curr->ndsort == ndcompound) {
      switch (curr->ndcode) {

      case ifnforall:
        cleanupforall(curr);
        break;

      case ifnloopb:
        cleanupiterloop(curr);
        break;

      case ifnloopa:
        cleanupiterloop(curr);
        break;

      case ifnselect:
        cleanupselect(curr);
        break;

      case ifntagcase:
        cleanuptagcase(curr);
        break;

      case ifnifthenelse:
        cleanupifthenelse(curr);
        break;

      case ifniter:
        cleanupnewiter(curr);
        break;
      }
    }
    curr->ndnext = below;
    below = curr;
    curr = above;
    above = above->ndnext;
  }
  /* now remove marked nodes */
  while (!nsempty(&stk)) {
    curr = nspop(&stk);
    /*if MessagesOn then
              writeln( 'Dead Code Removal:  Removing node ', Curr^.NDId:1);
    */
    removenode(curr);
  }
}  /* CleanUpGraph */



static void removedeadcode()
{
  /* This routine walks the function graphs of a module, searching for
     and removing dead code.  Code is dead if it produces values that
     can never be used.  One example of this is a node with no output
     edges, another is a node that has output edges connected to a graph
     but for which there are no other implicit connections in other graphs.
     This second case can happen if temporaries are computed in the body
     of a loop and wired the the graph outputs but are never used in the
     test or returns graph.
     The algorithm requires that the nodes have been ordered.  It traverses
     the graph in reverse order (by walking down and reversing pointers then
     walking back up and restoring them) looking for nodes with no output
     edges.  If it finds one it removes all of its input edges and saves
     that node on a stack to be removed later (when the graph is restored).
     It cleans up compound nodes by traversing the subgraphs in the
     reverse order, taking account of impicit connections between subgraphs.
   */
  node *f;

  f = firstfunction;
  while (f != NULL) {
    cleanupgraph(f);
    f = tonextfunction(f);
  }
}  /* RemoveDeadCode */


static void rm(n)
node *n;
{
  port *e, *ie, *oe;
  node *srcnode, *cn;
  int srcport, port_, cp;
  stryng lvalue, name;

  /* First, change all output edges */
  ie = n->ndilist;
  while (ie != NULL) {
    port_ = ie->pttoport;
    oe = getoutputedge(n, port_);
    if (oe == NULL) {
      printf("WARNING: RemoveNoOp: No output edge on port %d", port_);
      printf(" of NoOp node ID = %d\n", n->ndid);
    } else if (producerportnumber(oe) != port_) {
      printf("WARNING: RemoveNoOp: No output edge on port %d", port_);
      printf(" of NoOp node ID = %d\n", n->ndid);
    } else if (ie->ptsort == ptlit) {
      /* make corresponding outputs Literals */
      lvalue = ie->UU.ptlitvalue;
      while (oe != NULL) {
        e = oe;
        oe = nextoutputedgesameport(oe);
        cp = e->pttoport;
        cn = e->pttonode;
        name = e->ptname;
        disconnectedgefromdest(e);
        disconnectedgefromsource(e);
        e = insertliteral(cn, cp, e->pttype, lvalue, name);
        /*  ChangeEdgeToLiteral( E, Lvalue )*/
      }
    } else {
      /* Change the source nodes of all outputs */
      srcnode = producernodeofedge(ie);
      srcport = producerportnumber(ie);
      while (oe != NULL) {
        e = oe;
        oe = nextoutputedgesameport(oe);
        changeedgesrc(e, srcnode, srcport);
      }
    }
    ie = ie->pttonext;
  }
  removenode(n);

  /* IE is an edge */
}  /* rm */


static void removenoop(g)
node *g;
{
  node *gn, *n;
  int grnum, FORLIM;

  n = g->ndnext;
  while (n != NULL) {
    gn = n;
    n = n->ndnext;
    if (gn->ndsort == ndcompound) {
      FORLIM = numbofsubgraphs(gn);
      for (grnum = 0; grnum < FORLIM; grnum++)
        removenoop(tochildgraph(gn, grnum));
    } else if (gn->ndcode == ifnnoop)
      rm(gn);
  }
}  /* RemoveNoOp */


static int compactinputs(c, startport, lastport)
node *c;
int startport, lastport;
{
  /* -- C is a compound node
     -- 1 <= StartPort <= LastPort <= LargestInputPortNumber( C )
     This function searches for input ports of C whose values
     are not used by any subgraphs.  If such a port is found:
       (1) the input edge corresponding to that port is removed
       (2) that port is "removed" by shifting the remaining
           ports to the left by one unit.
     -- The function returns the number of ports removed.
   */
  int p, ix, lastgraph, numberremoved, grnum;
  port *e;
  boolean portused;

  lastgraph = numbofsubgraphs(c) - 1;
  p = startport;
  numberremoved = 0;
  for (ix = p; ix <= lastport; ix++) {
    portused = false;
    grnum = 0;
    while (grnum <= lastgraph && !portused) {
      if (getoutputedge(tochildgraph(c, grnum), p) != NULL)
        portused = true;
      else
        grnum++;
    }
    if (portused)
      p++;
    else {  /* remove this port */
      numberremoved++;
      e = getinputedge(c, p);
      if (e != NULL)
        removeedge(&e);
      shiftinputports(c, p, -1);
      for (grnum = 0; grnum <= lastgraph; grnum++)
        shiftoutputports(tochildgraph(c, grnum), p, -1);
    }
  }
  return numberremoved;
}  /* CompactInputs */


static void compactports(c)
node *c;
{
  /* -- C is a compound node
     This routine examines the implicit port connections of C searching
     for port numbers that are no longer used by any subgraph.  If any
     are found, they are eliminated by shifting edges into this gap from
     the right.
   */
  port *tmpe, *e1, *e2, *e3;
  int k, l, t, p, count, ix;
  node *initg, *geng, *testg, *bodyg, *retg;

  k = largestinputportnumber(c);
  switch (c->ndcode) {

  case ifnforall:
    geng = toforallgeneratorgraph(c);
    bodyg = toforallbodygraph(c);
    retg = toforallreturnsgraph(c);
    l = largestinputportnumber(geng);
    if (l == 0)
      l = k;
    t = largestinputportnumber(bodyg);
    if (t == 0)
      t = l;
    /* Compact the K ports */
    count = compactinputs(c, 1, k);
    if (count > 0) {
      shiftinputports(geng, k + 1, -count);
      shiftinputports(bodyg, l + 1, -count);
      k -= count;
      l -= count;
      t -= count;
    }
    /* Compact the L ports */
    /*  P := K+1;Cannot remove and L ports, even if unused
              count := 0;
              for ix := P to L do
                begin
                  E1 := GetOutputEdge( BodyG, P );
                  E2 := GetOutputEdge( RetG, P );
                  if (E1 = nil) and (E2 = nil) then
                    begin
                      count := succ( count );
                      ShiftOutputPorts( BodyG, P, -1 );
                      ShiftInputPorts( BodyG, P, -1 );
                      ShiftOutputPorts( RetG, P, -1 );
                      TmpE := GetInputEdge( GenG, P );
                      if TmpE <> nil then
                        RemoveEdge( TmpE );
                      ShiftInputPorts( GenG, P, -1 )
                    end
                  else
                    P := succ( P )
                end;
              L := L - count;
              T := T - count;*/
    /* Compact the T ports */
    count = 0;
    p = l + 1;
    for (ix = p; ix <= t; ix++) {
      if (getoutputedge(retg, p) == NULL) {
        count++;
        shiftoutputports(retg, p, -1);
        tmpe = getinputedge(bodyg, p);
        if (tmpe != NULL)
          removeedge(&tmpe);
        shiftinputports(bodyg, p, -1);
      } else
        p++;
    }
    t -= count;
    break;
    /* IFNForall */

  case ifnloopa:
  case ifnloopb:
    initg = toinitgraph(c);
    testg = totestgraph(c);
    bodyg = tobodygraph(c);
    retg = toreturnsgraph(c);
    l = largestinputportnumber(initg);
    if (l == 0)
      l = k;
    t = largestinputportnumber(bodyg);
    if (t == 0)
      t = l;
    /* Compact the K ports */
    count = compactinputs(c, 1, k);
    if (count > 0) {
      shiftinputports(initg, k + 1, -count);
      shiftinputports(bodyg, k + 1, -count);
      k -= count;
      l -= count;
      t -= count;
    }
    /* Compact the L ports */
    p = k + 1;
    count = 0;
    for (ix = p; ix <= l; ix++) {
      e1 = getoutputedge(testg, p);
      e2 = getoutputedge(bodyg, p);
      e3 = getoutputedge(retg, p);
      if (e1 == NULL && e2 == NULL && e3 == NULL) {
        count++;
        shiftoutputports(testg, p, -1);
        shiftoutputports(bodyg, p, -1);
        tmpe = getinputedge(bodyg, p);
        if (tmpe != NULL)
          removeedge(&tmpe);
        shiftinputports(bodyg, p, -1);
        shiftoutputports(retg, p, -1);
        tmpe = getinputedge(initg, p);
        if (tmpe != NULL)
          removeedge(&tmpe);
        shiftinputports(initg, p, -1);
      } else
        p++;
    }
    l -= count;
    t -= count;
    /* Compact the T ports */
    count = 0;
    p = l + 1;
    for (ix = p; ix <= t; ix++) {
      e1 = getoutputedge(testg, p);
      e2 = getoutputedge(retg, p);
      if (e1 == NULL && e2 == NULL) {
        count++;
        shiftoutputports(testg, p, -1);
        shiftoutputports(retg, p, -1);
        tmpe = getinputedge(bodyg, p);
        if (tmpe != NULL)
          removeedge(&tmpe);
        shiftinputports(bodyg, p, -1);
      } else
        p++;
    }
    t -= count;
    break;
    /* IFNLoopA, IFNLoopB */

  case ifnselect:
    count = compactinputs(c, 1, k);
    break;
    /* IFNSelect */

  case ifntagcase:
    count = compactinputs(c, 2, k);
    break;
    /* IFNTagCase */

  case ifnifthenelse:
    count = compactinputs(c, 1, k);
    break;
    /* IFNIfThenElse */
  }/* case */
}  /* CompactPorts */


static void buildbasictype(base, name)
char base;
Char *name;
{
  /* builds a symbol table entry an IF1 basic type */
  /* BaseRange is a subrange of defined constants  */
  stentry *s;

  s = newtypealloc(iftbasic);
  s->stlabel = base + 1;
  string10(&s->stliteral, name);
  s->UU.stbasic = base;
  typetable[s->stlabel - 1] = s;
}  /* BuildBasicType */


/* dlz - reorganized and rewrote 8/87 to avoid referencing possibly
   uncompiled fields (vivek's), extracted similar sequences, etc.
   Also, rewrote pragma assignments thru new routines AssignNodePragma
   and AssignEdgePragma, now pragmas not usable in this version
   ignored and a cautionary message printed */
static void initmodule()
{
  /* Initializes the global variables needed for loading the program */
  int i;
  /* stentry *t; */
  node *WITH;

  univnodecnt = 0;
  univedgecnt = 0;
  univmodulecnt = 0;
  initstamps();
  funclist = NULL;
  firstfunction = NULL;
  module = newnodealloc(ndcompound);
  WITH = module;
  WITH->ndcode = ifnmodule;
  WITH->ndsort = ndcompound;
  WITH->UU.U2.ndsubsid = NULL;
  WITH->ndparent = NULL;
  WITH->ndnext = NULL;
  WITH->ndilist = NULL;
  WITH->ndolist = NULL;
  WITH->nddepilist = NULL;
  WITH->nddepolist = NULL;
  WITH->ndnextinline = NULL;
  buildbasictype(ifbboolean, "Boolean   ");
  buildbasictype(ifbcharacter, "Character ");
  buildbasictype(ifbdouble, "Double    ");
  buildbasictype(ifbinteger, "Integer   ");
  buildbasictype(ifbnull, "Null      ");
  buildbasictype(ifbreal, "Real      ");
  buildbasictype(ifbwild, "WildBasic ");
  tthwm = 7;
  for (i = tthwm; i < entrymax; i++)
    typetable[i] = NULL;
  /* Add the Wild Card Type to the Type Table */
  /* t = */ (void)getwildtype();
}  /* InitModule */

staticforward void dumpgraph PROTO((node*,struct LOC_dumpprogram *));

static void writetypenumber(entry_, LINK)
stentry *entry_;
struct LOC_dumpprogram *LINK;
{
  /* Print out the type number associated with this type pointer.
     If the pointer is nill the type number is zero.  */
  /* WriteTypeNumber */
  if (entry_ == NULL)
    fprintf(LINK->diag, "%c0", (Char)tab_);
  else
    fprintf(LINK->diag, "%c%d", (Char)tab_, entry_->stlabel);
}

static void dumpentry(eptr, LINK)
stentry *eptr;
struct LOC_dumpprogram *LINK;
{
  /* Print the type table entry for this Type pointer. */
  /* DumpEntry */
  if (eptr == NULL)   /* with */
    return;
  fprintf(LINK->diag, "T %d %d", eptr->stlabel, eptr->stsort);
  switch (eptr->stsort) {

  case iftwild:
    /* blank case */
    break;

  case iftbasic:
    fprintf(LINK->diag, " %d", eptr->UU.stbasic);
    break;

  case iftfunctiontype:
    writetypenumber(eptr->UU.U3.starg, LINK);
    writetypenumber(eptr->UU.U3.stres, LINK);
    break;

  case iftarray:
  case iftstream:
  case iftmultiple:
  case iftrecord:
  case iftunion:
  case iftbuffer:
    writetypenumber(eptr->UU.stbasetype, LINK);
    break;

  case iftfield:
  case ifttuple:
  case ifttag:
    writetypenumber(eptr->UU.U2.stelemtype, LINK);
    writetypenumber(eptr->UU.U2.stnext, LINK);
    break;
  }/* case */
  /* write type pragmas */
  if (eptr->stliteral.len != 0) {
    fprintf(LINK->diag, "    %%na=");
    writestring(LINK->diag, &eptr->stliteral);
  }
  if (eptr->stsize > 0)
    fprintf(LINK->diag, "    %%sz=%d", eptr->stsize);
  if (eptr->strecurflag)
    fprintf(LINK->diag, "    %%rt");
  putc('\n', LINK->diag);
}

static void writeedgepragmas(e, LINK)
port *e;
struct LOC_dumpprogram *LINK;
{
  if (e->ptname.len != 0) {
    fprintf(LINK->diag, "%c %%na=", (Char)tab_);
    writestring(LINK->diag, &e->ptname);
  }
  if (e->ptlbound != -SHORT_MAX)
    fprintf(LINK->diag, "%c%%bd=%d,%d", (Char)tab_, e->ptlbound, e->ptubound);
  if (e->ptdfaddr > 0)
    fprintf(LINK->diag, "%c%%of=%d", (Char)tab_, e->ptdfaddr);
  if (e->ptmark == byref)
    fprintf(LINK->diag, "%c%%mk=R", (Char)tab_);
  else if (e->ptmark == byval)
    fprintf(LINK->diag, "%c%%mk=V", (Char)tab_);
  else
    fprintf(LINK->diag, "%c%%mk=D", (Char)tab_);
  if (e->ptsrcline >= 0)
    fprintf(LINK->diag, "%c%%sl=%d", (Char)tab_, e->ptsrcline);
  if (e->ptwiline >= 0)
    fprintf(LINK->diag, "%c%%wl=%d", (Char)tab_, e->ptwiline);
  if (e->ptsetrc != -SHORT_MAX)
    fprintf(LINK->diag, "%c%%sr=%d", (Char)tab_, e->ptsetrc);
  if (e->ptprodmodrc != -SHORT_MAX)
    fprintf(LINK->diag, "%c%%pm=%d", (Char)tab_, e->ptprodmodrc);
  if (e->ptconmodrc != -SHORT_MAX)   /*with*/
    fprintf(LINK->diag, "%c%%cm=%d", (Char)tab_, e->ptconmodrc);
  putc('\n', LINK->diag);
}  /*WriteEdgePragmas*/

static void dumpinputedges(n, LINK)
node *n;
struct LOC_dumpprogram *LINK;
{
  /* Walk the input edges of the node N and print out
     each in turn.
     Print out the pragmas associated with each edge or literal.*/
  port *e, *WITH;

  e = n->nddepilist;   /* also display any dep edges */
  if (e == NULL)
    e = n->ndilist;
  while (e != NULL) {   /* while-with */
    WITH = e;
    if (e->ptsort == ptdep)
      fprintf(LINK->diag, "D%c%d%c%d\n",
              (Char)tab_, WITH->UU.U1.ptfrnode->ndlabel, (Char)tab_,
              WITH->pttonode->ndlabel);
    else {
      if (e->ptsort == ptlit)
        fprintf(LINK->diag, "L%c", (Char)tab_);
      else
        fprintf(LINK->diag, "E%c%d %d",
                (Char)tab_, WITH->UU.U1.ptfrnode->ndlabel,
                WITH->UU.U1.ptfrport);
      fprintf(LINK->diag, "%c%d %d",
              (Char)tab_, WITH->pttonode->ndlabel, WITH->pttoport);
      writetypenumber(WITH->pttype, LINK);
      if (WITH->ptsort == ptlit) {
        fprintf(LINK->diag, " \"");
        writestring(LINK->diag, &WITH->UU.ptlitvalue);
        putc('"', LINK->diag);
      }
      writeedgepragmas(e, LINK);
    }  /*else*/
    e = e->pttonext;
  }
}  /* DumpInputEdges */

static void writenodepragmas(n, LINK)
node *n;
struct LOC_dumpprogram *LINK;
{
   if (n->ndsrcline >= 0) {
      fprintf(LINK->diag, "%c%%sl=%d", (Char)tab_, n->ndsrcline);
      fprintf(LINK->diag, "\t%%sf=");
      writestring(LINK->diag,&infile[0]->parvalue);
   }
  if (n->ndwiline >= 0)
    fprintf(LINK->diag, "%c%%wl=%d", (Char)tab_, n->ndwiline);
  if (n->ndxcoord != -SHORT_MAX)
    fprintf(LINK->diag, "%c%%xy=%d,%d", (Char)tab_, n->ndxcoord, n->ndycoord);
  if (n->ndfrequency >= 0.0)
    fprintf(LINK->diag, "%c%%fq=% .5E", (Char)tab_, n->ndfrequency);
  if (n->ndexpanded == 1)
    fprintf(LINK->diag, "%c%%ep=1", (Char)tab_);
  else if (n->ndexpanded == 0)
    fprintf(LINK->diag, "%c%%ep=0", (Char)tab_);
  putc('\n', LINK->diag);   /*with*/
}  /*WriteNodePragmas*/

static void dumpsimple(n, LINK)
node *n;
struct LOC_dumpprogram *LINK;
{
  /* Print out the simple node N along with its pragmas */
/* CANN PEEK */  if ( n->ndcode == ifnpeek )
/* CANN PEEK */ fprintf(LINK->diag, "N %d%c314", n->ndlabel, (Char)tab_ );
/* CANN PEEK */ else
  fprintf(LINK->diag, "N %d%c%d", n->ndlabel, (Char)tab_, n->ndcode);
  writenodepragmas(n, LINK);
}  /* DumpSimple */

static void dumpcompound(n, LINK)
node *n;
struct LOC_dumpprogram *LINK;
{
  /* N is a compound node.
     This will consist of :
       (1) a header line
       (2) a list of subgraphs  (recursive call to DumpGraph)
       (3) a closing line with pragmas.
     The tagcase node is handled carefully to get the subgraph-tag
     associations correct.*/
  assoclist *atemp;
  graph *gptr;
  int count, graphcount;

  /* DumpCompound */
  fprintf(LINK->diag, "{ Compound %3d %3d\n", n->ndlabel, n->ndcode);
  /* Dump the subsidiary graphs */
  graphcount = 0;
  gptr = n->UU.U2.ndsubsid;
  while (gptr != NULL) {
    graphcount++;
    dumpgraph(gptr->grnode, LINK);
    gptr = gptr->grnext;
  }
  /* Dump the pointer list */
  if (n->ndcode == ifntagcase)   /* with N^ */
  {  /* Dump association list */
    /*find length of list*/
    count = 0;
    atemp = n->UU.U2.ndassoc;
    while (atemp != NULL) {
      count++;
      atemp = atemp->next;
    }
    fprintf(LINK->diag, "} %d %d %d", n->ndlabel, n->ndcode, count);
    /* write out the assoc list */
    atemp = n->UU.U2.ndassoc;
    while (atemp != NULL) {
      fprintf(LINK->diag, " %d", atemp->graphnum);
      atemp = atemp->next;
    }
  }  /*then*/
  else {   /*if*/
    fprintf(LINK->diag, "} %d %d %d", n->ndlabel, n->ndcode, graphcount);
    for (count = 0; count < graphcount; count++)
      fprintf(LINK->diag, " %d", count);
  }
  writenodepragmas(n, LINK);
}

Static void dumpgraph(g, LINK)
node *g;
struct LOC_dumpprogram *LINK;
{
  /*( G : NDPtr )*/
  /* Print out the appropriate IF1 line depending on the type
     of graph this is (X, I, or G).  Then walk the nodes of
     the graph and print out each node followed by all its input
     edges.*/
  node *n;
  linkrec *WITH1;

  /* Dump graph header */
  if (g->UU.U1.ndlink == NULL)   /*with*/
  {  /* Is a subgraph of a compound node */
    putc('G', LINK->diag);
    writetypenumber(g->UU.U1.ndtype, LINK);
  } else {   /* Is a Function Graph */
    WITH1 = g->UU.U1.ndlink;
    if (WITH1->lksort == lslocal)
      putc('G', LINK->diag);
    else if (WITH1->lksort == lsimported)
      putc('I', LINK->diag);
    else
      putc('X', LINK->diag);
    writetypenumber(g->UU.U1.ndtype, LINK);
    fprintf(LINK->diag, "%c\"", (Char)tab_);
    writestring(LINK->diag, &WITH1->lkname);
    putc('"', LINK->diag);
    /* write function pragmas here */
    if (WITH1->lkarsize >= 0)
      fprintf(LINK->diag, "%c%%ar=%d", (Char)tab_, WITH1->lkarsize);
    if (WITH1->lkexpand)
      fprintf(LINK->diag, "  %%ex");
  }
  /* with */
  writenodepragmas(g, LINK);
  /* CANN */ /* dumpinputedges(g, LINK); */
  n = g->ndnext;
  while (n != NULL) {
    if (n->ndsort == ndcompound)
      dumpcompound(n, LINK);
    else
      dumpsimple(n, LINK);
    dumpinputedges(n, LINK);
    n = n->ndnext;
  }
  dumpinputedges(g, LINK); /* CANN 1/92 DUMP GRAPH INPUT EDGES LAST */
}  /* DumpGraph */

static void dumpif1file(diag, LINK)
FILE *diag;
struct LOC_dumpprogram *LINK;
{
  /* Module = A pointer to a dummy compound node whose subsidiary
             graphs are the graphnodes of the if file being produced.*/
  int entrynum;
  Char ch;
  node *fgraph;
  int FORLIM;

  FORLIM = tthwm;

  CANN_DumpSpecialPragmas(diag);

  /* First dump the type table */
  for (entrynum = 0; entrynum < FORLIM; entrynum++)
    dumpentry(typetable[entrynum], LINK);
  /* Dump the stamps */
  for (ch = 'A'; ch <= 'Z'; ch++) {
    if (P_inset(ch, stampset)) {
      fprintf(diag, "C$  %c", ch);
      writestring(diag, &stamp[ch - 'A']);
      putc('\n', diag);
    }
  }
  fgraph = firstfunction;
  while (fgraph != NULL) {
    dumpgraph(fgraph, LINK);
    fgraph = tonextfunction(fgraph);
  }
}  /* DumpIF1File */


/* dlz, reorganized and consolidated 8/87: 3 deep procedure nesting to 1,
   conditional comp. of vivek's stuff, new procs Write(Node/Edge)Pragmas */
static void dumpprogram(outfile)
stryng outfile;
{
  struct LOC_dumpprogram V;

  V.diag = NULL;
  if (openoutputfile(&outfile, &V.diag))
    dumpif1file(V.diag, &V);
  else {
    printf("*** ERROR, cannot open output file: ");
    writestring(stdout, &outfile);
    printf(" ***\n");
  }
  if (V.diag != NULL)
    fclose(V.diag);
}  /* DumpProgram */



static void dumpmodule()
{
  stryng outfilename;

  outfilename = outfile->parvalue;
  dumpprogram(outfilename);
}  /* DumpModule */






static char hashfunction(name, LINK)
Char *name;
struct LOC_graphwalk *LINK;
{
  int sum, pos;
  sum = (name[0] - '0') * name[1] % 89;
/* p2c: mono.bin.noblank.p, line 8597:
 * Note: Using % for possibly-negative arguments [317] */
  for (pos = 2; pos < maxnamelen; pos++)
    sum += name[pos];
  return (sum % commtablesize);
/* p2c: mono.bin.noblank.p, line 8600:
 * Note: Using % for possibly-negative arguments [317] */
}


/* ---------------------------------------------------------------- */
/* A collection of routines to implement lists of integers          */
static boolean emptylist(l, LINK)
intlist *l;
struct LOC_graphwalk *LINK;
{
  return (l->length == 0);
}  /* EmptyList */

static void initlist(l, LINK)
intlist *l;
struct LOC_graphwalk *LINK;
{
  l->length = 0;
}  /* InitList */

static int poplist(l, LINK)
intlist *l;
struct LOC_graphwalk *LINK;
{
  int Result;

  Result = l->element[l->length - 1];
  l->length--;
  return Result;
}  /* PopList */

static void addtolist(l, ele, LINK)
intlist *l;
int ele;
struct LOC_graphwalk *LINK;
{
  int i;
  boolean found;

  /* see if ele is in list yet */
  i = 1;
  found = false;
  while (i <= l->length && !found) {
    if (l->element[i - 1] == ele)
      found = true;
    else
      i++;
  }
  if (found)
    return;
  if (i > intlistlen)
    printf("INTERNAL ERROR: List Overflow!!\n");
  else {
    l->length = i;
    l->element[i - 1] = ele;
  }
}  /* AddToList */

/* ---------------------------------------------------------------- */
static void displaytable(LINK)
struct LOC_graphwalk *LINK;
{
  int loc;
  commandrec *WITH;

  for (loc = 0; loc <= commtablemax; loc++) {
    WITH = &LINK->commandtable[loc];
    if (!WITH->empty)
      printf("loc: %2d  %.*s\n", loc, maxnamelen, WITH->name);
  }
}  /* DisplayTable */

static void insert_(cname_, command, LINK)
Char *cname_;
commandtype command;
struct LOC_initcommandtable *LINK;
{
  commandname cname;
  int loc;
  commandrec *WITH;

  mymemcpy(cname, cname_, sizeof(commandname));
  loc = hashfunction(cname, LINK->LINK);
  while (!LINK->LINK->commandtable[loc].empty) {
    loc = (loc + 1) % commtablesize;
/* p2c: mono.bin.noblank.p, line 8658:
 * Note: Using % for possibly-negative arguments [317] */
  }
  WITH = &LINK->LINK->commandtable[loc];
  WITH->empty = false;
  mymemcpy(WITH->name, cname, sizeof(commandname));
  WITH->commvalue = command;
}  /* Insert */

static void initcommandtable(LINK)
struct LOC_graphwalk *LINK;
{
  struct LOC_initcommandtable V;
  int loc;

  V.LINK = LINK;
  for (loc = 0; loc <= commtablemax; loc++)
    LINK->commandtable[loc].empty = true;
  insert_("above", ccnodesabove, &V);
  insert_("allf ", cclisallfun, &V);
  insert_("below", ccnodesbelow, &V);
  insert_("f    ", cclisnodeswop, &V);
  insert_("fr   ", ccrecfind, &V);
  insert_("fun  ", ccfunction, &V);
  insert_("graph", ccgraph, &V);
  insert_("gport", ccgraphports, &V);
  insert_("help ", cchelp, &V);
  insert_("id   ", ccnodeid, &V);
  insert_("iedge", cclisinedges, &V);
  insert_("label", ccnodelabel, &V);
  insert_("l    ", ccleft, &V);
  insert_("loop ", cclooplevel, &V);
  insert_("n    ", ccnextnode, &V);
  insert_("nodes", cclisallnodes, &V);
  insert_("oedge", cclisoutedges, &V);
  insert_("up   ", ccparent, &V);
  insert_("pos  ", ccposition, &V);
  insert_("q    ", ccquit, &V);
  insert_("r    ", ccright, &V);
  insert_("table", ccshowtable, &V);
  insert_("down ", ccsubgraph, &V);
  insert_("type ", ccdisptype, &V);
  insert_("dn   ", ccdumpnode, &V);
  insert_("di   ", ccdumpinput, &V);
  insert_("do   ", ccdumpoutput, &V);
  insert_("ddepi", ccdumpdepinput, &V);
  insert_("ddepo", ccdumpdepoutput, &V);
  insert_("dalli", ccdumpallinput, &V);
  insert_("dallo", ccdumpalloutput, &V);
}  /* InitCommandTable */

static void skipblanks(LINK)
struct LOC_graphwalk *LINK;
{
  boolean finished;

  finished = false;
  while (!finished) {
    if (P_eoln(stdin)) {
      finished = true;
      break;
    }
    if (P_inset(P_peek(stdin), LINK->blankchars))
      getc(stdin);
    else
      finished = true;
  }
}  /* SkipBlanks */

static boolean readinteger_(i, LINK)
int *i;
struct LOC_graphwalk *LINK;
{
  Char ch;

  skipblanks(LINK);
  ch = P_peek(stdin);
  if (ch >= '0' && ch <= '9') {
    scanf("%d", i);
    return true;
  } else
    return false;
}  /* ReadInteger */

static void readcommandname(cname, LINK)
Char *cname;
struct LOC_getvalidcommand *LINK;
{
  /* Read the command entered from the command line.
       -- Skip leading blanks and tabs
       -- Reads entire character string until eoln, blank or
          tab are found
       -- Smashes chars to lower case
       -- Only records first MaxNameLen characters
       -- Pads remainder of name with blanks
       -- Does not issue a readln since arguments may be forthcomming
  */
  int i, length;
  boolean found;
  Char ch;

  skipblanks(LINK->LINK);
  found = false;
  length = 0;
  while (!found) {
    if (P_eoln(stdin)) {
      found = true;
      break;
    }
    ch = P_peek(stdin);
    if (P_inset(ch, LINK->LINK->blankchars)) {
      found = true;
      break;
    }
    getc(stdin);
    if (length < maxnamelen) {
      length++;
      cname[length - 1] = lowercase(ch);
    }
  }
  /* pad word with blanks */
  for (i = length; i < maxnamelen; i++)
    cname[i] = ' ';
}  /* ReadCommandName */

static boolean foundintable(cname, command, LINK)
Char *cname;
commandtype *command;
struct LOC_getvalidcommand *LINK;
{
  boolean Result;
  int loc;
  boolean stilllooking;
  commandrec *WITH;

  stilllooking = true;
  loc = hashfunction(cname, LINK->LINK);
  while (stilllooking) {
    WITH = &LINK->LINK->commandtable[loc];
    if (WITH->empty) {
      stilllooking = false;
      Result = false;
      continue;
    }
    if (!strncmp(WITH->name, cname, sizeof(commandname))) {
      stilllooking = false;
      Result = true;
      *command = WITH->commvalue;
    } else {
      loc = (loc + 1) % commtablesize;
/* p2c: mono.bin.noblank.p, line 8789:
 * Note: Using % for possibly-negative arguments [317] */
    }
  }
  return Result;
}  /* FoundInTable */

static void getvalidcommand(command, LINK)
commandtype *command;
struct LOC_graphwalk *LINK;
{
  struct LOC_getvalidcommand V;
  boolean found;
  commandname cname;

  V.LINK = LINK;
  found = false;
  while (!found) {
    printf("GW>> ");
    readcommandname(cname, &V);
    if (foundintable(cname, command, &V)) {
      found = true;
      break;
    }
    scanf("%*[^\n]");
    getchar();
    printf("Command unknown: %.*s\n", maxnamelen, cname);
  }
}  /* GetValidCommand */

/* -------------------------------------------------------------- */
/* The following procedures  the operations of the          */
/* graphwalker.            */
static int findlooplevel(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  int level;
  boolean found;

  if (n == module)
    return -1;
  else {
    level = 0;
    found = false;
    while (!found) {
      if (n->ndsort == ndgraph) {
        switch (graphkind(n)) {

        case ifgselector:
        case ifgalternative:
        case ifgvariant:
        case ifgloopainit:
        case ifgloopbinit:
        case ifgifpredicate:
        case ifgiftrue:
        case ifgiffalse:
          /* blank case */
          break;

        case ifgloopabody:
        case ifgloopatest:
        case ifgloopareturns:
        case ifgloopbbody:
        case ifgloopbtest:
        case ifgloopbreturns:
        case ifgforallgenerator:
        case ifgforallbody:
        case ifgforallreturns:
          level++;
          break;

        case ifgfunction:
          found = true;
          break;
        default:
           ;
        }/* case */
      }
      n = n->ndparent;
    }
    return level;
  }
}  /* FindLoopLevel */

static int findlexicallevel(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  /* Function graphs are considered to be at level 0
     and the level number increases each time you dive
     into a the subgraphs of a compound node
   */
  int level;

  if (n == module)
    return -1;
  else {
    level = -1;
    do {
      n = toenclosingcompound(n);
      level++;
    } while (n != NULL);
    return level;
  }
}  /* FindLexicalLevel */

static void displayedge(e, LINK)
port *e;
struct LOC_graphwalk *LINK;
{
  if (e == NULL) {
    printf("Error:  nil edge pointer\n");
    return;
  }
  printf("%4d", e->ptif1line);
  if (e->ptsort == ptedge)
    printf(":  E  %2d %2d", e->UU.U1.ptfrnode->ndlabel, e->UU.U1.ptfrport);
  else
    printf(":  L       ");
  printf("     %2d %2d", e->pttonode->ndlabel, e->pttoport);
  printf("  Type: %3d", e->pttype->stlabel);
  if (e->ptsort == ptlit) {
    printf("  \"");
    writestring(stdout, &e->UU.ptlitvalue);
    putchar('"');
  }
  if (e->ptname.len != 0) {
    printf("  Name: ");
    writestring(stdout, &e->ptname);
  }
  if (e->ptdfaddr > 0)
    printf("   %%of=%d", e->ptdfaddr);
  putchar('\n');
}  /* DisplayEdge */

static void displaynode(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  int i, pos;
  printable name;
  ifgraphtype gkind;

  if (n == NULL) {
    printf("ERROR: Nil node pointer\n");
    return;
  }
  printf("%4d:", n->ndline);
  if (n->ndsort == ndgraph) {
    printf("  G %2d   ", n->ndlabel);
    gkind = graphkind(n);
    pos = 1;
    mymemcpy(name, graphname[(long)gkind], sizeof(printable));
    while (name[pos - 1] != ' ') {
      putchar(name[pos - 1]);
      pos++;
    }
    if (gkind == ifgfunction) {
      putchar(' ');
      writestring(stdout, &n->UU.U1.ndlink->lkname);
      pos += n->UU.U1.ndlink->lkname.len + 1;
    }
    for (i = pos + 1; i <= 19; i++)
      putchar(' ');
  } else {
    printf("  N %2d   ", n->ndlabel);
    pos = 1;
    mymemcpy(name, nodename[n->ndcode], sizeof(printable));
    while (name[pos - 1] != ' ') {
      putchar(name[pos - 1]);
      pos++;
    }
    for (i = pos + 1; i <= 19; i++)
      putchar(' ');
  }
  printf("  Id: %4d   Level: %2d\n", n->ndid, findlexicallevel(n, LINK));
}  /* DisplayNode */

static void writetype(t)
stentry *t;
{
  if (t == NULL) {
    printf("Nil");
    return;
  }
  switch (t->stsort) {

  case iftarray:
    printf("Array[ ");
    writetype(t->UU.stbasetype);
    printf(" ] ");
    break;

  case iftbasic:
    writestring(stdout, &t->stliteral);
    break;

  case iftfunctiontype:
    printf("Function ( ");
    writetype(t->UU.U3.starg);
    printf(" RETURNS ");
    writetype(t->UU.U3.stres);
    putchar(')');
    break;

  case iftmultiple:
    printf("Multiple[ ");
    writetype(t->UU.stbasetype);
    printf(" ] ");
    break;

  case iftrecord:
    printf("Record[ ");
    writetype(t->UU.stbasetype);
    printf(" ] ");
    break;

  case iftstream:
    printf("Stream[ ");
    writetype(t->UU.stbasetype);
    printf(" ] ");
    break;

  case ifttuple:
  case iftfield:
  case ifttag:
    writetype(t->UU.U2.stelemtype);
    if (t->UU.U2.stnext != NULL) {
      printf(", ");
      writetype(t->UU.U2.stnext);
    }
    break;

  case iftunion:
    printf("Union[ ");
    writetype(t->UU.stbasetype);
    printf(" ] ");
    break;

  case iftbuffer:
    printf("Buffer[ ");
    writetype(t->UU.stbasetype);
    printf("] ");
    break;

  case 10:
    printf(" special structured Wild type ");
    break;
  }/* case */
}  /* WriteType */

static void displaytype(LINK)
struct LOC_graphwalk *LINK;
{
  int typenum;

  if (!readinteger_(&typenum, LINK)) {
    printf("Invalid Integer Argument\n");
    return;
  }
  if (typenum < 1 || typenum > tthwm) {
    printf("Integer argument out of range: %d\n", typenum);
    return;
  }
  printf("Type %3d = ", typenum);
  writetype(typetable[typenum - 1]);
  putchar('\n');
}  /* DisplayType */

static void marknode(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  n->ndid = -n->ndid;
}

static boolean nodemarked(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  return (n->ndid < 0);
}

static void unmarkgraph(g, count, LINK)
node *g;
int count;
struct LOC_graphwalk *LINK;
{
  node *n;

  n = g->ndnext;
  while (count > 0) {
    if (n->ndid < 0) {
      count--;
      n->ndid = -n->ndid;
    }
    n = n->ndnext;
  }
}

static void gatherboundaryedges(l, n, mcount, LINK)
intlist *l;
node *n;
int *mcount;
struct LOC_graphwalk *LINK;
{
  node *pn;
  port *e;

  /* assume N is not marked */
  (*mcount)++;
  marknode(n, LINK);
  e = n->ndilist;
  while (e != NULL) {
    if (e->ptsort == ptedge) {
      pn = producernodeofedge(e);
      if (pn->ndsort == ndgraph)
        addtolist(l, producerportnumber(e), LINK);
      else if (!nodemarked(pn, LINK))
        gatherboundaryedges(l, pn, mcount, LINK);
    }
    e = e->pttonext;
  }
}  /* GatherBoundaryEdges */

static void listallfuns(LINK)
struct LOC_graphwalk *LINK;
{
  node *fun;

  fun = firstfunction;
  while (fun != NULL) {
    displaynode(fun, LINK);
    fun = tonextfunction(fun);
  }
}  /* ListAllFuns */

static void listallnodes(current, LINK)
node *current;
struct LOC_graphwalk *LINK;
{
  node *g, *n;

  if (current->ndsort == ndgraph)
    g = current;
  else
    g = current->ndparent;
  n = g->ndnext;
  if (n == NULL) {
    printf("Graph is Empty\n");
    return;
  }
  while (n != NULL) {
    displaynode(n, LINK);
    n = n->ndnext;
  }
}  /* ListAllNodes */

static void gotonextnode(cursor, LINK)
node **cursor;
struct LOC_graphwalk *LINK;
{
  node *n;

  n = (*cursor)->ndnext;
  if (n == NULL)
    printf("At end of graph\n");
  else {
    *cursor = n;
    displaynode(*cursor, LINK);
  }
}  /* GotoNextNode */

static void gotoparent(cursor, LINK)
node **cursor;
struct LOC_graphwalk *LINK;
{
  if (*cursor == module) {
    printf("How did you get here?  Module is off limits!\n");
    return;
  }
  if ((*cursor)->ndparent == module)
    printf("At top of function, you can't move up\n");
  else {
    *cursor = (*cursor)->ndparent;
    displaynode(*cursor, LINK);
  }
}  /* GotoParent */

static void showcurrfun(cursor, LINK)
node *cursor;
struct LOC_graphwalk *LINK;
{
  boolean finished;

  if (cursor == module) {
    printf("At Top Of Graph\n");
    return;
  }
  finished = false;
  while (!finished) {
    if (cursor->ndsort == ndgraph) {
      if (cursor->UU.U1.ndlink != NULL)
        finished = true;
      else
        cursor = cursor->ndparent;
    } else
      cursor = cursor->ndparent;
  }
  displaynode(cursor, LINK);
}  /* ShowCurrFun */

static void gotonodeid(cursor, LINK)
node **cursor;
struct LOC_graphwalk *LINK;
{
  node *n;
  int id;

  if (!readinteger_(&id, LINK)) {
    printf("Error: Bad node Id\n");
    return;
  }
  if (id < 1 || id > univnodecnt) {
    printf("Argument out of range: %d\n", id);
    return;
  }
  n = toenclosingfunction(*cursor);
  n = getnodewithid(n, id);
  if (n == NULL)
    printf("No such node in current function\n");
  else {
    *cursor = n;
    displaynode(*cursor, LINK);
  }
}  /* GotoNodeId */

static void showoutedges(cursor, LINK)
node *cursor;
struct LOC_graphwalk *LINK;
{
  port *e;
  int port_;

  if (readinteger_(&port_, LINK)) {
    e = getoutputedge(cursor, port_);
    if (e == NULL) {
      printf("No output edges from port %d\n", port_);
      return;
    }
    do {
      displayedge(e, LINK);
      e = nextoutputedgesameport(e);
    } while (e != NULL);
    return;
  }
  e = cursor->ndolist;
  if (e == NULL) {
    printf("No Output Edges\n");
    return;
  }
  while (e != NULL) {
    displayedge(e, LINK);
    e = e->UU.U1.ptfrnext;
  }
}  /* ShowOutEdges */

static void showinedges(cursor, LINK)
node *cursor;
struct LOC_graphwalk *LINK;
{
  port *e;
  int port_;

  if (readinteger_(&port_, LINK)) {
    e = getinputedge(cursor, port_);
    if (e == NULL)
      printf("No input edges to port %d\n", port_);
    else
      displayedge(e, LINK);
    return;
  }
  e = cursor->ndilist;
  if (e == NULL) {
    printf("No Input Edges\n");
    return;
  }
  while (e != NULL) {
    displayedge(e, LINK);
    e = e->pttonext;
  }

  /* No argument, display all edges */
}  /* ShowInEdges */

static void gotosubgraph(cursor, LINK)
node **cursor;
struct LOC_graphwalk *LINK;
{
  int graphnum;

  if ((*cursor)->ndsort != ndcompound) {
    printf("Not at a compound node\n");
    return;
  }
  if (!readinteger_(&graphnum, LINK)) {
    printf("Invalid integer argument\n");
    return;
  }
  if ((graphnum < 0) | (graphnum >= numbofsubgraphs(*cursor)))
    printf("No Subgraph numbered: %d\n", graphnum);
  else {
    *cursor = tochildgraph(*cursor, graphnum);
    displaynode(*cursor, LINK);
  }
}  /* GotoSubgraph */

static void gotonodelabel(cursor, LINK)
node **cursor;
struct LOC_graphwalk *LINK;
{
  node *g, *n;
  int lab;

  if (*cursor == module)
    g = *cursor;
  else if ((*cursor)->ndsort == ndgraph)
    g = *cursor;
  else
    g = (*cursor)->ndparent;
  if (!readinteger_(&lab, LINK)) {
    printf("Invalid Integer argument\n");
    return;
  }
  n = getnodewithlabel(g, lab);
  if (n == NULL)
    printf("No node with label: %d\n", lab);
  else {
    *cursor = n;
    displaynode(*cursor, LINK);
  }
}  /* GotoNodeLabel */

static void searchgraph(g, opcode, LINK)
node *g;
int opcode;
struct LOC_findnodes *LINK;
{
  node *n;
  int graphnum, FORLIM;

  n = g->ndnext;
  while (n != NULL) {
    if (n->ndcode == opcode)
      displaynode(n, LINK->LINK);
    if (LINK->recursive && n->ndsort == ndcompound) {
      FORLIM = numbofsubgraphs(n);
      for (graphnum = 0; graphnum < FORLIM; graphnum++)
        searchgraph(tochildgraph(n, graphnum), opcode, LINK);
    }
    n = n->ndnext;
  }
}  /* SearchGraph */

static void findnodes(cursor, recursive_, LINK)
node *cursor;
boolean recursive_;
struct LOC_graphwalk *LINK;
{
  struct LOC_findnodes V;
  node *g;
  int opcode;

  V.LINK = LINK;
  V.recursive = recursive_;
  if (cursor == module)
    g = cursor;
  else if (cursor->ndsort == ndgraph)
    g = cursor;
  else
    g = cursor->ndparent;
  if (readinteger_(&opcode, LINK))
    searchgraph(g, opcode, &V);
  else
    printf("Invalid Integer Argument\n");
}  /* FindNodes */

static void moveright_(cursor, LINK)
node **cursor;
struct LOC_graphwalk *LINK;
{
  /* If Cursor is positioned in a subgraph of a compound
     node, move to the sibling graph to the right (if one
     exists)
   */
  node *g;
  graph *gtemp;

  if (*cursor == module) {
    printf("Not in Subgraph of Compound Node\n");
    return;
  }
  if ((*cursor)->ndsort == ndgraph)
    g = *cursor;
  else
    g = (*cursor)->ndparent;
  gtemp = g->ndparent->UU.U2.ndsubsid;
  while (gtemp->grnode != g)
    gtemp = gtemp->grnext;
  if (gtemp->grnext == NULL)
    printf("No Graph to the right\n");
  else {
    *cursor = gtemp->grnext->grnode;
    displaynode(*cursor, LINK);
  }
}  /* MoveRight */

static void moveleft_(cursor, LINK)
node **cursor;
struct LOC_graphwalk *LINK;
{
  /* If Cursor is positioned in a subgraph of a compound
     node, move to the sibling graph to the left (if one
     exists)
   */
  node *g;
  graph *gtemp;

  if (*cursor == module) {
    printf("Not in Subgraph of Compound Node\n");
    return;
  }
  if ((*cursor)->ndsort == ndgraph)
    g = *cursor;
  else
    g = (*cursor)->ndparent;
  gtemp = g->ndparent->UU.U2.ndsubsid;
  if (gtemp->grnode == g) {
    printf("No subgraph to the left\n");
    return;
  }
  while (gtemp->grnext->grnode != g)
    gtemp = gtemp->grnext;
  *cursor = gtemp->grnode;
  displaynode(*cursor, LINK);
}  /* MoveLeft */

static void shownodesabove(cursor, LINK)
node *cursor;
struct LOC_graphwalk *LINK;
{
  int port_;
  port *e;
  intlist l;
  node *g;

  if (readinteger_(&port_, LINK)) {
    e = getinputedge(cursor, port_);
    if (e == NULL) {
      printf("No edge connected to input port: %d\n", port_);
      return;
    }
    if (e->ptsort == ptlit)
      printf("Literal connected to port: %d\n", port_);
    else
      displaynode(producernodeofedge(e), LINK);
    return;
  }
  initlist(&l, LINK);
  if (cursor->ndsort == ndgraph)
    g = cursor;
  else
    g = cursor->ndparent;
  e = cursor->ndilist;
  while (e != NULL) {
    if (e->ptsort == ptedge)
      addtolist(&l, nodelabel(producernodeofedge(e)), LINK);
    e = e->pttonext;
  }
  if (emptylist(&l, LINK))
    printf("Not Dependant on any nodes\n");
  else {
    while (!emptylist(&l, LINK))
      displaynode(getnodewithlabel(g, poplist(&l, LINK)), LINK);
  }
}  /* ShowNodesAbove */

static void shownodesbelow(cursor, LINK)
node *cursor;
struct LOC_graphwalk *LINK;
{
  int port_;
  port *e;
  intlist l;
  node *g;

  initlist(&l, LINK);
  if (cursor->ndsort == ndgraph)
    g = cursor;
  else
    g = cursor->ndparent;
  if (readinteger_(&port_, LINK)) {
    e = getoutputedge(cursor, port_);
    if (e == NULL)
      printf("No edges connected to output port: %d\n", port_);
    else {
      while (e != NULL) {
        addtolist(&l, nodelabel(e->pttonode), LINK);
        e = nextoutputedgesameport(e);
      }
    }
  } else {
    e = cursor->ndolist;
    while (e != NULL) {
      addtolist(&l, nodelabel(e->pttonode), LINK);
      e = e->UU.U1.ptfrnext;
    }
  }
  while (!emptylist(&l, LINK))
    displaynode(getnodewithlabel(g, poplist(&l, LINK)), LINK);
}  /* ShowNodesBelow */

static void showgraph(cursor, LINK)
node *cursor;
struct LOC_graphwalk *LINK;
{
  if (cursor == module) {
    printf("Not in a graph\n");
    return;
  }
  if (cursor->ndsort == ndgraph)
    displaynode(cursor, LINK);
  else
    displaynode(cursor->ndparent, LINK);
}  /* ShowGraph */

static void givehelp(LINK)
struct LOC_graphwalk *LINK;
{
  printf("above [port]     : List nodes directly above current node\n");
  printf("allf             : List all function in Module\n");
  printf("below [port]     : List nodes directly below current node\n");
  printf("dn               : Dump the node record of the current node\n");
  printf("di [port]        : Dump the input edge record(s)\n");
  printf("do [port]        : Dump the output edge record(s)\n");
  printf("ddepi\t\t: Dump the input dependence edge records\n");
  printf("ddepo\t\t: Dump the output dependence edge records\n");
  printf("f <opcode>       : List all nodes in current graph with the given opcode\n");
  printf("f <opcode>       : List all nodes in function with the given opcode\n");
  printf("fun              : List function containing current node\n");
  printf("gport            : List graph ports which effect current node\n");
  printf("graph            : List graph containing current node\n");
  printf("help             : Display this HELP table\n");
  printf("id <idnum>       : Move cursor to the node with this idnum\n");
  printf("iedge [port]     : List input edges of cursor\n");
  printf("l                : Move to left sibling graph\n");
  printf("label <lnum>     : Move cursor to node in current graph with this label\n");
  printf("loop    \t\t: Show cursors loop depth\n");
  printf("n                : Move to next node in the graph\n");
  printf("nodes            : List all nodes in the current graph\n");
  printf("oedge [port]     : List output edges of cursor\n");
  printf("up               : Move to parent graph or node\n");
  printf("pos              : Show current position\n");
  printf("q                : Quit the graphwalker\n");
  printf("r                : Move to the right sibling graph\n");
  printf("table            : Show distribution of commands in hash table\n");
  printf("down <grnum>     : Move to given subgraph of compound node (zero based)\n");
  printf("type <typenum>   : Show structure of given type\n");
}  /* GiveHelp */

static void showgraphports(cursor, LINK)
node *cursor;
struct LOC_graphwalk *LINK;
{
  intlist l;
  int markcount;

  if (cursor == module || cursor->ndsort == ndgraph) {
    printf("At graph node\n");
    return;
  }
  initlist(&l, LINK);
  markcount = 0;
  gatherboundaryedges(&l, cursor, &markcount, LINK);
  unmarkgraph(cursor->ndparent, markcount, LINK);
  printf("Graph Ports: ");
  while (!emptylist(&l, LINK))
    printf("%3d", poplist(&l, LINK));
  putchar('\n');
}  /* ShowGraphPorts */

static void dumpnode(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  int count;
  graph *g;
  linkrec *WITH1;

/* p2c: mono.bin.noblank.p, line 9464:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9464:
 * Note: Element has wrong type for WRITE statement [196] */
  printf("N =         <meef>\n");
  printf("NDId =      %11d   NDLabel =  %11d\n", n->ndid, n->ndlabel);
  printf("NDCode =    %11d   NDMisc. =   %11d\n", n->ndcode, n->ndmisc.numb);
/* p2c: mono.bin.noblank.p, line 9467:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9467:
 * Note: Element has wrong type for WRITE statement [196] */
/* p2c: mono.bin.noblank.p, line 9467:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9467:
 * Note: Element has wrong type for WRITE statement [196] */
  printf("NDParent =  <meef>   NDNext =   <meef>\n");
/* p2c: mono.bin.noblank.p, line 9468:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9468:
 * Note: Element has wrong type for WRITE statement [196] */
/* p2c: mono.bin.noblank.p, line 9468:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9468:
 * Note: Element has wrong type for WRITE statement [196] */
  printf("NDIList =   <meef>   NDOList =  <meef>\n");
  printf("NDLine =    %11d\n", n->ndline);
  printf("NDSrcLine = %11d   NDWiLine = %11d\n", n->ndsrcline, n->ndwiline);
  printf("NDXCoord =  %11d   NDYCoord = %11d\n", n->ndxcoord, n->ndycoord);
  switch (n->ndsort) {

  case ndatomic:
    printf("NDSort =       NDAtomic  (Simple Node)\n");
    break;

  case ndcompound:
    printf("NDSort =     NDCompound   NDAssoc =  <meef>\n");
/* p2c: mono.bin.noblank.p, line 9478:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9478:
 * Note: Element has wrong type for WRITE statement [196] */
    printf("NDSubsid =  <meef>\n");
    count = 0;
    g = n->UU.U2.ndsubsid;
    while (g != NULL) {
      printf("  Graph %d: (G = <meef>)  GRNode = <meef>  GRNext = <meef>\n",
             count);
      g = g->grnext;
      count++;
    }
/* p2c: mono.bin.noblank.p, line 9483:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9483:
 * Note: Element has wrong type for WRITE statement [196] */
/* p2c: mono.bin.noblank.p, line 9484:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9484:
 * Note: Element has wrong type for WRITE statement [196] */
/* p2c: mono.bin.noblank.p, line 9484:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9484:
 * Note: Element has wrong type for WRITE statement [196] */
    break;
/* p2c: mono.bin.noblank.p, line 9477:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9477:
 * Note: Element has wrong type for WRITE statement [196] */

  case ndgraph:
    printf("NDSort =        NDGraph   NDType =   <meef>");
    if (n->UU.U1.ndtype != NULL)
      printf("  (STLabel = %d)\n", n->UU.U1.ndtype->stlabel);
    else
      putchar('\n');
/* p2c: mono.bin.noblank.p, line 9496:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9496:
 * Note: Element has wrong type for WRITE statement [196] */
    printf("NDLink =    <meef>\n");
    if (n->UU.U1.ndlink != NULL) {
      WITH1 = n->UU.U1.ndlink;
      switch (WITH1->lksort) {

      case lslocal:
        printf(" LKSort =     LSstatic\n");
        break;

      case lsimported:
        printf(" LKSort =     LSImported  (Global)\n");
        break;

      case lsexported:
        printf(" LKSort =     LSExported  (Defined)\n");
        break;
      }/*case*/
      printf(" LKName =     ");
      writestring(stdout, &WITH1->lkname);
      printf("\n LKGraph =   <meef>  LKNext =    <meef>\n");
/* p2c: mono.bin.noblank.p, line 9508:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9508:
 * Note: Element has wrong type for WRITE statement [196] */
/* p2c: mono.bin.noblank.p, line 9508:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9508:
 * Note: Element has wrong type for WRITE statement [196] */
      printf(" LKARSize =  %11d  LKARIndex = %11d\n",
             WITH1->lkarsize, WITH1->lkarindex);
      if (WITH1->lkexpand)
        printf(" LKExpand =   TRUE\n");
      else
        printf(" LKExpand =   FALSE\n");
    }
    break;
/* p2c: mono.bin.noblank.p, line 9491:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9491:
 * Note: Element has wrong type for WRITE statement [196] */
  default:
     ;
  }/* case */
}  /* DumpNode */

static void dumponeedge(e, LINK)
port *e;
struct LOC_graphwalk *LINK;
{
/* p2c: mono.bin.noblank.p, line 9523:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9523:
 * Note: Element has wrong type for WRITE statement [196] */
/* p2c: mono.bin.noblank.p, line 9523:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9523:
 * Note: Element has wrong type for WRITE statement [196] */
  printf("E =         <meef>   PTType =    <meef>");
  if (e->pttype != NULL)
    printf("  (STLabel = %d)\n", e->pttype->stlabel);
  else
    putchar('\n');
  printf("PTIF1Line = %11d   PTName =    ", e->ptif1line);
  writestring(stdout, &e->ptname);
  printf("\nPTToNode =  <meef>   (NodeID = %d)\n", e->pttonode->ndid);
/* p2c: mono.bin.noblank.p, line 9531:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9531:
 * Note: Element has wrong type for WRITE statement [196] */
/* p2c: mono.bin.noblank.p, line 9533:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9533:
 * Note: Element has wrong type for WRITE statement [196] */
  printf("PTToNext =  <meef>   PTToPort =  %11d\n", e->pttoport);
  printf("PTSrcLine = %11d   PTWiLine =  %11d\n", e->ptsrcline, e->ptwiline);
  printf("PTId =      %11d", e->ptid);
  if (e->ptmark == byref)
    printf("   PTMark =          ByRef\n");
  else if (e->ptmark == byval)
    printf("   PTMark =          ByVal\n");
  else
    printf("   PTMark =          ByDefault\n");
  printf("PTLBound =  %11d   PTUBound =  %11d\n", e->ptlbound, e->ptubound);
  printf("PTDFAddr =  %11d\n", e->ptdfaddr);
  if (e->ptsort == ptedge) {
    printf("PTSort =         PTEdge\n");
/* p2c: mono.bin.noblank.p, line 9547:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9547:
 * Note: Element has wrong type for WRITE statement [196] */
    printf("PTFrNode =  <meef>   (^.NDId  = %d)\n", e->UU.U1.ptfrnode->ndid);
/* p2c: mono.bin.noblank.p, line 9549:
 * Internal error in writeelement: got a char * instead of a string [214] */
/* p2c: mono.bin.noblank.p, line 9549:
 * Note: Element has wrong type for WRITE statement [196] */
    printf("PTFrNext =  <meef>   PTFrPort =  %11d\n", e->UU.U1.ptfrport);
    return;
  }
  printf("PTSort =          PTLit\n");
  printf("PTLitValue =     ");
  writestring(stdout, &e->UU.ptlitvalue);
  putchar('\n');
}  /* DumpOneEdge */

static void dumpdepinputedges(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  port *e;

  e = n->nddepilist;
  if (e == NULL)
    printf("This node as no input dependence edges. \n");
  while (e != NULL) {
    dumponeedge(e, LINK);
    e = e->pttonext;
    if (e != NULL) {
      if (e->pttoport != 0)
        e = NULL;
      else
        printf("error, dep edges not connected to real edges\n");
    }
    if (e != NULL)
      printf("---------------\n");
  }
}

static void dumpdepoutputedges(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  port *e;

  e = n->nddepolist;
  if (e == NULL)
    printf("This node as no output dependence edges. \n");
  while (e != NULL) {
    dumponeedge(e, LINK);
    e = nextoutputedgesameport(e);
    if (e != NULL)
      printf("---------------\n");
  }
}

static void dumpinputedges_(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  int port_;
  port *e;

  if (readinteger_(&port_, LINK)) {
    e = getinputedge(n, port_);
    if (e == NULL)
      printf("No input edge on port # %d\n", port_);
    else
      dumponeedge(e, LINK);
    return;
  }
  e = n->ndilist;
  while (e != NULL) {
    dumponeedge(e, LINK);
    e = e->pttonext;
    if (e != NULL)
      printf("---------------\n");
  }

  /* Dump All Input Edges */
}

static void dumpallinput(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{  /* Dump All Input Edges */
  port *e;

  if (n->nddepilist == NULL)
    e = n->ndilist;
  else
    e = n->nddepilist;
  while (e != NULL) {
    dumponeedge(e, LINK);
    e = e->pttonext;
    if (e != NULL)
      printf("---------------\n");
  }
}

static void dumpoutputedges(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{
  int port_;
  port *e;

  if (readinteger_(&port_, LINK)) {
    e = getoutputedge(n, port_);
    if (e == NULL) {
      printf("No output edge on port # %d\n", port_);
      return;
    }
    while (e != NULL) {
      dumponeedge(e, LINK);
      e = nextoutputedgesameport(e);
      if (e != NULL)
        printf("---------------\n");
    }
    return;
  }
  e = n->ndolist;
  while (e != NULL) {
    dumponeedge(e, LINK);
    e = e->UU.U1.ptfrnext;
    if (e != NULL)
      printf("---------------\n");
  }

  /* Dump All Input Edges */
}  /* DumpOutputEdges */

static void dumpalloutput(n, LINK)
node *n;
struct LOC_graphwalk *LINK;
{  /* Dump All Output Edges */
  port *e;

  if (n->nddepolist == NULL)
    e = n->ndolist;
  else
    e = n->nddepolist;
  while (e != NULL) {
    dumponeedge(e, LINK);
    e = e->UU.U1.ptfrnext;
    if (e != NULL)
      printf("---------------\n");
  }
}


node *graphwalk(start)
node *start;
{
  struct LOC_graphwalk V;
  node *Result, *cursor;
  commandtype command;

  P_addset(P_expset(V.blankchars, 0L), ' ');
  P_addset(V.blankchars, (Char)tab_);
  initcommandtable(&V);
  cursor = start;
  command = ccposition;
  displaynode(cursor, &V);
  while (command != ccquit) {
    getvalidcommand(&command, &V);
    switch (command) {

    case cclisallfun:
      listallfuns(&V);
      break;

    case cclisallnodes:
      listallnodes(cursor, &V);
      break;

    case ccrecfind:
      findnodes(cursor, true, &V);
      break;

    case ccfunction:
      showcurrfun(cursor, &V);
      break;

    case cchelp:
      givehelp(&V);
      break;

    case ccnodeid:
      gotonodeid(&cursor, &V);
      break;

    case cclisinedges:
      showinedges(cursor, &V);
      break;

    case cclooplevel:
      printf("Loop Level: %d\n", findlooplevel(cursor, &V));
      break;

    case ccgraphports:
      showgraphports(cursor, &V);
      break;

    case ccnodelabel:
      gotonodelabel(&cursor, &V);
      break;

    case cclisnodeswop:
      findnodes(cursor, false, &V);
      break;

    case ccnextnode:
      gotonextnode(&cursor, &V);
      break;

    case cclisoutedges:
      showoutedges(cursor, &V);
      break;

    case ccparent:
      gotoparent(&cursor, &V);
      break;

    case ccposition:
      displaynode(cursor, &V);
      break;

    case ccquit:
      Result = cursor;
      break;

    case ccshowtable:
      displaytable(&V);
      break;

    case ccsubgraph:
      gotosubgraph(&cursor, &V);
      break;

    case ccdisptype:
      displaytype(&V);
      break;

    case ccright:
      moveright_(&cursor, &V);
      break;

    case ccleft:
      moveleft_(&cursor, &V);
      break;

    case ccnodesabove:
      shownodesabove(cursor, &V);
      break;

    case ccnodesbelow:
      shownodesbelow(cursor, &V);
      break;

    case ccgraph:
      showgraph(cursor, &V);
      break;

    case ccdumpnode:
      dumpnode(cursor, &V);
      break;

    case ccdumpinput:
      dumpinputedges_(cursor, &V);
      break;

    case ccdumpoutput:
      dumpoutputedges(cursor, &V);
      break;

    case ccdumpdepinput:
      dumpdepinputedges(cursor, &V);
      break;

    case ccdumpdepoutput:
      dumpdepoutputedges(cursor, &V);
      break;

    case ccdumpallinput:
      dumpallinput(cursor, &V);
      break;

    case ccdumpalloutput:
      dumpalloutput(cursor, &V);
      break;
    }/* case */
    scanf("%*[^\n]");
    getchar();
  }
  return Result;
}  /* GraphWalk */


/***********************NODE AND EDGE COUNT ROUTINES *******************/


int nextnodenum()
{
  int Result;

  Result = univnodecnt;
  univnodecnt++;
  return Result;
}


int nextedgenum()
{
  int Result;

  Result = univedgecnt;
  univedgecnt++;
  return Result;
}


int nextsgnodenum(fromlevel)
treestackobj *fromlevel;
{
  int Result;
  treestackobj *level;

  level = fromlevel;
  while (level->lleveltag == let)
    level = level->lastlevel;
  Result = level->nodecounter;
  level->nodecounter++;
  return Result;
}  /* NextSGNodeNum */


int nextreturnport(fromlevel)
treestackobj *fromlevel;
{
  int Result;
  treestackobj *level;

  level = fromlevel;
  while (level->lleveltag == let)
    level = level->lastlevel;
  switch (level->lleveltag) {

  case forloop:
  case specfa:
    level->UU.U0.freturnportnum++;
    Result = level->UU.U0.freturnportnum;
    break;

  case initloop:
    level->UU.U5.ireturnportnum++;
    Result = level->UU.U5.ireturnportnum;
    break;
  default:
     ;
  }/*case*/
  return Result;
}


static void nextbodyportname(level, str)
treestackobj *level;
stryng *str;
{
  level->UU.U0.bodyoutputportnum++;
  integerstring(str, level->UU.U0.bodyoutputportnum, 10);
  stripspaces(str);
  insertchar(str, '|', 1);
}


/*------------------  MEMORY MANAGEMENT --------------------*/
static void freesymptr(sym)
symtblbucket *sym;
{
  /* Free(sym); */
}


static void freetreestack(tree)
treestackobj *tree;
{
  /* Free(tree); */
}


static void newsemantic(ptr, tagtype)
semanticrec **ptr;
typesemanticdata tagtype;
{
  PSBLOCK b;

  /* *ptr = (semanticrec *)Malloc(sizeof(semanticrec)); */
  b = MySBlockAlloc(); /* CANN */
  *ptr = &(b->sr); /* CANN */

  (*ptr)->next = NULL;
  (*ptr)->tag = tagtype;
  switch (tagtype) {

  case tgnamelist:
    (*ptr)->UU.namelist = NULL;
    break;

  case tgtypelist:
    (*ptr)->UU.typelist = NULL;
    break;

  case tgttptr:
    (*ptr)->UU.ttptr = NULL;
    break;

  case tgsymptr:
    (*ptr)->UU.symptr = NULL;
    break;

  case tgexplist:
    (*ptr)->UU.explist = NULL;
    break;

  case tgpreclevel:
    (*ptr)->UU.U5.preclevel = -SHORT_MAX;
    (*ptr)->UU.U5.operation = noop;
    (*ptr)->UU.U5.line = -1;
    (*ptr)->UU.U5.column = -1;
    break;

  case tgsymlist:
    (*ptr)->UU.symlist = NULL;
    break;

  case tgnodeptr:
    (*ptr)->UU.nodeptr = NULL;
    break;

  case tgsubgraphnum:
    (*ptr)->UU.subgraphnum = 0;
    break;

  case tgoldflag:
    (*ptr)->UU.oldflag = false;
    break;

  case tgreduceflag:
    (*ptr)->UU.redflag = rfnone;
    break;

  case tgrednodetype:
    (*ptr)->UU.rednodetype = 0;
    break;

  case tgtestflag:
    (*ptr)->UU.testflag = neitherloop;
    break;

  case tgtcstacklist:
    (*ptr)->UU.tcstacklist = NULL;
    break;
  }/* case */
}


static void freesemantic(ptr)
semanticrec **ptr;
{
  Free(*ptr);
}


static void newnamelist(ptr)
namelistrec **ptr;
{
  PBBLOCK b;

  /* *ptr = (namelistrec *)Malloc(sizeof(namelistrec)); */
  b = MyBBlockAlloc(); /* CANN */
  *ptr = &(b->nlr); /* CANN */

  mymemcpy((*ptr)->name.str, blankstring, sizeof(stryngar));
  (*ptr)->name.len = 0;
  (*ptr)->next = NULL;
  (*ptr)->prev = NULL;
  (*ptr)->linenum = 0;
  (*ptr)->column = 0;
}


static void freenamelist(ptr)
namelistrec **ptr;
{
  Free(*ptr);
}


static void newtypelist(ptr)
typelistrec **ptr;
{
  PSBLOCK b;

  /* *ptr = (typelistrec *)Malloc(sizeof(typelistrec)); */
  b = MySBlockAlloc(); /* CANN */
  *ptr = &(b->tlr); /* CANN */

  (*ptr)->typeptr = NULL;
  (*ptr)->next = NULL;
  (*ptr)->prev = NULL;
  (*ptr)->linenum = 0;
}


static void freetypelist(ptr)
typelistrec **ptr;
{
  Free(*ptr);
}


static void newtornlist(ptr, tag)
tornrec **ptr;
torntype tag;
{
  *ptr = (tornrec *)Malloc(sizeof(tornrec));
  (*ptr)->torntag = tag;
  switch (tag) {

  case typetag:
    (*ptr)->UU.ttptr = NULL;
    break;

  case symtag:
    (*ptr)->UU.symptr = NULL;
    break;
  }
  (*ptr)->next = NULL;
  (*ptr)->prev = NULL;
}


static void freetornlist(ptr)
tornrec **ptr;
{
  Free(*ptr);
}


static void newttptr(ptr, tagtype)
stentry **ptr;
char tagtype;
{
  PBBLOCK b;
  /* *ptr = (stentry *)Malloc(sizeof(stentry)); */
  b = MyBBlockAlloc(); /* CANN */
  *ptr = &(b->i); /* CANN */

  (*ptr)->stid = -1;
  (*ptr)->stlabel = -1;
  (*ptr)->stequivchain = *ptr;
  mymemcpy((*ptr)->stliteral.str, blankstring, sizeof(stryngar));
  (*ptr)->stliteral.len = 0;
  (*ptr)->stsize = 0;
  (*ptr)->strecurflag = false;
  (*ptr)->stsort = tagtype;
  switch (tagtype) {

  case iftwild:
    /* blank case */
    break;

  case iftbasic:
    (*ptr)->UU.stbasic = 0;
    break;

  case iftfunctiontype:
    (*ptr)->UU.U3.starg = NULL;
    (*ptr)->UU.U3.stres = NULL;
    break;

  case iftarray:
  case iftstream:
  case iftmultiple:
  case iftrecord:
  case iftunion:
    (*ptr)->UU.stbasetype = NULL;
    break;

  case iftfield:
  case ifttuple:
  case ifttag:
    (*ptr)->UU.U2.stelemtype = NULL;
    (*ptr)->UU.U2.stnext = NULL;
    break;
  }/* case */
}


static void freettptr(ptr)
stentry **ptr;
{
  Free(*ptr);
}


node *newnodeptr(ntype, level)
nodesort ntype;
treestackobj *level;
{
  node *node_;

  node_ = newnodealloc(ntype);
  node_->ndid = nextnodenum();
  node_->ndlabel = nextsgnodenum(level);   /* with */
  return node_;
}  /* NewNode */


port *newedgeptr(ptype)
portsort ptype;
{
  port *edge;

  edge = newedgealloc(ptype);
  edge->ptid = nextedgenum();
  return edge;
}


linkrec *newlinkageptr(linkagesort)
linksort linkagesort;
{
  linkrec *lk;
  PBBLOCK b;

  /* lk = (linkrec *)Malloc(sizeof(linkrec)); */
  b = MyBBlockAlloc(); /* CANN */
  lk = &(b->lr); /* CANN */

  lk->lksort = linkagesort;
  lk->lkgraph = NULL;
  mymemcpy(lk->lkname.str, blankstring, sizeof(stryngar));
  lk->lkname.len = 0;
  mymemcpy(lk->lkmodulename.str, blankstring, sizeof(stryngar));
  lk->lkmodulename.len = 0;
  lk->lkarsize = -1;
  lk->lkexpand = false;
  lk->lkarindex = -1;
  lk->lknext = NULL;   /*with*/
  return lk;
}  /*NewLinkagePtr*/


graph *newgraphptr()
{
  graph *gr;
  PSBLOCK b;

  /* gr = (graph *)Malloc(sizeof(graph)); */
  b = MySBlockAlloc(); /* CANN */
  gr = &(b->g); /* CANN */

  gr->grnode = NULL;
  gr->grnext = NULL;
  return gr;
}



edgelisthead *newheadptr()
{
  edgelisthead *head;
  PBBLOCK b;

  /* head = (edgelisthead *)Malloc(sizeof(edgelisthead)); */
  b = MyBBlockAlloc(); /* CANN */
  head = &(b->elh); /* CANN */

  mymemcpy(head->edgename.str, blankstring, sizeof(stryngar));
  head->edgename.len = 0;
  head->edges = NULL;
  head->next = NULL;
  return head;
}


static void freeheadptr(head)
edgelisthead **head;
{
  Free(*head);
}


edgelist *newedgelistptr()
{
  edgelist *edgelist_;
  PSBLOCK b;

  /* edgelist_ = (edgelist *)Malloc(sizeof(edgelist)); */
  b = MySBlockAlloc(); /* CANN */
  edgelist_ = &(b->el); /* CANN */

  edgelist_->edge = NULL;
  edgelist_->next = NULL;
  edgelist_->toorfrom = noport;
  return edgelist_;
}


static void freeedgelistptr(edgelist_)
edgelist **edgelist_;
{
  Free(*edgelist_);
}


refrec *newreferencesptr()
{
  refrec *refptr_;
  PSBLOCK b;

  /* refptr_ = (refrec *)Malloc(sizeof(refrec)); */
  b = MySBlockAlloc(); /* CANN */
  refptr_ = &(b->rr); /* CANN */

  refptr_->front = NULL;
  refptr_->back = NULL;
  return refptr_;
}


static inforecord *newinfoptr()
{
  inforecord *ptr;
  PBBLOCK b;

  /* ptr = (inforecord *)Malloc(sizeof(inforecord)); */
  b = MyBBlockAlloc(); /* CANN */
  ptr = &(b->ir);      /* CANN */

  ptr->node_ = NULL;
  ptr->port_ = -1;
  ptr->typeptr = NULL;
  mymemcpy(ptr->name.str, blankstring, sizeof(stryngar));
  ptr->name.len = 0;
  mymemcpy(ptr->litvalue.str, blankstring, sizeof(stryngar));
  ptr->litvalue.len = 0;
  ptr->onlist = NULL;
  return ptr;
}


static void freeinfoptr(ptr)
inforecord **ptr;
{
  Free(*ptr);
}


static explistnode *newexplistptr()
{
  explistnode *explist;
  PSBLOCK b;

  /* explist = (explistnode *)Malloc(sizeof(explistnode)); */
  b = MySBlockAlloc(); /* CANN */
  explist = &(b->eln); /* CANN */

  explist->graphinfo = newinfoptr();
  explist->next = NULL;
  return explist;
}  /* NewExpList */


static tcstacklistrec *newtcstacklist()
{
  tcstacklistrec *ptr;

  ptr = (tcstacklistrec *)Malloc(sizeof(tcstacklistrec));
  mymemcpy(ptr->tagname.str, blankstring, sizeof(stryngar));
  ptr->tagname.len = 0;
  ptr->sgnum = 0;
  ptr->typeptr = NULL;
  ptr->next = NULL;
  return ptr;
}  /* NewExpList */


static errorrecord *newerrorptr(etype)
errortypes etype;
{
  errorrecord *newe;

  newe = (errorrecord *)Malloc(sizeof(errorrecord));
  newe->etype = etype;
  newe->linenumber = -1;
  newe->column = -1;
  switch (etype) {

  case tnameundef:
  case vnameundef:
  case fndoubdef:
  case tagnameddef:
  case fieldnameddef:
  case defineerr:
  case doubledefarg:
  case forwardtype:
  case expimporterr:
  case forwardnotresolved:
  case undeffunct:
  case atypenameerr:
  case vnamenotloopvar:
  case undeftagub:
  case tnonubuild:
  case nameundrs:
  case ntypeonrs:
  case nameundrr:
  case typeclashrr:
  case undefntag:
  case nameundeftc:
  case ddtname:
  case notalltc:
  case vardoubledef:
  case arityonfa:
  case atinrg:
  case decbutnotdef:
  case lvarnotdef:
  case lvarusebredef:
  case loopcvmix:
  case loopconsassn:
  case redefimlvar:
  case lvarneverredef:
  case deflistnotempty:
  case typedoubdef:
  case innerfndoubdef:
    mymemcpy(newe->UU.errorstr.str, blankstring, sizeof(stryngar));
    newe->UU.errorstr.len = 0;
    break;

  case binaryoparity:
  case unaryoparity:
  case binarytypesnoteq:
    mymemcpy(newe->UU.errorstr.str, blankstring, sizeof(stryngar));
    newe->UU.errorstr.len = 0;
    newe->UU.op = noop;
    break;

  case unarytypeerr:
    newe->UU.typeptr = NULL;
    newe->UU.U31.uop = noop;
    break;

  case notypeabuild:
  case notarraytype:
  case arraytypeclash:
  case lbarity:
  case lbtype:
  case arityonerror:
  case chararity:
  case doublearity:
  case intarity:
  case arityonisu:
  case arityonrbuild:
  case typeonrbuild:
  case arityonubuild:
  case typeclashub:
  case arityonrselect:
  case etypeonrs:
  case arityonrexp:
  case arityonoexp:
  case ntyperr:
  case prednotbool:
  case predarity:
  case nothingsc:
  case typenssc:
  case typeclashsc:
  case arityontag:
  case typenutc:
  case typesnsametc:
  case othernone:
  case indexexperr:
  case arrayarity:
  case needarraytype:
  case arityareplace:
  case typeareplace:
  case replaceoverdim:
  case replaceelemtype:
  case arrayofarity:
  case valueofarity:
  case streamofarity:
  case maskingarity:
  case masknotbool:
  case longexplist:
  case longnamelist:
  case cdmix:
  case testarity:
  case testnotbool:
  case realarity:
    /* blank case */
    break;

  case charitype:
  case doubleitype:
  case intitype:
  case isutype:
  case typeonfa:
  case icnotas:
  case realitype:
    newe->UU.typeptr = NULL;
    break;

  case binarytypeerr:
    newe->UU.U18.btypeptr = NULL;
    newe->UU.U18.bop = noop;
    break;

  case typefunctarg:
  case numfunctarg:
    mymemcpy(newe->UU.U29.functionname.str, blankstring, sizeof(stryngar));
    newe->UU.U29.functionname.len = 0;
    newe->UU.U29.argnum = -1;
    break;

  case typefunctres:
  case numfunctres:
    mymemcpy(newe->UU.U19.functname.str, blankstring, sizeof(stryngar));
    newe->UU.U19.functname.len = 0;
    newe->UU.U19.resnum = -1;
    break;

  case asstypeclash:
    newe->UU.U21.exptype = NULL;
    newe->UU.U21.nametype = NULL;
    break;

  case vardoubledecl:
    mymemcpy(newe->UU.U25.varname.str, blankstring, sizeof(stryngar));
    newe->UU.U25.varname.len = 0;
    newe->UU.U25.exp1type = NULL;
    newe->UU.U25.exp2type = NULL;
    break;

  case abuildelemtype:
    newe->UU.elemnum = -1;
    break;

  case ifreturnstypes:
  case tagreturnstypes:
  case numifreturns:
  case expsnstypesc:
  case numtagreturns:
    newe->UU.expnum = 0;
    break;

  case reducetype:
    newe->UU.U91.redflag = rfnone;
    newe->UU.U91.redtype = NULL;
    break;
  }/* case */
  return newe;
}  /* NewErrorPtr */


static void freeerrorptr(errorrec)
errorrecord **errorrec;
{
  Free(*errorrec);
}


static symlistnode *newsymlistptr()
{
  symlistnode *slptr;
  PSBLOCK b;

  /* slptr = (symlistnode *)Malloc(sizeof(symlistnode)); */
  b = MySBlockAlloc(); /* CANN */
  slptr = &(b->sln); /* CANN */

  slptr->sym = NULL;
  slptr->next = NULL;
  return slptr;
}  /* NewSymListPtr */



Char *errortypes_NAMES[] = {
  "fndoubdef", "tnameundef", "fieldnameddef", "tagnameddef", "defineerr",
  "doubledefarg", "forwardtype", "innerfndoubdef", "binaryoparity",
  "chararity", "doublearity", "intarity", "realarity", "binarytypesnoteq",
  "charitype", "doubleitype", "intitype", "realitype", "binarytypeerr",
  "typefunctres", "numfunctres", "asstypeclash", "vardoubledef",
  "longexplist", "longnamelist", "vardoubledecl", "vnameundef", "undeffunct",
  "typefunctarg", "numfunctarg", "unaryoparity", "unarytypeerr",
  "vnamenotloopvar", "arityonerror", "arityonisu", "isutype", "expimporterr",
  "arityonrbuild", "typeonrbuild", "forwardnotresolved", "arityonubuild",
  "tnonubuild", "undeftagub", "typeclashub", "lbarity", "lbtype",
  "notypeabuild", "atypenameerr", "notarraytype", "arraytypeclash",
  "abuildelemtype", "arityonrselect", "etypeonrs", "nameundrs", "ntypeonrs",
  "arityonrexp", "arityonoexp", "ntyperr", "nameundrr", "typeclashrr",
  "ifreturnstypes", "tagreturnstypes", "numifreturns", "numtagreturns",
  "prednotbool", "predarity", "nothingsc", "typenssc", "expsnstypesc",
  "typeclashsc", "undefntag", "arityontag", "typenutc", "nameundeftc",
  "ddtname", "typesnsametc", "othernone", "notalltc", "arrayarity",
  "needarraytype", "indexexperr", "arityareplace", "typeareplace",
  "replaceoverdim", "replaceelemtype", "valueofarity", "maskingarity",
  "masknotbool", "arityonfa", "typeonfa", "atinrg", "reducetype",
  "arrayofarity", "streamofarity", "icnotas", "cdmix", "decbutnotdef",
  "lvarnotdef", "testarity", "testnotbool", "lvarusebredef", "loopcvmix",
  "loopconsassn", "redefimlvar", "lvarneverredef", "deflistnotempty",
  "typedoubdef"
} ;


static void printtypesort(filename, typeptr)
FILE *filename;
stentry *typeptr;
{
  switch (typeptr->stsort) {

  case iftarray:
    fprintf(filename, "array ");
    break;

  case iftstream:
    fprintf(filename, "stream ");
    break;

  case iftrecord:
    fprintf(filename, "record ");
    break;

  case iftunion:
    fprintf(filename, "union ");
    break;

  case iftfield:
    fprintf(filename, "field ");
    break;

  case iftfunctiontype:
    fprintf(filename, "function type ");
    break;

  case iftmultiple:
    fprintf(filename, "multiple ");
    break;

  case ifttag:
    fprintf(filename, "tag ");
    break;

  case ifttuple:
    fprintf(filename, "tuple ");
    break;

  case iftwild:
    fprintf(filename, "wild ");
    break;

  case iftbasic:
    switch (typeptr->UU.stbasic) {

    case ifbboolean:
      fprintf(filename, "boolean ");
      break;

    case ifbcharacter:
      fprintf(filename, "character ");
      break;

    case ifbdouble:
      fprintf(filename, "double ");
      break;

    case ifbinteger:
      fprintf(filename, "integer ");
      break;

    case ifbnull:
      fprintf(filename, "null ");
      break;

    case ifbreal:
      fprintf(filename, "real ");
      break;

    case ifbwild:
      fprintf(filename, "wild ");
      break;
    }/* case */
    break;
  }/*case*/
}  /*PrintTypeSort*/

static void printoperation(filename, op)
FILE *filename;
opertype op;
{
  switch (op) {

  case orop:
    fprintf(filename, "| ");
    break;

  case andop:
    fprintf(filename, "& ");
    break;

  case mult:
    fprintf(filename, "* ");
    break;

  case divd:
    fprintf(filename, "/ ");
    break;

  case plus:
  case uplus:
    fprintf(filename, "+ ");
    break;

  case minus:
  case uminus:
    fprintf(filename, "- ");
    break;

  case concat:
    fprintf(filename, "|| ");
    break;

  case lt:
    fprintf(filename, "< ");
    break;

  case le:
    fprintf(filename, "<= ");
    break;

  case gt:
    fprintf(filename, "> ");
    break;

  case ge:
    fprintf(filename, ">= ");
    break;

  case equal:
    fprintf(filename, "= ");
    break;

  case notequal:
    fprintf(filename, "~= ");
    break;

  case unot:
    fprintf(filename, "~ ");
    break;
  default:
     ;
  }/*case*/
}  /*PrintOperation*/

static void printerror(filename, errorrec)
FILE *filename;
errorrecord *errorrec;
{
   writestring(filename,&infile[0]->parvalue);
  fprintf(filename, ":%d: ERROR - ",errorrec->linenumber);
  switch (errorrec->etype) {

  case fndoubdef:
    fprintf(filename, "Function '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' already defined in this scope.\n");
    break;

  case tnameundef:
    fprintf(filename, "type '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' used but never defined.\n");
    break;

  case vnameundef:
    fprintf(filename, "Value name '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' undefined.\n");
    break;

  case fieldnameddef:
    fprintf(filename, "Field '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' already defined in this scope.\n");
    break;

  case tagnameddef:
    fprintf(filename, "Tag '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' already defined in this scope.\n");
    break;

  case defineerr:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, " already listed in DEFINE statement.\n");
    break;

  case doubledefarg:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' already defined as an argument.\n");
    break;

  case forwardtype:
    fprintf(filename, " Forward header not the same as function ");
    fprintf(filename, "header for function '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename,"\n");
    break;
    
  case innerfndoubdef:
    fprintf(filename, "Function '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' already defined in an outer scope.\n");
    break;

  case expimporterr:
    fprintf(filename, "Function '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' can not be both imported and exported.\n");
    break;

  case forwardnotresolved:
    fprintf(filename, "Forward function '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename,
            "' never had a local function defined for it.\n");
    break;

  case lbarity:
    fprintf(filename,
            "Lower Bound expression has arity greater that one.\n");
    break;

  case lbtype:
    fprintf(filename,
            "Type of lower bound expression must be integer.\n");
    break;

  case notypeabuild:
    fprintf(filename,
            "A type name must be given when creating an empty array.\n");
    break;

  case atypenameerr:
    fprintf(filename, "Type '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename,
      "' does not match the type of the array element given.\n");
    break;

  case notarraytype:
    fprintf(filename,
            "Type name it not an array type in Array Build.\n");
    break;

  case arraytypeclash:
    fprintf(filename,
      "Base type of type name and type of element in  Abuild must be the same.\n");
    break;

  case abuildelemtype:
    fprintf(filename,
            "Type of the array element number %3din array build is incorrect.\n",
            errorrec->UU.elemnum
            );
    break;

  case unarytypeerr:
    fprintf(filename, "Operand of type ");
    printtypesort(filename, errorrec->UU.U31.utypeptr);
    fprintf(filename, "incorrect for operation ");
    printoperation(filename, errorrec->UU.U31.uop);
    fprintf(filename,"\n");
    break;

  case unaryoparity:
    fprintf(filename, "Arity of operand for unary operation ");
    printoperation(filename, errorrec->UU.op);
    fprintf(filename, " is greater than 1.\n");
    break;

  case binaryoparity:
    fprintf(filename, "Arity of operand for binary operation ");
    printoperation(filename, errorrec->UU.op);
    fprintf(filename, " is greater than 1.\n");
    break;
    
  case binarytypesnoteq:
    fprintf(filename, "Operand types not equal for binary operation ");
    printoperation(filename, errorrec->UU.op);
    fprintf(filename, "\n");
    break;

  case binarytypeerr:
    fprintf(filename, "Operand of type ");
    printtypesort(filename, errorrec->UU.U18.btypeptr);
    fprintf(filename, "incorrect for operation ");
    printoperation(filename, errorrec->UU.U18.bop);
    fprintf(filename, "\n");
    break;

  case chararity:
  case doublearity:
  case intarity:
  case realarity:
    fprintf(filename, " Expression argument to prefix operator ");
/* p2c: mono.bin.noblank.p, line 10411: Note:
 * Line breaker spent 0.0+4.30 seconds, 5000 tries on line 12255 [251] */
    fprintf(filename, "%s must be of arity one.\n",
            errortypes_NAMES[(long)errorrec->etype]);
    break;

  case charitype:
    fprintf(filename, "Argument type to prefix operator Character");
    fprintf(filename, " must be integer, not ");
    printtypesort(filename, errorrec->UU.typeptr);
    fprintf(filename, ".\n");
    break;

  case doubleitype:
    fprintf(filename, "Argument type to prefix operator Double_Real");
    fprintf(filename, " must be integer or real, not ");
    printtypesort(filename, errorrec->UU.typeptr);
    fprintf(filename, ".\n");
    break;

  case intitype:
    fprintf(filename, "Argument type to prefix operator Integer ");
    fprintf(filename, " must be real, double, or character, not ");
    printtypesort(filename, errorrec->UU.typeptr);
    fprintf(filename, ".\n");
    break;

  case realitype:
    fprintf(filename, "Argument type to prefix operator Real");
    fprintf(filename, " must be integer, or double, not ");
    printtypesort(filename, errorrec->UU.typeptr);
    fprintf(filename, ".\n");
    break;

  case typefunctarg:
    fprintf(filename, "Type of argument number %3d incorrect in function ",
            errorrec->UU.U29.argnum);
    writestring(filename, &errorrec->UU.U29.functionname);
    fprintf(filename, "\n");
    break;

  case numfunctarg:
    if (errorrec->UU.U29.argnum < 0)   /*Not enough arguments*/
      fprintf(filename, "Not enough argument for function ");
    else
      fprintf(filename, "Too many arguments for function ");
    writestring(filename, &errorrec->UU.U29.functionname);
    fprintf(filename, "\n");
    break;

  case undeffunct:
    fprintf(filename, "Function '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' is undefined.\n");
    break;

  case typefunctres:
    fprintf(filename, "Type of result number %3d incorrect in function ",
            errorrec->UU.U19.resnum);
    writestring(filename, &errorrec->UU.U19.functname);
    fprintf(filename, "\n");
    break;

  case numfunctres:
    if (errorrec->UU.U19.resnum < 0)   /*Not enough results*/
      fprintf(filename, "Not enough result expressions for function ");
    else
      fprintf(filename, "Too many result expressions for function ");
    writestring(filename, &errorrec->UU.U19.functname);
    fprintf(filename, "\n");
    break;

  case asstypeclash:
    fprintf(filename, "Type clash on assignment. expression type ");
    printtypesort(filename, errorrec->UU.U21.exptype);
    fprintf(filename, " name type ");
    printtypesort(filename, errorrec->UU.U21.nametype);
    fprintf(filename, "\n");
    break;

  case vardoubledef:
    fprintf(filename, "Value name already defined in this block, '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "'\n");
    break;

  case longexplist:
    fprintf(filename, " Expression list longer than name list ");
    fprintf(filename, "\n");
    break;

  case longnamelist:
    fprintf(filename, " Name list longer than expression list");
    fprintf(filename, "\n");
    break;

  case vardoubledecl:
    writestring(filename, &errorrec->UU.U25.varname);
    fprintf(filename, " declared twice,  type ");
    printtypesort(filename, errorrec->UU.U25.exp1type);
    fprintf(filename, " and type ");
    printtypesort(filename, errorrec->UU.U25.exp2type);
    fprintf(filename, "\n");
    break;

  case vnamenotloopvar:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' not a loop name, can't be used with old operator.");
    fprintf(filename, "\n");
    break;

  case arityonerror:
    fprintf(filename, "input to IS ERROR must be of arity one ");
    fprintf(filename, "\n");
    break;

  case arityonisu:
    fprintf(filename, "Arity on Is Union must be one. ");
    fprintf(filename, "\n");
    break;

  case isutype:
    fprintf(filename, "Argument to Is Union must be of type union not ");
    printtypesort(filename, errorrec->UU.typeptr);
    fprintf(filename, "\n");
    break;

  case arityonrbuild:
    fprintf(filename, "Expression in field of record build must be");
    fprintf(filename, " of arity one.");
    fprintf(filename, "\n");
    break;

  case typeonrbuild:
    fprintf(filename, "Type name must match record being built");
    fprintf(filename, "\n");
    break;

  case arityonubuild:
    fprintf(filename, "Expression must be of arity one on union create");
    fprintf(filename, "\n");
    break;

  case tnonubuild:
    fprintf(filename, "Type name on union create must be a union type");
    fprintf(filename, ". Name was '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "'\n");
    break;

  case undeftagub:
    fprintf(filename, "Tag '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' not defined in this union");
    fprintf(filename, "\n");
    break;

  case typeclashub:
    fprintf(filename, "Type of expression does not match tag type");
    fprintf(filename, "\n");
    break;

  case arityonrselect:
    fprintf(filename, "Expression on record select must be arity one.");
    fprintf(filename, "\n");
    break;

  case etypeonrs:
    fprintf(filename, "Expression type on record select must be record");
    fprintf(filename, "\n");
    break;

  case nameundrs:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' not a field in this record. ");
    fprintf(filename, "\n");
    break;

  case ntypeonrs:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' not of type record. ");
    fprintf(filename, "\n");
    break;

  case arityonrexp:
    fprintf(filename, "Replacement expression must be of arity one in ");
    fprintf(filename, "record replace");
    fprintf(filename, "\n");
    break;

  case arityonoexp:
    fprintf(filename, "Expression preceeding record replace must");
    fprintf(filename, "of arity one ");
    fprintf(filename, "\n");
    break;

  case ntyperr:
    fprintf(filename, "Expression and fields must be of type record");
    fprintf(filename, " in a record replace.");
    fprintf(filename, "\n");
    break;

  case nameundrr:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' not a field in this record.");
    fprintf(filename, "\n");
    break;

  case typeclashrr:
    fprintf(filename, "Replacement expression not the same type as ");
    fprintf(filename, "field '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "'\n");
    break;

  case ifreturnstypes:
    fprintf(filename,
      "Type of expression number %4d incorrect in arm of IF.\n",
      errorrec->UU.expnum);
    break;

  case tagreturnstypes:
    fprintf(filename,
      "Type of expression number %4d incorrect in arm of TagCase.\n",
      errorrec->UU.expnum);
    break;

  case numifreturns:
    if (errorrec->UU.expnum < 0)
      fprintf(filename,
              "Not enough expressions returned by arm  of IF.\n");
    else
      fprintf(filename,
              "Too many expressions returned by arm  of IF.\n");
    break;

  case numtagreturns:
    if (errorrec->UU.expnum < 0)
      fprintf(filename,
              "Not enough expressions returned by arm  of TagCase.\n");
    else
      fprintf(filename,
              "Too many expressions returned by arm  of TagCase.\n");
    break;

  case prednotbool:
    fprintf(filename,
            "The predicate expression of an IF statement  must be of type boolean.\n");
    break;

  case predarity:
    fprintf(filename,
            "The predicate expression of an IF statement  must have arity 1.\n");
    break;

  case nothingsc:
    fprintf(filename, "A stream create must have a typename or an ");
    fprintf(filename, "expression");
    fprintf(filename, "\n");
    break;

  case typenssc:
    fprintf(filename, "The typename in a stream build must be of ");
    fprintf(filename, "type stream");
    fprintf(filename, "\n");
    break;

  case typeclashsc:
    fprintf(filename, "Expressions in stream build must be the same");
    fprintf(filename, " type as the type name's elements");
    fprintf(filename, "\n");
    break;

  case expsnstypesc:
    fprintf(filename, "All expressions must be the same type, error");
    fprintf(filename, " on exp %6d", errorrec->UU.expnum);
    fprintf(filename, "\n");
    break;

  case undefntag:
    fprintf(filename, " Name '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "'undefined.");
    fprintf(filename, "\n");
    break;

  case arityontag:
    fprintf(filename, "Expression in Tagcase head must be of arity one.");
    fprintf(filename, "\n");
    break;

  case typenutc:
    fprintf(filename, "Expression in Tagcase header must ");
    fprintf(filename, "be of type union.");
    fprintf(filename, "\n");
    break;

  case nameundeftc:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' not a tag of this union.");
    fprintf(filename, "\n");
    break;

  case ddtname:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' already associated with an arm in this tagcase");
    fprintf(filename, "\n");
    break;

  case typesnsametc:
    fprintf(filename, "Types of fields in tag list must be of the same");
    fprintf(filename, " type. ");
    fprintf(filename, "\n");
    break;

  case othernone:
    fprintf(filename, "All tags have been specified, otherwise");
    fprintf(filename, " clause not allowed.");
    fprintf(filename, "\n");
    break;

  case notalltc:
    fprintf(filename, "All tags must be specified in a tagcase,'");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' not specified.");
    fprintf(filename, "\n");
    break;

  case arrayarity:
    fprintf(filename,
            "Arity of expression for array indexing must be 1.\n");
    break;

  case needarraytype:
    fprintf(filename,
            "Type of expression for array indexing must be an array.\n");
    break;

  case indexexperr:
    fprintf(filename,
            "Type of expression for array indexing must be integer.\n");
    break;

  case arityareplace:
    fprintf(filename,
            "Array Expression for an AReplace must have an arity of 1.\n");
    break;

  case typeareplace:
    fprintf(filename,
            "Expression for an AREplace must be of type array.\n");
    break;

  case replaceoverdim:
    fprintf(filename,
            "Too many dimensions specified in AReplace for the size of the input array.\n");
    break;

  case replaceelemtype:
     fprintf(filename, "Replace element not the correct type.\n");
    break;

  case valueofarity:
    fprintf(filename,
            "Arity of expression in Value Of must be 1.\n");
    break;

  case streamofarity:
    fprintf(filename,
            "Arity of expression in Stream Of must be 1.\n");
    break;

  case arrayofarity:
    fprintf(filename,
            "Arity of expression in Array Of must be 1.\n");
    break;

  case maskingarity:
     fprintf(filename, "Arity of masking expression must be 1.\n");
    break;

  case masknotbool:
    fprintf(filename,
            "Type of masking expression must be boolean.\n");
    break;

  case arityonfa:
    fprintf(filename, "Forall header must be one array/stream expression");
    fprintf(filename, " or two integer expressions.");
    fprintf(filename, "\n");
    break;

  case typeonfa:
    fprintf(filename, "Type of expression in forall header must be");
    fprintf(filename, " integer, array, or stream");
    fprintf(filename, "\n");
    break;

  case atinrg:
    fprintf(filename, "At index list only allowed with array/stream");
    fprintf(filename, " forall expressions.");
    fprintf(filename, "\n");
    break;

  case reducetype:
    fprintf(filename, "Type ");
    printtypesort(filename, errorrec->UU.U91.redtype);
    fprintf(filename, " not legal input type to ");
    switch (errorrec->UU.U91.redflag) {

    case rfsum:
      fprintf(filename, "Sum ");
      break;

    case rfproduct:
      fprintf(filename, "Product ");
      break;

    case rfleast:
      fprintf(filename, "Least ");
      break;

    case rfgreatest:
      fprintf(filename, "Greatest ");
      break;

    case rfcatenate:
      fprintf(filename, "Catenate ");
      break;
    default:
       ;
    }/*case*/
    fprintf(filename, " reduction.\n");
    break;

  case icnotas:
    fprintf(filename, "Index names may only be used on stream or array");
    fprintf(filename, " types not ");
    printtypesort(filename, errorrec->UU.typeptr);
    fprintf(filename, " in a for.");
    fprintf(filename, "\n");
    break;

  case cdmix:
    fprintf(filename, "Cross and Dot may not be mixed in a for loop.");
    fprintf(filename, "\n");
    break;

  case decbutnotdef:
    fprintf(filename, "Definition must precede use of value name '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "'\n");
    break;

  case lvarnotdef:
    fprintf(filename, "Definition must precede use of loop name :'");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "'\n");
    break;

  case testarity:
     fprintf(filename, "Arity of test expression must be 1.\n");
    break;

  case testnotbool:
     fprintf(filename, "Type of test expression must be boolean.\n");
    break;

  case lvarusebredef:
    fprintf(filename, "Loop variables must be redefined before use: '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "'\n");
    break;

  case loopcvmix:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' is a loop constant, ");
    fprintf(filename, "can not be used with old.");
    fprintf(filename, "\n");
    break;

  case loopconsassn:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "'already used as a loop constant, can not be");
    fprintf(filename, " used on the left hand side on assignment.");
    fprintf(filename, "\n");
    break;

  case redefimlvar:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' is an imported loop name and can not");
    fprintf(filename, " be assigned to in this loop.");
    fprintf(filename, "\n");
    break;

  case lvarneverredef:
    putc('\'', filename);
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' used as a loop name but never redefined");
    fprintf(filename, "\n");
    break;

  case deflistnotempty:
    fprintf(filename, "Function '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' is listed in Define Stmt, but never defined.");
    fprintf(filename, "\n");
    break;

  case typedoubdef:
    fprintf(filename, "Type name '");
    writestring(filename, &errorrec->UU.errorstr);
    fprintf(filename, "' already defined.\n");
    break;
  }/* case */
}  /* semerror */


/*------------------- ERROR ROUTINES -------------------------*/
static void semerror(errorrec)
errorrecord *errorrec;
{  /*semerr*/
  semerrcnt++;
  printerror(stdout, errorrec);
  if (listing)
    printerror(listfile, errorrec);
  freeerrorptr(&errorrec);
}


/*------------------- GRAPH ROUTINES -----------------------*/
node *findparent(level)
treestackobj *level;
{
  node *Result;

  switch (level->lleveltag) {

  case forloop:
  case specfa:
  case initloop:
  case tagcase:
  case nestedifcomp:
  case ifcomp:
    Result = level->currentsubn0;
    break;

  case funct:
    Result = level->UU.lfunctname->graphinfo->node_;
    break;
  default:
     ;
  }/*case*/
  return Result;
}


static void linkparent(nd, level)
node *nd;
treestackobj *level;
{
  while (level->lleveltag == let)
    level = level->lastlevel;
  level->prevnode->ndnext = nd;
  level->prevnode = nd;
  nd->ndparent = findparent(level);
}  /*LinkParent*/


/*------------------- SEMANTIC STACK -------------------*/
static void pushsemantic(stackitem)
semanticrec *stackitem;
{
  stackitem->next = topsemstk;
  topsemstk = stackitem;
}


semanticrec *popsemantic()
{
  semanticrec *Result;

  Result = topsemstk;
  if (topsemstk != NULL)
    topsemstk = topsemstk->next;
  else
    printf("INTERNAL ERROR -- semantic stack underflow\n");
  return Result;
}


/*--------------- LIST ROUTINES ---------------------------*/
static void linkname(name, line, col, list)
stryng name;
int line, col;
namelistrec **list;
{
  namelistrec *listptr;

  if (*list == NULL) {
    newnamelist(list);
    (*list)->name = name;
    (*list)->linenum = linenumber;
    return;
  }
  listptr = *list;
  while (listptr->next != NULL)
    listptr = listptr->next;
  newnamelist(&listptr->next);
  listptr->next->name = name;
  listptr->next->column = col;
  listptr->next->linenum = line;
  listptr->next->prev = listptr;
}  /* linkname */


tornrec *linktorntype(elem, list)
tornrec *elem, *list;
{
  if (list != NULL)
    list->prev = elem->next;
  elem->next = list;
  elem->prev = NULL;
  return elem;
}


static void linktype(typeptr, list)
stentry *typeptr;
typelistrec **list;
{
  typelistrec *listptr;

  if (*list == NULL) {
    newtypelist(list);
    (*list)->typeptr = typeptr;
    return;
  }
  listptr = *list;
  while (listptr->next != NULL)
    listptr = listptr->next;
  newtypelist(&listptr->next);
  listptr->next->typeptr = typeptr;
  listptr->next->prev = listptr;
}  /* linktype */


static void addtonamelist(inputtoken, line, col)
stryng inputtoken;
int line, col;
{
  /*action 3*/
  /*stackpops - tgnamelist
                  pushes - tgnamelist*/
  /*description
          Pop a name list from the semstack and add the inputtoken stryng
          to the list and push it again*/
  semanticrec *semrec;

  if (semtrace) {
    printf("begin AddToNameList, name is ");
    writestring(stdout, &inputtoken);
    putchar('\n');
  }
  semrec = popsemantic();
  stringlowercase(&inputtoken);
  linkname(inputtoken, line, col, &semrec->UU.namelist);
  pushsemantic(semrec);
}  /* addtonamelist */


static void startnamelist()
{
  /*action 2*/
  /*stackpops - nothing
                  pushes - tgnamelist (empty)*/
  /*description
          Obtain a namelist record and initialize it to empty.  Push it
          on the semantic stack.*/
  semanticrec *semrec;

  if (semtrace)
    printf("begin StartNameList \n");
  newsemantic(&semrec, tgnamelist);
  pushsemantic(semrec);
}  /* startnamelist */


static void addtoexplist(list, exp)
explistnode **list, *exp;
{
  /* Add the graph info pointed to by exp to the end of the list pointed
     to by list.*/
  explistnode *listptr;

  listptr = *list;
  if (listptr == NULL) {
    *list = exp;
    return;
  }
  while (listptr->next != NULL)
    listptr = listptr->next;
  listptr->next = exp;

  /*else*/
}  /*AddToExpList*/


static void pushemptyexplist()
{
  /*action 107 PushEmptyExpList*/
  /*stackpops - nothing
                  pushes - tgexplist*/
  /*description
          Save an empty explist on the stack*/
  semanticrec *semexplist;

  if (semtrace)
    printf("begin PushEmptyExpList \n");
  newsemantic(&semexplist, tgexplist);
  pushsemantic(semexplist);
}


inforecord *getalit1()
{
  inforecord *info;

  info = newinfoptr();
  info->typeptr = getbasictype(ifbinteger);
  string10(&info->litvalue, "1         ");
  return info;
}


int assignports(list, portnum)
edgelisthead *list;
int portnum;
{
  edgelist *edgelist_, *tempedge;
  edgelisthead *headlist, *temphead;
  int port_;

  headlist = list;
  port_ = portnum;
  while (headlist != NULL) {
    edgelist_ = headlist->edges;
    while (edgelist_ != NULL) {
      if (edgelist_->toorfrom == toport)
        edgelist_->edge->pttoport = port_;
      else if (edgelist_->toorfrom == fromport)
        edgelist_->edge->UU.U1.ptfrport = port_;
      else {
        printf("COMPILER ERROR PORT FLAG = NoPort, name = ");
        writestring(stdout, &headlist->edgename);
        putchar('\n');
      }
      tempedge = edgelist_;
      edgelist_ = edgelist_->next;
      freeedgelistptr(&tempedge);
    }  /*while*/
    port_++;
    temphead = headlist;
    headlist = headlist->next;
    freeheadptr(&temphead);
  }  /*while*/
  return port_;
}

/**************************************************************************/
/* FILE   **************          file1.c          ************************/
/**************************************************************************/
/* Author: Skedz?                                                         */
/* Update: Dave Cann                                                      */
/* Update: Pat Miller -- ANSI compliance                                  */
/* Copyright (C) University of California Regents                         */
/**************************************************************************/


static node *buildcompound_(leveltype)
lexleveltype leveltype;
{
  node *compnd;

  compnd = newnodeptr(ndcompound, currentlevel);
  linkparent(compnd, currentlevel);
  createlevel(leveltype);
  currentlevel->prevnode = compnd;
  compnd->ndsrcline = linenumber;
  switch (leveltype) {

  case nestedifcomp:
  case ifcomp:
    currentlevel->UU.U8.ifnode = compnd;
    compnd->ndcode = ifnifthenelse;
    break;

  case tagcase:
    currentlevel->UU.U4.tagcasenode = compnd;
    compnd->ndcode = ifntagcase;
    break;

  case forloop:
  case specfa:
    currentlevel->UU.U0.forallnode = compnd;
    compnd->ndcode = ifnforall;
    break;

  case initloop:
    currentlevel->UU.U5.initnode = compnd;
    compnd->ndcode = -1;
    break;

  default:
     ;
  }/*case*/
  return compnd;
}


static void addgrptr(gr, comp)
graph *gr;
node *comp;
{
  graph *curgrptr;

  curgrptr = comp->UU.U2.ndsubsid;
  if (curgrptr == NULL) {
    comp->UU.U2.ndsubsid = gr;
    return;
  }
  while (curgrptr->grnext != NULL)
    curgrptr = curgrptr->grnext;
  curgrptr->grnext = gr;

  /*else*/
}  /*AddGRptr*/


static node *buildsubgraph(comp)
node *comp;
{
  node *subgr;
  graph *gr;

  currentlevel->nodecounter = 0;
  subgr = newnodeptr(ndgraph, currentlevel);
  gr = newgraphptr();
  gr->grnode = subgr;
  addgrptr(gr, comp);
  subgr->ndcode = ifngraph;
  subgr->ndparent = comp;
  subgr->ndsrcline = linenumber;
  currentlevel->prevnode = subgr;
  currentlevel->currentsubn0 = subgr;
  return subgr;
}


comparetype stringcompare(str1, str2, mpt)
stryng *str1;
stryng *str2;
int     mpt;
{
  /*  The strutil routines have not been called here because this procedure
      will eventually end up in strutl.m4.*/
  comparetype Result;
  int stop, index1, index2;
  Char ch1, ch2;

  index1 = 1;
  index2 = 1;
  if (str1->len < str2->len)
    stop = str2->len + 1;
  else
    stop = str1->len + 1;
  while (index1 < stop) {
    ch1 = str1->str[index1 - 1];
    if (mpt) {
      if (isupper(ch1))
        ch1 = z_tolower(ch1);
    }
    ch2 = str2->str[index2 - 1];
    if (mpt) {
      if (isupper(ch2))
        ch2 = z_tolower(ch2);
    }
    if (ch1 < ch2) {
      Result = compareless;
      goto _L999;
    }
    if (ch1 > ch2) {
      Result = comparegreater;
      goto _L999;
    }
    index1++;
    index2++;
  }
  /* if we reach here, strings look equal;  check lengths */
  if (str1->len == str2->len)
    Result = compareequal;
  else if (str1->len < str2->len)
    Result = compareless;
  else
    Result = comparegreater;
_L999:
  return Result;
}  /*stringcompare*/


static void insertat(place)
int place;
{
  int i, temp;

  temp = idsorted[place - 1];
  idsorted[place - 1] = idsorted[idxrefmax - 1];
  for (i = idxrefmax; i >= place + 2; i--)
    idsorted[i - 1] = idsorted[i - 2];
  idsorted[place] = temp;
}

static void addtolist_(low, high)
int low, high;
{
  if (high == 0)
    return;
  if (high - low == 1 || high == 1) {
    if (stringcompare(&(idunsorted[idsorted[idxrefmax - 1] - 1].name),
                      &(idunsorted[idsorted[high - 1] - 1].name),
                      true) == comparegreater) {
      insertat(high + 1);
      return;
    }
    if (stringcompare(&(idunsorted[idsorted[idxrefmax - 1] - 1].name),
                      &(idunsorted[idsorted[low - 1] - 1].name),
                      true) == compareless)
      insertat(low);
    else
      insertat(high);
    return;
  }
  if (stringcompare(&(idunsorted[idsorted[idxrefmax - 1] - 1].name),
                    &(idunsorted[idsorted[(high + low) / 2 - 1] - 1].name),
                    true) == comparegreater) {
    addtolist_((high + low) / 2, high);
    return;
  }
  if (stringcompare(&(idunsorted[idsorted[idxrefmax - 1] - 1].name),
                    &(idunsorted[idsorted[(high + low) / 2 - 1] - 1].name),
                    true) == compareless)
    addtolist_(low, (high + low) / 2);
  else
    insertat((high + low) / 2);
}


static void addtoxref(buck)
symtblbucket *buck;
{
  /*AddBuck to the sorted XRef array.*/
  idxrefmax++;
  idunsorted[idxrefmax - 1].name = buck->name;
  idunsorted[idxrefmax - 1].refs = buck->references->front;
  idunsorted[idxrefmax - 1].defs = buck->defloc;
  idunsorted[idxrefmax - 1].typeptr = buck->typeptr;
  idsorted[idxrefmax - 1] = idxrefmax;
  addtolist_(1, idxrefmax - 1);
}


static void printxref()
{
  int i;
  xrefrec xrefbuck;
  reflist *reflist_;
  int FORLIM;

  FORLIM = idxrefmax;
  for (i = 0; i < FORLIM; i++) {
    xrefbuck = idunsorted[idsorted[i] - 1];
    writestring(listfile, &xrefbuck.name);
    fprintf(listfile, " : ");
    if (xrefbuck.typeptr->stliteral.len != 0)
      writestring(listfile, &xrefbuck.typeptr->stliteral);
    else
      outtype(listfile, xrefbuck.typeptr, true);
    putc('\n', listfile);
    if (xrefbuck.defs->fline != -1) {
      fprintf(listfile, "  *%d", xrefbuck.defs->fline);
      if (xrefbuck.defs->sline != -1)
        fprintf(listfile, "  *%d", xrefbuck.defs->sline);
    }
    reflist_ = xrefbuck.refs;
    while (reflist_ != NULL) {
      fprintf(listfile, "  %d", reflist_->line);
      reflist_ = reflist_->nextref;
    }
    fprintf(listfile, "\n\n");
  }
}


static void endlevel()
{
  /*If XRef, add the entrys in the symbol table to the sorted Xref array.
          If XRef and we are ending a function, print the XRef and then clear
          the array.*/
  treestackobj *dumpt;
  symtblbucket *tbucket, *dump;
  int i;

  for (i = 0; i <= maxhashtable; i++) {
    tbucket = currentlevel->hashtable[i];
    while (tbucket != NULL) {
      if (xref && !tbucket->importedflag)
        addtoxref(tbucket);
      dump = tbucket;
      tbucket = tbucket->nextbucket;
      freesymptr(dump);
    }  /* while */
  }  /* for */
  if (currentlevel->lleveltag == funct && xref) {
    fprintf(listfile,
      "\n------------------------------------------------------------------------- \n");
    fprintf(listfile, "Cross Reference for Function  ");
    writestring(listfile, &currentlevel->UU.lfunctname->name);
    fprintf(listfile, "\n\n");
    printxref();
    idxrefmax = 0;
    fprintf(listfile,
      "------------------------------------------------------------------------- \n\n");
  }
  dumpt = currentlevel;
  currentlevel = currentlevel->lastlevel;
  currentlevel->nextlevel = NULL;
  freetreestack(dumpt);
}  /* EndLevel */


static void endcompound()
{
  /*stackpops - nothing
                  pushes - tgexplist*/
  explistnode *explist;
  semanticrec *semexplist;
  typelistrec *typelist;
  int portnum;
  node *compnode;

  newsemantic(&semexplist, tgexplist);
  portnum = 1;
  switch (currentlevel->lleveltag) {

  case tagcase:
  case nestedifcomp:
  case ifcomp:
    if (currentlevel->lleveltag == ifcomp ||
        currentlevel->lleveltag == nestedifcomp) {
      typelist = currentlevel->UU.U4.tarmreturnstype;
      compnode = currentlevel->UU.U8.ifnode;
    } else {
      typelist = currentlevel->UU.U8.iarmreturnstype;
      compnode = currentlevel->UU.U4.tagcasenode;
    }  /*else*/
    semexplist->UU.explist = newexplistptr();
    explist = semexplist->UU.explist;
    explist->graphinfo->port_ = portnum;
    portnum++;
    explist->graphinfo->node_ = compnode;
    explist->graphinfo->typeptr = typelist->typeptr;
    typelist = typelist->next;
    while (typelist != NULL) {
      explist->next = newexplistptr();
      explist = explist->next;
      explist->graphinfo->port_ = portnum;
      portnum++;
      explist->graphinfo->node_ = compnode;
      explist->graphinfo->typeptr = typelist->typeptr;
      typelist = typelist->next;
    }  /*while*/
    break;
    /*IfComp, NestedIfComp,  TagCase*/
  default:
     ;
  }/*case*/
  endlevel();
  pushsemantic(semexplist);
}  /*EndCompound*/


static void addtoassolist(node_, asso)
node *node_;
int asso;
{
  assoclist *newa, *assoclist_;
  PSBLOCK b;

  /* newa = (assoclist *)Malloc(sizeof(assoclist)); */
  b = MySBlockAlloc(); /* CANN */
  newa = &(b->al); /* CANN */

  newa->graphnum = asso;
  newa->next = NULL;
  assoclist_ = node_->UU.U2.ndassoc;
  if (assoclist_ == NULL) {
    node_->UU.U2.ndassoc = newa;
    return;
  }
  while (assoclist_->next != NULL)
    assoclist_ = assoclist_->next;
  assoclist_->next = newa;

  /* else */
}  /* AddToAssoList */


port *orderolist(list)
port *list;
{
  int num, j, pass;
  boolean interch;
  port *lead, *middle, *trail;
  int FORLIM;

  num = 0;
  lead = list;
  while (lead != NULL) {
    num++;
    lead = lead->UU.U1.ptfrnext;
  }
  interch = true;
  pass = 1;
  while (pass < num && interch) {
    interch = false;
    middle = list;
    lead = middle->UU.U1.ptfrnext;
    trail = NULL;
    FORLIM = num - pass;
    for (j = 1; j <= FORLIM; j++) {
      if (middle->UU.U1.ptfrport > lead->UU.U1.ptfrport) {
        interch = true;
        middle->UU.U1.ptfrnext = lead->UU.U1.ptfrnext;
        lead->UU.U1.ptfrnext = middle;
        if (trail == NULL) {
          list = lead;
          trail = list;
        } else {
          trail->UU.U1.ptfrnext = lead;
          trail = lead;
        }
        lead = middle->UU.U1.ptfrnext;
      } else {
        trail = middle;
        middle = lead;
        lead = lead->UU.U1.ptfrnext;
      }
    }
    pass++;
  }
  return list;
}


port *orderilist(list)
port *list;
{
  int num, j, pass;
  boolean interch;
  port *lead, *middle, *trail;
  int FORLIM;

  num = 0;
  lead = list;
  while (lead != NULL) {
    num++;
    lead = lead->pttonext;
  }
  interch = true;
  pass = 1;
  while (pass < num && interch) {
    interch = false;
    middle = list;
    lead = middle->pttonext;
    trail = NULL;
    FORLIM = num - pass;
    for (j = 1; j <= FORLIM; j++) {
      if (middle->pttoport > lead->pttoport) {
        interch = true;
        middle->pttonext = lead->pttonext;
        lead->pttonext = middle;
        if (trail == NULL) {
          list = lead;
          trail = list;
        } else {
          trail->pttonext = lead;
          trail = lead;
        }
        lead = middle->pttonext;
      } else {
        trail = middle;
        middle = lead;
        lead = lead->pttonext;
      }
    }
    pass++;
  }
  return list;
}


boolean openlistfile(listfilename, listfile)
stryng listfilename;
FILE **listfile;
{
  stryng dev, name, ext;

  splitname(&listfilename, &dev, &name, &ext);
  defaultext(&listfilename, &name, "lst       ");
  if (canwrite(&listfilename))
    return (openwrite(listfile, &listfilename));
  else {
    printf("\n*****Could not open listing file:  ");
    writestring(stdout, &listfilename);
    printf(" *****\n");
    return false;
  }
}

Static void createlevel(curlex)
lexleveltype curlex;
{
  /* Create a new Lex Level of type CurLex and add it to the LL stack.*/
  treestackobj *newelement;
  int i;

  newelement = (treestackobj *)Malloc(sizeof(treestackobj));
  newelement->lleveltag = curlex;
  for (i = 0; i <= maxhashtable; i++)
    newelement->hashtable[i] = NULL;
  newelement->prevnode = NULL;
  newelement->currentsubn0 = NULL;
  newelement->nodecounter = 0;
  newelement->lastlevel = currentlevel;
  newelement->nextlevel = NULL;
  switch (curlex) {   /* with */

  case forloop:
  case specfa:
    newelement->UU.U0.kflist = NULL;
    newelement->UU.U0.mflist = NULL;
    newelement->UU.U0.tflist = NULL;
    newelement->UU.U0.forallnode = NULL;
    newelement->UU.U0.lowerbound = NULL;
    newelement->UU.U0.crossdotflag = 0;
    newelement->UU.U0.crossdoterror = false;
    newelement->UU.U0.freturnportnum = 0;
    newelement->UU.U0.returnn0 = NULL;
    newelement->UU.U0.bodyn0 = NULL;
    newelement->UU.U0.returnnodecount = 1;
    newelement->UU.U0.bodynodecount = 1;
    newelement->UU.U0.bodyoutputportnum = 0;
    newelement->UU.U0.bodyprevnode = NULL;
    newelement->UU.U0.returnprevnode = NULL;
    break;

  case initloop:
    newelement->UU.U5.kilist = NULL;
    newelement->UU.U5.lilist = NULL;
    newelement->UU.U5.tilist = NULL;
    newelement->UU.U5.initnode = NULL;
    newelement->UU.U5.ireturnportnum = 0;
    break;

  case tagcase:
    newelement->UU.U4.ktport = 1;
    newelement->UU.U4.tagcasenode = NULL;
    newelement->UU.U4.tarmreturnstype = NULL;
    break;

  case ifcomp:
  case nestedifcomp:
    newelement->UU.U8.kiport = 1;
    newelement->UU.U8.ifnode = NULL;
    newelement->UU.U8.iarmreturnstype = NULL;
    break;

  case funct:
    newelement->UU.lfunctname = NULL;
    break;

  case let:
  case root:
    /* blank case */
    break;
  }/* case */
  if (currentlevel != NULL)
    currentlevel->nextlevel = newelement;
  currentlevel = newelement;
}

symtblbucket *createbucket(bucktype)
identtype bucktype;
{
  /*Create a symbol table entry of type BuckType and returns its pointer.  */
  symtblbucket *newbuck;
  PBBLOCK b;
  PSBLOCK sb;

  /* newbuck = (symtblbucket *)Malloc(sizeof(symtblbucket)); */
  b = MyBBlockAlloc(); /* CANN */
  newbuck = &(b->sb); /* CANN */

  /* newbuck->graphinfo = (inforecord *)Malloc(sizeof(inforecord)); */
  b = MyBBlockAlloc(); /* CANN */
  newbuck->graphinfo = &(b->ir); /* CANN */

  /* newbuck->defloc = (defrec *)Malloc(sizeof(defrec)); */
  sb = MySBlockAlloc(); /* CANN */
  newbuck->defloc = &(sb->dr); /* CANN */

  mymemcpy(newbuck->name.str, blankstring, sizeof(stryngar));
  newbuck->name.len = 0;
  mymemcpy(newbuck->graphinfo->name.str, blankstring, sizeof(stryngar));
  newbuck->graphinfo->name.len = 0;
  newbuck->identtag = bucktype;
  newbuck->defloc->fline = -1;
  newbuck->defloc->fcolumn = -1;
  newbuck->defloc->sline = -1;
  newbuck->defloc->scolumn = -1;
  newbuck->references = newreferencesptr();
  newbuck->typeptr = NULL;
  newbuck->graphinfo->node_ = NULL;
  newbuck->graphinfo->port_ = -1;
  newbuck->graphinfo->typeptr = NULL;
  newbuck->graphinfo->onlist = NULL;
  newbuck->importedflag = false;
  switch (bucktype) {

  case ttype:
    newbuck->UU.undeftypeptrs = NULL;
    break;

  case tvariable:
    newbuck->UU.U4.loopflag = (loopvarflags *)Malloc(sizeof(loopvarflags));
    *newbuck->UU.U4.loopflag = lnone;
    newbuck->UU.U4.tflag = false;

    /* newbuck->UU.U4.oldfrom = (inforecord *)Malloc(sizeof(inforecord)); */
    b = MyBBlockAlloc(); /* CANN */
    newbuck->UU.U4.oldfrom = &(b->ir); /* CANN */

    newbuck->UU.U4.oldfrom->node_ = NULL;
    newbuck->UU.U4.oldfrom->port_ = -1;
    newbuck->UU.U4.oldfrom->typeptr = NULL;
    newbuck->UU.U4.oldfrom->onlist = NULL;
    newbuck->UU.U4.redefflag = false;
    break;

  case tglobal:
  case tforward:
  case tfunction:
  case tparam:
    /* blank case */
    break;

  case tpredefined:
    newbuck->UU.predefined = nopredef;
    break;
  default:
     ;
  }/* case */
  newbuck->nextbucket = NULL;   /* with */
  return newbuck;
}


static void setname(inbucket, ident)
symtblbucket *inbucket;
stryng ident;
{
  inbucket->name = ident;
  inbucket->graphinfo->name = ident;
}


static void setdefloc(inbucket, line, column)
symtblbucket *inbucket;
int line, column;
{
  if (inbucket->defloc->fline < 0) {
    inbucket->defloc->fline = line;
    inbucket->defloc->fcolumn = column;
  } else {
    inbucket->defloc->sline = line;
    inbucket->defloc->scolumn = column;
  }
}


static void addref(inbucket, line, column)
symtblbucket *inbucket;
int line, column;
{
  reflist *ref;
  PSBLOCK b;

  /* ref = (reflist *)Malloc(sizeof(reflist)); */
  b = MySBlockAlloc(); /* CANN */
  ref = &(b->rl); /* CANN */

  ref->line = line;
  ref->column = column;
  ref->nextref = NULL;
  if (inbucket->references->front == NULL)
    inbucket->references->front = ref;
  else
    inbucket->references->back->nextref = ref;
  inbucket->references->back = ref;
}


static void setlowerbound(level, lower)
treestackobj *level;
inforecord *lower;
{
  /*Set the lower bound info in the lex level passed in.*/
  if (level->UU.U0.lowerbound == NULL)
    level->UU.U0.lowerbound = newinfoptr();
  level->UU.U0.lowerbound->node_ = lower->node_;
  level->UU.U0.lowerbound->port_ = lower->port_;
  level->UU.U0.lowerbound->typeptr = lower->typeptr;
  level->UU.U0.lowerbound->name = lower->name;
  level->UU.U0.lowerbound->litvalue = lower->litvalue;
  level->UU.U0.lowerbound->onlist = lower->onlist;
}


/*macro procedure SetTypePtr(InBucket : SymTblPtr; TypeTb : STPtr); */
/*macro procedure SetLoopFlag(InBucket : SymTblPtr; Flag : LoopVarFlag); */
/*macro procedure SetFromOld(InBucket : SymTblPtr; FromInfo : InfoPtr)*/
/*macro procedure SetLFunctName(Name : SymTblPtr); */
/*macro procedure SetPrevNode(Node : NDPtr); */
/*macro procedure SetCurrentSubN0(Node : NDPtr); */
/*macro procedure SetNodeGraphInfo(InBucket : SymTblPtr; From : NDPtr)*/
/*macro procedure SetNodeOldFrom(InBucket : SymTblPtr; From : NDPtr)*/
/*macro procedure SetPortGraphInfo(InBucket : SymTblPtr; Port : integer) */
/*macro procedure SetPortOldFrom(InBucket : SymTblPtr; Port : integer) */
/*macro procedure SetTypePtrGraphInfo(InBucket : SymTblPtr; FType : TypeTPtr) */
/*macro procedure SetNameGraphInfo(InBucket : SymTblPtr; Name : stryng)*/
/*macro procedure SetOnListOldFrom(InBucket : SymTblPtr; List : EdgeHeadPtr) */
/*macro procedure SetOnListGraphInfo(InBucket : SymTblPtr; List : EdgeHeadPtr) */
/*macro function GetLowerBound(Level : TreeStackPtr): InfoPtr; */
/*macro function GetIdentTag(InBucket : SymTblPtr): IdentType; */
/*macro function GetName(InBucket : SymTblPtr) : Stryng); */
int getdefline(inbucket, time)
symtblbucket *inbucket;
int time;
{
  if (time == 1)
    return (inbucket->defloc->fline);
  else
    return (inbucket->defloc->sline);
}


int getdefcolumn(inbucket, time)
symtblbucket *inbucket;
int time;
{
  if (time == 1)
    return (inbucket->defloc->fcolumn);
  else
    return (inbucket->defloc->scolumn);
}


/*macro function GetType(InBucket: SymTblPtr) : STPtr; */
/*macro function GetUndefTypePtrs(InBucket : SymTblPtr) : pttypelistrec; */
loopvarflags getloopflag(inbucket)
symtblbucket *inbucket;
{
  if (inbucket->identtag == tvariable && inbucket->UU.U4.loopflag != NULL)
    return (*inbucket->UU.U4.loopflag);
  else
    return lnone;
}


/*macro function GetOldFrom(InBucket : SymTblPtr ) : InfoPtr; */
/*macro function GetLLevelTag(Level : TreeStackptr) : LexLevelType; */
/*macro function GetPrevNode(Level : TreeStackptr) : NDPtr; */
/*macro function GetCurrentSubN0(Level : TreeStackptr) : NDPtr; */
/*macro function GetLFunctName(Level : TreeStackPtr) : SymTblPtr; */
/*macro function GetNodeGraphInfo(InBucket : SymTblPtr) : NDPtr;*/
/*macro function GetNodeOldFrom(InBucket : SymTblPtr) : NDPtr;*/
/*macro function GetPortGraphInfo(InBucket : SymTblPtr) : integer; */
/*macro function GetTypePtrGraphInfo(InBucket : SymTblPtr) : TypeTPtr;*/
/*macro function GetNameGraphInfo(InBucket : SymTblPtr) : stryng); */
/*macro function GetOnListGraphInfo(InBucket : SymTblPtr) : EdgeHeadPtr; */
int hash(firstch, lastch)
Char firstch, lastch;
{
  return ((firstch + lastch) % hashtablesize);
/* p2c: mono.bin.noblank.p, line 11587:
 * Note: Using % for possibly-negative arguments [317] */
}


static void addtotable(bucket, level)
symtblbucket *bucket;
treestackobj *level;
{
  /*Hash the bucket in the symbol table for Level.*/
  int position;

  stringlowercase(&bucket->name);
  position = hash(stringchar(&bucket->name, 1),
                  stringchar(&bucket->name, bucket->name.len));
  bucket->nextbucket = level->hashtable[position];
  level->hashtable[position] = bucket;
}


symtblbucket *incurrentlevel(ident, itype)
stryng ident;
identtype itype;
{
  /*Search current symbol table for an entry with name = Ident and
          IdentTag = IType.  Return its pointer or nil if not found.*/
  symtblbucket *Result, *chain;
  boolean found;
  int position;

  Result = NULL;
  found = false;
  stringlowercase(&ident);
  position = hash(stringchar(&ident, 1), stringchar(&ident, ident.len));
  chain = currentlevel->hashtable[position];
  while (chain != NULL && !found) {
    if (equalstrings(&chain->name, &ident)) {
      switch (itype) {

      case ttype:
        if (chain->identtag == ttype) {
          found = true;
          Result = chain;
        }  /* if */
        break;

      case tforward:
      case tglobal:
      case tpredefined:
      case tfunction:
        if (chain->identtag == tfunction || chain->identtag == tforward ||
            chain->identtag == tglobal || chain->identtag == tpredefined) {
          found = true;
          Result = chain;
        }  /* if */
        break;

      case tparam:
      case tvariable:
        if (chain->identtag == tvariable || chain->identtag == tparam) {
          found = true;
          Result = chain;
        }  /* if */
        break;
      default:
         ;
      }/* case */
    }
    chain = chain->nextbucket;
  }  /* while */
  return Result;
}


static void findname(ident, itype, level, place)
stryng ident;
identtype itype;
treestackobj **level;
symtblbucket **place;
{
  /*Search all symbol tables back to  a function boundary for an
          entry with name = Ident and IdentTag = IType.*/
  treestackobj *looklevel;
  symtblbucket *chain;
  boolean found;
  int position;

  stringlowercase(&ident);
  looklevel = currentlevel;
  found = false;
  position = hash(stringchar(&ident, 1), stringchar(&ident, ident.len));
  *place = NULL;
  *level = NULL;
  do {
    chain = looklevel->hashtable[position];
    while (chain != NULL && !found) {
      if (equalstrings(&chain->name, &ident)) {
        switch (itype) {

        case ttype:
          if (chain->identtag == ttype) {
            found = true;
            *level = looklevel;
            *place = chain;
          }  /* if */
          break;

        case tforward:
        case tglobal:
        case tpredefined:
        case tfunction:
          if (chain->identtag == tfunction || chain->identtag == tforward ||
              chain->identtag == tglobal || chain->identtag == tpredefined) {
            found = true;
            *level = looklevel;
            *place = chain;
          }  /* if */
          break;

        case tparam:
        case tvariable:
          if (chain->identtag == tvariable || chain->identtag == tparam) {
            found = true;
            *level = looklevel;
            *place = chain;
          }  /* if */
          break;
        default:
           ;
        }/* case */
      }
      chain = chain->nextbucket;
    }  /* while */
    if (looklevel->lleveltag == funct && itype != tfunction &&
        itype != tglobal && itype != tpredefined && itype != ttype)
      found = true;
    else if (looklevel->lastlevel == NULL)
      found = true;
    else
      looklevel = looklevel->lastlevel;
  } while (!found);
}


static void addpredefined(name, tag)
stryng name;
predeftype tag;
{
  symtblbucket *bucket;

  bucket = createbucket(tpredefined);
  setname(bucket, name);
  bucket->UU.predefined = tag;
  addtotable(bucket, currentlevel);
}


static void initsymtable()
{
  /*Initialize the root symbol table to contain all the predefined
          functions.*/
  stryng predefined;

  currentlevel = NULL;
  createlevel(root);
  string10(&predefined, "Abs       ");
  stripspaces(&predefined);
  addpredefined(predefined, tgabs);
  string10(&predefined, "Array_AddH");
  stripspaces(&predefined);
  addpredefined(predefined, tgarrayaddh);
  string10(&predefined, "Array_AddL");
  stripspaces(&predefined);
  addpredefined(predefined, tgarrayaddl);
  string20(&predefined, "Array_Adjust        ");
  stripspaces(&predefined);
  addpredefined(predefined, tgarrayadjust);
  string10(&predefined, "Array_Fill");
  stripspaces(&predefined);
  addpredefined(predefined, tgarrayfill);
  string10(&predefined, "Array_LimH");
  stripspaces(&predefined);
  addpredefined(predefined, tgarraylimh);
  string10(&predefined, "Array_LimL");
  stripspaces(&predefined);
  addpredefined(predefined, tgarrayliml);
  string20(&predefined, "Array_PrefixSize    ");
  stripspaces(&predefined);
  addpredefined(predefined, tgarrayprefixsize);
  string10(&predefined, "Array_RemH");
  stripspaces(&predefined);
  addpredefined(predefined, tgarrayremh);
  string10(&predefined, "Array_RemL");
  stripspaces(&predefined);
  addpredefined(predefined, tgarrayreml);
  string10(&predefined, "Array_SetL");
  stripspaces(&predefined);
  addpredefined(predefined, tgarraysetl);
  string10(&predefined, "Array_Size");
  stripspaces(&predefined);
  addpredefined(predefined, tgarraysize);
  string10(&predefined, "Exp       ");
  stripspaces(&predefined);
  addpredefined(predefined, tgexp);
  string10(&predefined, "Floor     ");
  stripspaces(&predefined);
  addpredefined(predefined, tgfloor);
  string10(&predefined, "Max       ");
  stripspaces(&predefined);
  addpredefined(predefined, tgmax);
  string10(&predefined, "Min       ");
  stripspaces(&predefined);
  addpredefined(predefined, tgmin);
  string10(&predefined, "Mod       ");
  stripspaces(&predefined);
  addpredefined(predefined, tgmod);

/* CANN PEEK */  string10(&predefined, "Peek      ");
/* CANN PEEK */stripspaces(&predefined);
/* CANN PEEK */addpredefined(predefined, tgpeek);

  string20(&predefined, "Stream_Append       ");
  stripspaces(&predefined);
  addpredefined(predefined, tgstreamappend);
  string20(&predefined, "Stream_Empty        ");
  stripspaces(&predefined);
  addpredefined(predefined, tgstreamempty);
  string20(&predefined, "Stream_First        ");
  stripspaces(&predefined);
  addpredefined(predefined, tgstreamfirst);
  string20(&predefined, "Stream_PrefixSize   ");
  stripspaces(&predefined);
  addpredefined(predefined, tgstreamprefixsize);
  string20(&predefined, "Stream_Rest         ");
  stripspaces(&predefined);
  addpredefined(predefined, tgstreamrest);
  string20(&predefined, "Stream_Size         ");
  stripspaces(&predefined);
  addpredefined(predefined, tgstreamsize);
  string10(&predefined, "Trunc     ");
  stripspaces(&predefined);
  addpredefined(predefined, tgtrunc);
}


Static void outtype(fil, typ, printname)
FILE *fil;
stentry *typ;
boolean printname;
{
  /*Output to the file = Fil the type = Typ.  If PrintName is true
          and the type has a name, just print the name.  Otherwise print
          the structure of the type.  This routine calls itself recursively.  */
  if (typ == NULL) {
    return;
  }  /* if */
  if (typ->stliteral.len != 0 && printname) {
    writestring(fil, &typ->stliteral);
    return;
  }
  switch (typ->stsort) {

  case iftwild:
    fprintf(fil, " wild ");
    break;

  case iftbasic:
    switch (typ->UU.stbasic) {

    case 0:
      fprintf(fil, " Boolean ");
      break;

    case 1:
      fprintf(fil, " Character ");
      break;

    case 2:
      fprintf(fil, " Double ");
      break;

    case 3:
      fprintf(fil, " Integer ");
      break;

    case 4:
      fprintf(fil, " Null ");
      break;

    case 5:
      fprintf(fil, " Real ");
      break;

    case 6:
      fprintf(fil, " Wild ");
      break;
    }
    break;

  case iftfunctiontype:
    fprintf(fil, " Function ");
    break;

  case iftarray:
    fprintf(fil, " Array[ ");
    if (!typ->strecurflag)
      outtype(fil, typ->UU.stbasetype, true);
    else
      writestring(fil, &typ->UU.stbasetype->stliteral);
    fprintf(fil, " ]");
    break;

  case iftstream:
    fprintf(fil, " Stream( ");
    if (!typ->strecurflag)
      outtype(fil, typ->UU.stbasetype, true);
    else
      writestring(fil, &typ->UU.stbasetype->stliteral);
    fprintf(fil, " )");
    break;

  case iftmultiple:
    fprintf(fil, " Multiple( ");
    if (!typ->strecurflag)
      outtype(fil, typ->UU.stbasetype, true);
    else
      writestring(fil, &typ->UU.stbasetype->stliteral);
    fprintf(fil, " )");
    break;

  case iftrecord:
    fprintf(fil, " Record[ ");
    outtype(fil, typ->UU.stbasetype, false);
    fprintf(fil, " ]");
    break;

  case iftunion:
    fprintf(fil, " Union[ ");
    outtype(fil, typ->UU.stbasetype, false);
    fprintf(fil, " ]");
    break;

  case iftfield:
    writestring(fil, &typ->stliteral);
    fprintf(fil, " : ");
    if (typ->UU.U2.stelemtype != NULL) {
      if (typ->UU.U2.stelemtype->stliteral.len == 0)
        outtype(fil, typ->UU.U2.stelemtype, false);
      else
        writestring(fil, &typ->UU.U2.stelemtype->stliteral);
    } else
      printf(" Undef Type ");
    if (typ->UU.U2.stnext != NULL)
      fprintf(fil, "; ");
    outtype(fil, typ->UU.U2.stnext, false);
    break;

  case ifttuple:
    writestring(fil, &typ->stliteral);
    fprintf(fil, " : ");
    if (typ->UU.U2.stelemtype->stliteral.len == 0)
      outtype(fil, typ->UU.U2.stelemtype, false);
    else
      writestring(fil, &typ->UU.U2.stelemtype->stliteral);
    putc('\n', fil);
    outtype(fil, typ->UU.U2.stnext, false);
    break;

  case ifttag:
    writestring(fil, &typ->stliteral);
    fprintf(fil, " : ");
    if (typ->UU.U2.stelemtype != NULL) {
      if (typ->UU.U2.stelemtype->stliteral.len == 0)
        outtype(fil, typ->UU.U2.stelemtype, false);
      else
        writestring(fil, &typ->UU.U2.stelemtype->stliteral);
    } else
      printf(" Undef Type ");
    if (typ->UU.U2.stnext != NULL)
      fprintf(fil, "; ");
    outtype(fil, typ->UU.U2.stnext, false);
    break;
  }/* case */
}


Char *identtype_NAMES[] = {
  "ttype", "tglobal", "tfunction", "tforward", "tvariable", "tparam",
  "tpredefined", "none"
} ;


Char *loopvarflags_NAMES[] = {
  "lnone", "lvar", "lconst", "linit", "lbinit"
} ;


static void printbucket(symbucket)
symtblbucket *symbucket;
{
  /*Print the contents of the symbol table entry.*/
  reflist *ref;

  printf("%s  ", identtype_NAMES[(long)symbucket->identtag]);
  writestring(stdout, &symbucket->name);
  if (symbucket->identtag == tpredefined) {
    return;
  }  /* if */
  printf("  Defs %7d", symbucket->defloc->fline);
  if (symbucket->defloc->sline != -1)
    printf(" , %12d", symbucket->defloc->sline);
  putchar('\n');
  if (symbucket->references != NULL) {
    ref = symbucket->references->front;
    while (ref != NULL) {
      printf("%12d ", ref->line);
      ref = ref->nextref;
    }
    putchar('\n');
  } else
    printf("References pointer is nil\n");
  if (symbucket->typeptr != NULL) {
    if (symbucket->typeptr->stsort == iftbasic)
      outtype(stdout, symbucket->typeptr, true);
    writestring(stdout, &symbucket->typeptr->stliteral);
    putchar('\n');
  }
  if (symbucket->graphinfo != NULL) {
    printf("GraphInfo\n");
    if (symbucket->graphinfo->node_ != NULL)
      printf("Node = %4d", symbucket->graphinfo->node_->ndlabel);
    else
      printf("node is nil");
    printf("Port = %4d", symbucket->graphinfo->port_);
    writestring(stdout, &symbucket->graphinfo->name);
    printf("  ");
    writestring(stdout, &symbucket->graphinfo->litvalue);
    putchar('\n');
  } else
    printf("GraphInfo is nil\n");
  if (symbucket->identtag != tvariable) {
    return;
  }  /* if */
  printf("  LoopFlag is : %s",
         loopvarflags_NAMES[(long)(*symbucket->UU.U4.loopflag)]);
  printf(" TFlag is : %s", symbucket->UU.U4.tflag ? " TRUE" : "FALSE");
  printf(" RedefFlag is : %s\n",
         symbucket->UU.U4.redefflag ? " TRUE" : "FALSE");
  if (symbucket->UU.U4.oldfrom == NULL)
    return;
  printf("Old GraphInfo\n");
  if (symbucket->UU.U4.oldfrom->node_ != NULL)
    printf("Node = %4d", symbucket->UU.U4.oldfrom->node_->ndlabel);
  else
    printf("node is nil ");
  printf("Port = %4d", symbucket->UU.U4.oldfrom->port_);
  writestring(stdout, &symbucket->UU.U4.oldfrom->name);
  printf("  ");
  writestring(stdout, &symbucket->UU.U4.oldfrom->litvalue);
  putchar('\n');
}  /* PrintBucket */


staticforward void newsymlist PROTO(( symlistobj**,struct LOC_printtable* ));
static void newsymlist(sym, LINK)
symlistobj **sym;
struct LOC_printtable *LINK;
{
  *sym = (symlistobj *)Malloc(sizeof(symlistobj));
  (*sym)->entry_ = NULL;
  (*sym)->next = NULL;
}  /* NewSymList */

staticforward void freesymlist PROTO(( symlistobj*,struct LOC_printtable* ));
static void freesymlist(sym, LINK)
symlistobj *sym;
struct LOC_printtable *LINK;
{
  /* Free(sym); */
}  /* FreeSymList */

staticforward void addtofunctlist PROTO(( symtblbucket*,struct LOC_printtable* ));
static void addtofunctlist(sym, LINK)
symtblbucket *sym;
struct LOC_printtable *LINK;
{
  symlistobj *syml;

  newsymlist(&syml, LINK);
  syml->entry_ = sym;
  if (LINK->frontl == NULL)
    LINK->frontl = syml;
  else
    LINK->backl->next = syml;
  LINK->backl = syml;
}  /* addtofunctlist */


static void printtable(fil, node_)
FILE *fil;
treestackobj *node_;
{
  /*Print the symbol table node to the file.*/
  struct LOC_printtable V;
  int i;
  symtblbucket *chain;
  symlistobj *dump;

  V.frontl = NULL;
  V.backl = NULL;
  /*writeln(Fil,'  Name                    Class      Defined    Referenced      Type   ');*/
  putc('\n', fil);
  for (i = 0; i <= maxhashtable; i++) {
    chain = node_->hashtable[i];
    while (chain != NULL) {
      if (chain->identtag != tfunction && chain->identtag != tglobal &&
          chain->identtag != tforward && chain->identtag != tpredefined)
        printbucket(chain);
      else
        addtofunctlist(chain, &V);
      chain = chain->nextbucket;
    }  /* while */
  }  /* for */
  while (V.frontl != NULL) {
    chain = V.frontl->entry_;
    fprintf(fil, "Function ");
    writestring(fil, &chain->name);
    fprintf(fil, "  %s\n", identtype_NAMES[(long)chain->identtag]);
    if (chain->typeptr != NULL) {
      fprintf(fil, " arguments ");
      outtype(fil, chain->typeptr->UU.U3.starg, true);
      fprintf(fil, "\n returns ");
      outtype(fil, chain->typeptr->UU.U3.stres, true);
      putc('\n', fil);
    }  /* if */
    dump = V.frontl;
    V.frontl = V.frontl->next;
    freesymlist(dump, &V);
  }  /* while */
}


static void printtypes(fil)
FILE *fil;
{
  /*Print out the IF1 type table.*/
  int i;

  for (i = 0; i < entrymax; i++) {
    if (typetable[i] != NULL) {
      if (typetable[i]->stid == 1) {
        writestring(fil, &typetable[i]->stliteral);
        fprintf(fil, " :\n");
        fprintf(fil, "           ");
        outtype(fil, typetable[i], false);
        putc('\n', fil);
        typetable[i]->stid = -1;
      }  /* if */
    }
  }  /* for */
}


Char *lexleveltype_NAMES[] = {
  "forloop", "specfa", "let", "funct", "tagcase", "initloop", "ifcomp",
  "root", "nestedifcomp"
} ;


static void printtree(fil, current)
FILE *fil;
treestackobj *current;
{
  /*Print all the symbol tables from current down to root.*/
  symtblbucket *fun;

  while (current != NULL) {
    putc('\n', fil);
    if (current->lleveltag == funct) {
      fun = current->UU.lfunctname;
      fprintf(fil, "Function ");
      if (fun == NULL)
        printf(" LFunctName is nil\n");
      else {
        writestring(fil, &fun->name);
        putc('\n', fil);
        if (fun->typeptr != NULL) {
          fprintf(fil, " arguments\n");
          outtype(fil, fun->typeptr->UU.U3.starg, true);
          fprintf(fil, "\n returns\n");
          outtype(fil, fun->typeptr->UU.U3.stres, true);
          putc('\n', fil);
        }  /* if */
        else
          printf("LFunctName type pointer is nil\n");
      }  /* else */
    }  /* if */
    else
      fprintf(fil, "%s\n", lexleveltype_NAMES[(long)current->lleveltag]);
    printtable(fil, current);
    current = current->nextlevel;
  }  /* while */
}  /* PrintTree */


static void crossref(fil, level)
FILE *fil;
treestackobj *level;
{
  /*Print out sym table at Level, used only by debugger.*/
  if (level == NULL) {
    return;
  }  /* if */
  printtree(fil, level);
  fprintf(fil,
    "\n --------------------------------------------------------------------\n\n");
  printtypes(fil);
}


symtblbucket *getsymtabentry(id, bucktype)
stryng id;
identtype bucktype;
{
  /*Get a symbol table entry of type Bucktype and set its name to
          id.  Returns its pointer.*/
  symtblbucket *symentry;

  symentry = createbucket(bucktype);
  setname(symentry, id);
  return symentry;
}  /* getsymtabentry */


edgelisthead *addnametolist(list, name)
edgelisthead **list;
stryng name;
{
  edgelisthead *newhead, *inlist;

  newhead = newheadptr();
  newhead->edgename = name;
  if (*list == NULL) {
    *list = newhead;
    return newhead;
  }  /* if */
  inlist = *list;
  while (inlist->next != NULL)
    inlist = inlist->next;
  inlist->next = newhead;
  return newhead;
}


edgelisthead *addtoklist(name, edge, list)
stryng name;
port *edge;
edgelisthead *list;
{
  edgelisthead *Result;
  edgelist *newedgerec;
  edgelisthead *newhead;
  boolean done, found;

  done = false;
  found = false;
  while (!done && !found) {
    if (!equalstrings(&list->edgename, &name)) {
      if (list->next != NULL)
        list = list->next;
      else
        done = true;
      continue;
    }  /* if */
    newedgerec = newedgelistptr();
    newedgerec->edge = edge;
    newedgerec->next = list->edges;
    newedgerec->toorfrom = toport;
    list->edges = newedgerec;
    Result = list;
    found = true;
  }  /* while */
  if (!done) {
    return Result;
  }  /* if */
  newhead = newheadptr();
  newedgerec = newedgelistptr();
  newedgerec->next = NULL;
  newhead->edgename = name;
  newhead->edges = newedgerec;
  newedgerec->edge = edge;
  newedgerec->toorfrom = toport;
  list->next = newhead;
  return newhead;
/* p2c: mono.bin.noblank.p: Note: Deleting unreachable code [255] */
}  /* AddToKList */


edgelisthead *addtoforklist(name, edge, level)
stryng name;
port *edge;
treestackobj *level;
{
  edgelisthead *klist;
  edgelist *newedgerec;
  edgelisthead *newhead;

  if (level->lleveltag == forloop || level->lleveltag == specfa) {
    klist = level->UU.U0.kflist;
    if (klist != NULL)
      return (addtoklist(name, edge, klist));
    else {
      newhead = newheadptr();
      newedgerec = newedgelistptr();
      newedgerec->next = NULL;
      newhead->edgename = name;
      newhead->edges = newedgerec;
      newedgerec->edge = edge;
      newedgerec->toorfrom = toport;
      level->UU.U0.kflist = newhead;
      return newhead;
    }  /* else */
  }  /* if */
  printf(" tag not Forloop or SpecFA in AddToForKList\n");
  return NULL;
}  /* AddToForKList */


edgelisthead *addtoiklist(name, edge, level)
stryng name;
port *edge;
treestackobj *level;
{
  edgelisthead *klist;
  edgelist *newedgerec;
  edgelisthead *newhead;

  if (level->lleveltag == initloop) {
    klist = level->UU.U5.kilist;
    if (klist != NULL)
      return (addtoklist(name, edge, klist));
    else {
      newhead = newheadptr();
      newedgerec = newedgelistptr();
      newedgerec->next = NULL;
      newhead->edgename = name;
      newhead->edges = newedgerec;
      newedgerec->edge = edge;
      newedgerec->toorfrom = toport;
      level->UU.U5.kilist = newhead;
      return newhead;
    }  /* else */
  }  /* if */
  printf(" tag not InitLoop in AddToIKList\n");
  return NULL;
}  /* AddToIKList */


static void addtoolist(edge, node_)
port *edge;
node *node_;
{
  /* Add the edge to the output port list of the node suppiled.*/
  port *trail, *olist;
  boolean found;
  stryng name1, name2;

  if (edge->UU.U1.ptfrport != -1)   /* if */
  {  /* if a port num has been assigned */
    olist = node_->ndolist;
    if (olist == NULL) {
      node_->ndolist = edge;
      return;
    }  /* if olist <> nil */
    trail = NULL;
    found = false;
    while (!found) {  /* list is ordered by port num */
      /* if (olist->UU.U1.ptfrport > edge->UU.U1.ptfrport) */
      if (olist->UU.U1.ptfrport >= edge->UU.U1.ptfrport)  /* CANN FASTER!!! */
        found = true;
      else {
        trail = olist;
        olist = olist->UU.U1.ptfrnext;
      }
      if (olist == NULL)
        found = true;
    }  /* while */
    edge->UU.U1.ptfrnext = olist;
    if (trail == NULL)
      node_->ndolist = edge;
    else
      trail->UU.U1.ptfrnext = edge;
    return;
  }
  /* else no port num has been assigned */
  olist = node_->ndolist;
  if (olist == NULL) {
    node_->ndolist = edge;
    return;
  }  /* if */
  trail = NULL;
  found = false;
  name2 = edge->ptname;
  stringlowercase(&name2);
  while (!found) {  /* Search for others with the same name */
    name1 = olist->ptname;
    stringlowercase(&name1);
    if (equalstrings(&name1, &name2)) {
      found = true;
      break;
    }
    trail = olist;
    olist = olist->UU.U1.ptfrnext;
    if (olist == NULL)
      found = true;
  }  /* while */
  edge->UU.U1.ptfrnext = olist;
  if (trail == NULL)
    node_->ndolist = edge;
  else
    trail->UU.U1.ptfrnext = edge;

  /* else */
}  /* AddToOList */


static void addtoilist(edge, node_)
port *edge;
node *node_;
{
  /*  Add the edge to the input port list of the supplied node*/
  port *trail, *ilist;
  boolean found;

  if (edge->pttoport != -1) {  /* if no port num is assigned */
    ilist = node_->ndilist;
    if (ilist == NULL) {
      node_->ndilist = edge;
      return;
    }  /* if olist <> nil */
    trail = NULL;
    found = false;
    while (!found) {  /* list is ordered by port num */
      if (ilist->pttoport > edge->pttoport)
        found = true;
      else {
        trail = ilist;
        ilist = ilist->pttonext;
      }
      if (ilist == NULL)
        found = true;
    }  /* while */
    edge->pttonext = ilist;
    if (trail == NULL)
      node_->ndilist = edge;
    else
      trail->pttonext = edge;
    return;
  }  /* if */
  ilist = node_->ndilist;
  if (ilist == NULL) {
    node_->ndilist = edge;
    return;
  }  /* if */
  trail = NULL;
  found = false;
  while (!found) {  /* look for others with same name */
    if (equalstrings(&ilist->ptname, &edge->ptname)) {
      found = true;
      break;
    }
    trail = ilist;
    ilist = ilist->pttonext;
    if (ilist == NULL)
      found = true;
  }  /* while */
  edge->pttonext = ilist;
  if (trail == NULL)
    node_->ndilist = edge;
  else
    trail->pttonext = edge;

  /* else no port num is assigned */
  /* else */
}  /* AddToIList */


symtblbucket *copysym(old)
symtblbucket *old;
{
  /*  Build a new sym table bucket with the same info as the one passed in */
  symtblbucket *new_;

  new_ = createbucket(old->identtag);
  new_->name = old->name;
  new_->graphinfo->name = old->name;
  new_->defloc = old->defloc;
  new_->references = old->references;
  new_->typeptr = old->typeptr;
  new_->importedflag = true;
  switch (old->identtag) {

  case tvariable:
    new_->UU.U4.loopflag = old->UU.U4.loopflag;
    new_->UU.U4.tflag = old->UU.U4.tflag;
    new_->UU.U4.redefflag = old->UU.U4.redefflag;
    new_->UU.U4.oldfrom->name = old->name;
    insertchar(&new_->UU.U4.oldfrom->name, '-', 1);
    insertchar(&new_->UU.U4.oldfrom->name, 'd', 1);
    insertchar(&new_->UU.U4.oldfrom->name, 'l', 1);
    insertchar(&new_->UU.U4.oldfrom->name, 'o', 1);
    break;

  case tglobal:
  case tforward:
  case tfunction:
    printf("Pulling function !!\n");
    break;

  case tparam:
    /* blank case */
    break;

  case ttype:
    printf(" Pulling type!!\n");
    break;
  default:
    break;
  }/* case */
  return new_;
}  /* CopySym */


port *emptyoldedge(sym)
symtblbucket *sym;
{
  /* Return an edge that comes from the OldFrom graph info in Sym*/
  port *newedge;

  newedge = newedgeptr(ptedge);
  newedge->UU.U1.ptfrnode = sym->UU.U4.oldfrom->node_;
  newedge->ptname = sym->name;
  insertchar(&newedge->ptname, '-', 1);
  insertchar(&newedge->ptname, 'd', 1);
  insertchar(&newedge->ptname, 'l', 1);
  insertchar(&newedge->ptname, 'o', 1);
  newedge->pttype = sym->typeptr;
  if (sym->UU.U4.oldfrom->onlist == NULL)
    newedge->UU.U1.ptfrport = sym->UU.U4.oldfrom->port_;
  return newedge;
}


port *emptyedge(sym)
symtblbucket *sym;
{
  /* Return an edge that comes from the graph info in Sym*/
  port *newedge;

  newedge = newedgeptr(ptedge);
  newedge->UU.U1.ptfrnode = sym->graphinfo->node_;
  newedge->ptname = sym->name;
  newedge->pttype = sym->typeptr;
  if (sym->graphinfo->onlist == NULL)
    newedge->UU.U1.ptfrport = sym->graphinfo->port_;
  return newedge;
}


int nextkport(level)
treestackobj *level;
{
  if (level->lleveltag == ifcomp || level->lleveltag == nestedifcomp) {
    level->UU.U8.kiport++;
    return (level->UU.U8.kiport);
  } else {
    level->UU.U4.ktport++;
    return (level->UU.U4.ktport);
  }
}  /* NexrKPort */


symtblbucket *pullname(symname, level, line)
symtblbucket *symname;
treestackobj *level;
int line;
{
  /* This routine connects the edges required to bring the value represented
     by SymName in Lex Level Level into the current lex level.  If SymName is
     a loop name it will also pull in the OldFrom value is it is defined.
     A symbol table entry containing the graphinfo for the value in the
     current lex level is returned.*/
  symtblbucket *newsym;
  edgelisthead *list;
  edgelist *newel;
  treestackobj *fromlevel;
  port *edge, *dupedge;
  boolean oldpull, graphinfopull;

  if (level == currentlevel) {  /* if not at the inner level */
    return symname;
  }  /* if */
  graphinfopull = true;
  oldpull = false;
  if (symname->identtag == tvariable) {
    if (*symname->UU.U4.loopflag == lvar) {  /* if pulling a loop name */
      oldpull = true;   /* and it had OldFrom info */
      if (!symname->UU.U4.redefflag)   /* then pull that along too */
        graphinfopull = false;
    }
  }
  while (level != currentlevel) {
    /* go until we reach the inner-
                                                  most level*/
    newsym = copysym(symname);
    level = level->nextlevel;
    if (level->lleveltag != let) {
      if (graphinfopull) {
        if (symname->graphinfo->node_ == NULL) {  /* It's a lit */
          edge = newedgeptr(ptlit);
          edge->ptname = symname->name;
          edge->UU.ptlitvalue = symname->graphinfo->litvalue;
          edge->pttype = symname->typeptr;
          edge->ptsrcline = line;
        } else {
          edge = emptyedge(symname);
          edge->ptsrcline = line;
          list = symname->graphinfo->onlist;
          if (list == NULL && level->lleveltag != funct)
                /* not on a list, so it's easy */
                  addtoolist(edge, symname->graphinfo->node_);
          else {  /* else need to add to a list */
            newel = newedgelistptr();
            newel->edge = edge;
            newel->next = list->edges;
            newel->toorfrom = fromport;
            list->edges = newel;
            fromlevel = level->lastlevel;   /* find the current SG Node */
            while (fromlevel->lleveltag == let)   /* add to the SG Olist */
              fromlevel = fromlevel->lastlevel;
            addtoolist(edge, fromlevel->currentsubn0);
          }
        }  /* else */
      }  /* if */
      if (oldpull) {  /* do the same thing for the old value */
        if (symname->UU.U4.oldfrom->node_ == NULL) {
          dupedge = newedgeptr(ptlit);
          dupedge->ptname = symname->name;
          insertchar(&dupedge->ptname, '-', 1);
          insertchar(&dupedge->ptname, 'd', 1);
          insertchar(&dupedge->ptname, 'l', 1);
          insertchar(&dupedge->ptname, 'o', 1);
          dupedge->UU.ptlitvalue = symname->UU.U4.oldfrom->litvalue;
          dupedge->pttype = symname->typeptr;
          dupedge->ptsrcline = line;
        } else {
          dupedge = emptyoldedge(symname);
          dupedge->ptsrcline = line;
          list = symname->UU.U4.oldfrom->onlist;
          if (list == NULL && level->lleveltag != funct)
            addtoolist(dupedge, symname->UU.U4.oldfrom->node_);
          else {
            newel = newedgelistptr();
            newel->edge = dupedge;
            newel->next = list->edges;
            newel->toorfrom = fromport;
            list->edges = newel;
            fromlevel = level->lastlevel;
            while (fromlevel->lleveltag == let)
              fromlevel = fromlevel->lastlevel;
            addtoolist(dupedge, fromlevel->currentsubn0);
          }
        }  /* else */
      }  /* if */
    }  /* if */
    /* Now have to process the TO end of the edge.  Add the edge to the
       input list of the node, set the TO node in the edge and set
       the Node Graphinfo to the current subgraph in that lex level.  */
    switch (level->lleveltag) {

    case forloop:
    case specfa:
      if (graphinfopull) {
        newsym->graphinfo->onlist = addtoforklist(symname->name, edge, level);
        edge->pttonode = level->UU.U0.forallnode;
        addtoilist(edge, level->UU.U0.forallnode);
        newsym->graphinfo->node_ = level->currentsubn0;
        newsym->graphinfo->typeptr = symname->typeptr;
      }  /* if */
      if (oldpull) {
        newsym->UU.U4.oldfrom->onlist = addtoforklist(dupedge->ptname,
                                                      dupedge, level);
        dupedge->pttonode = level->UU.U0.forallnode;
        addtoilist(dupedge, level->UU.U0.forallnode);
        newsym->UU.U4.oldfrom->node_ = level->currentsubn0;
        newsym->UU.U4.oldfrom->typeptr = symname->typeptr;
      }  /* then */
      addtotable(newsym, level);
      break;

    case initloop:
      if (graphinfopull) {
        newsym->graphinfo->onlist = addtoiklist(symname->name, edge, level);
        edge->pttonode = level->UU.U5.initnode;
        addtoilist(edge, level->UU.U5.initnode);
        newsym->graphinfo->node_ = level->currentsubn0;
        newsym->graphinfo->typeptr = symname->typeptr;
      }  /* if */
      if (oldpull) {
        newsym->UU.U4.oldfrom->onlist = addtoiklist(dupedge->ptname, dupedge,
                                                    level);
        dupedge->pttonode = level->UU.U5.initnode;
        addtoilist(dupedge, level->UU.U5.initnode);
        newsym->UU.U4.oldfrom->node_ = level->currentsubn0;
        newsym->UU.U4.oldfrom->typeptr = symname->typeptr;
      }  /* if */
      addtotable(newsym, level);
      break;

    case tagcase:
      if (graphinfopull) {
        newsym->graphinfo->onlist = NULL;
        edge->pttonode = level->UU.U4.tagcasenode;
        edge->pttoport = nextkport(level);
        addtoilist(edge, level->UU.U4.tagcasenode);
        newsym->graphinfo->node_ = level->currentsubn0;
        newsym->graphinfo->port_ = edge->pttoport;
        newsym->graphinfo->typeptr = edge->pttype;
      }  /* if */
      if (oldpull) {
        newsym->UU.U4.oldfrom->onlist = NULL;
        dupedge->pttonode = level->UU.U4.tagcasenode;
        dupedge->pttoport = nextkport(level);
        addtoilist(dupedge, level->UU.U4.tagcasenode);
        newsym->UU.U4.oldfrom->node_ = level->currentsubn0;
        newsym->UU.U4.oldfrom->port_ = dupedge->pttoport;
        newsym->UU.U4.oldfrom->typeptr = dupedge->pttype;
      }
      addtotable(newsym, level);
      break;

    case ifcomp:
    case nestedifcomp:
      if (graphinfopull) {
        newsym->graphinfo->onlist = NULL;
        edge->pttonode = level->UU.U8.ifnode;
        edge->pttoport = nextkport(level);
        addtoilist(edge, level->UU.U8.ifnode);
        newsym->graphinfo->node_ = level->currentsubn0;
        newsym->graphinfo->port_ = edge->pttoport;
        newsym->graphinfo->typeptr = edge->pttype;
      }  /* if */
      if (oldpull) {
        newsym->UU.U4.oldfrom->onlist = NULL;
        dupedge->pttonode = level->UU.U8.ifnode;
        dupedge->pttoport = nextkport(level);
        addtoilist(dupedge, level->UU.U8.ifnode);
        newsym->UU.U4.oldfrom->node_ = level->currentsubn0;
        newsym->UU.U4.oldfrom->port_ = dupedge->pttoport;
        newsym->UU.U4.oldfrom->typeptr = dupedge->pttype;
      }
      addtotable(newsym, level);
      break;

    case funct:
      if (graphinfopull)
        newsym->graphinfo = symname->graphinfo;
      if (oldpull)
        newsym->UU.U4.oldfrom = symname->UU.U4.oldfrom;
      addtotable(newsym, level);
      break;

    case let:
    case root:
      if (graphinfopull)
        newsym->graphinfo = symname->graphinfo;
      if (oldpull)
        newsym->UU.U4.oldfrom = symname->UU.U4.oldfrom;
      addtotable(newsym, level);
      break;
    }/* case */
    symname = newsym;
  }  /* while */
  return symname;
}  /* PullName */


static void addedge(from, tonode)
inforecord *from;
inforecord *tonode;
{
  /* This routine do everything necessary to create and edge between the
     From graphinfo and the To graphinfo.  */
  port *edge;
  edgelist *edgeel;
  int line;
  symtblbucket *sym;
  stryng str, oldstr;
  /* boolean oldflag; */

  sym = NULL;
  line = -1;
  /* oldflag = false; */
  if (from->name.len != 0) {
    if (tonode->node_->ndcode == ifncall && tonode->port_ == 1) {
      /*name is a function*/
      sym = incurrentlevel(from->name, tfunction);
    } else {
      substring(&str, &from->name, 1, 4);
      string10(&oldstr, "old-      ");
      stripspaces(&oldstr);
      if (equalstrings(&str, &oldstr)) {
        str = from->name;
        deletestring(&str, 1, 4);
        /* oldflag = true; */
      } else
        str = from->name;
      sym = incurrentlevel(str, tvariable);
    }
    if (sym != NULL) {
      if (sym->references->back != NULL)
        line = sym->references->back->line;
      else if (getdefline(sym, 2) > 0)
        line = getdefline(sym, 2);
      else
        line = getdefline(sym, 1);
    }  /*then*/
  }  /*then*/
  if (from->node_ == NULL) {  /* from is a literal */
    edge = newedgeptr(ptlit);
    edge->pttype = from->typeptr;
    edge->ptname = from->name;
    edge->UU.ptlitvalue = from->litvalue;
    edge->ptsrcline = line;
  } else {
    edge = newedgeptr(ptedge);
    edge->UU.U1.ptfrnode = from->node_;
    edge->pttype = from->typeptr;
    edge->ptname = from->name;
    edge->ptsrcline = line;
    if (from->onlist == NULL) {  /* If port is assigned */
      edge->UU.U1.ptfrport = from->port_;
      addtoolist(edge, from->node_);
    }  /* if Onlist = nil */
    else {  /* else place on the list */
      edgeel = newedgelistptr();
      edgeel->edge = edge;
      edgeel->toorfrom = fromport;
      edgeel->next = from->onlist->edges;
      from->onlist->edges = edgeel;
      addtoolist(edge, from->node_);
    }  /* else Onlist <> nil */
  }  /* from not a literal */
  edge->pttonode = tonode->node_;   /* process the To Node */
  if (tonode->onlist == NULL) {  /* if port is assigned */
    edge->pttoport = tonode->port_;
    addtoilist(edge, tonode->node_);
    return;
  }  /* if Onlist = nil */
  edgeel = newedgelistptr();
  edgeel->edge = edge;
  edgeel->toorfrom = toport;
  edgeel->next = tonode->onlist->edges;
  tonode->onlist->edges = edgeel;
  addtoilist(edge, tonode->node_);

  /* else put on the list */
}  /* AddEdge */


static void pushnilttptr()
{
  /*action 93 PushNilTTPtr*/
  /*stack              pops - nothing
                       pushes - TGTTptr*/
  /*description
            Create a new type table semantic record and push it on the
            stack.*/
  semanticrec *sem;

  if (semtrace)
    printf("In PushNilTTPtr\n");
  newsemantic(&sem, tgttptr);
  pushsemantic(sem);
}  /* PushNilTTPtr*/


static void pushbasic(token)
int token;
{
  /*action 10 PushBasic*/
  /*stack              pops - nothing
                       pushes - TGTTptr*/
  /*description
           Get a type table pointer of the correct basic type.
           Create a new type table semantic record and save the basic
           type pointer in it.  Push the semantic record*/
  semanticrec *semrec;
  stentry *typeptr;

  if (semtrace)
    printf("In PushBasic\n");
  switch (token) {

  case nullkw:
    typeptr = getbasictype(ifbnull);
    break;

  case boolkw:
    typeptr = getbasictype(ifbboolean);
    break;

  case intgkw:
    typeptr = getbasictype(ifbinteger);
    break;

  case realkw:
    typeptr = getbasictype(ifbreal);
    break;

  case doubkw:
    typeptr = getbasictype(ifbdouble);
    break;

  case charkw:
    typeptr = getbasictype(ifbcharacter);
    break;
  }/* case */
  newsemantic(&semrec, tgttptr);
  semrec->UU.ttptr = typeptr;
  pushsemantic(semrec);
}  /* PushBasic */


static void pushtypename(inputtoken, line, column)
stryng inputtoken;
int line, column;
{
  /*action 11 PushTypeName*/
  /*stack              pops - nothing
                       pushes - TGSymList*/
  /*description
          Search the current SymTab entry for type name of inputtoken.  If
          one is found its typeptr should be empty.  Otherwise this is a
          second defition of this type name so declare and error.  If the
          name is found with a nil typeptr, this means it was referenced
          before it was defined which is ok.  If no entry is found, create
          a new one.  Save the symtabptr on the stack.*/
  symtblbucket *symname;
  semanticrec *symptr;
  errorrecord *errorrec;

  if (semtrace)
    printf("In PushTypeName\n");
  symname = incurrentlevel(inputtoken, ttype);
  if (symname == NULL) {
    symname = getsymtabentry(inputtoken, ttype);
    symname->typeptr = NULL;
    setdefloc(symname, line, column);
    addtotable(symname, currentlevel);
  } else {
    if (symname->typeptr != NULL) {
      errorrec = newerrorptr(typedoubdef);
      errorrec->UU.errorstr = inputtoken;
      errorrec->linenumber = line;
      semerror(errorrec);
    }
  }
  newsemantic(&symptr, tgsymptr);
  symptr->UU.symptr = symname;
  pushsemantic(symptr);
}  /* PushTypeName */


static void pusharray(flgaddtotable)
boolean flgaddtotable;
{
  /*action 12 PushArray*/
  /*stack              pops - nothing
                       pushes - TGTTPtr*/
  /*description
           Get an array type table pointer.  Create a semantic record
           and save the type pointer in it. Push the semantic record.*/
  stentry *parray;
  semanticrec *semrec;

  if (semtrace)
    printf("In PushArray\n");
  newttptr(&parray, iftarray);
  if (flgaddtotable)
    putintable(&parray);
  newsemantic(&semrec, tgttptr);
  semrec->UU.ttptr = parray;
  pushsemantic(semrec);
}  /* PushArray */


static void pushstream(flgaddtotable)
boolean flgaddtotable;
{
  /*action 16 PushStream*/
  /*stack              pops - nothing
                       pushes - TGTTPtr*/
  /*description
           Get a stream type table pointer.  Create a semantic record
           and save the type pointer in it. Push the semantic record.*/
  stentry *pstream;
  semanticrec *semrec;

  if (semtrace)
    printf("In PushStream\n");
  newttptr(&pstream, iftstream);
  if (flgaddtotable)
    putintable(&pstream);
  newsemantic(&semrec, tgttptr);
  semrec->UU.ttptr = pstream;
  pushsemantic(semrec);
}  /* PushStream */


static void pushrecord(flgaddtotable)
boolean flgaddtotable;
{
  /*action 17 PushRecord*/
  /*stack              pops - nothing
                       pushes - TGTTPtr*/
  /*description
           Get a record type table pointer.  Create a semantic record
           and save the type pointer in it. Push the semantic record.*/
  stentry *precord;
  semanticrec *semrec;

  if (semtrace) {
    printf("In PushRecord");
    if (flgaddtotable)
      printf(" and put in table\n");
    else
      printf(" and no put in table\n");
  }
  newttptr(&precord, iftrecord);
  if (flgaddtotable)
    putintable(&precord);
  newsemantic(&semrec, tgttptr);
  semrec->UU.ttptr = precord;
  pushsemantic(semrec);
}  /* PushRecord */


static void pushunion(flgaddtotable)
boolean flgaddtotable;
{
  /*action 19 PushUnion*/
  /*stack              pops - nothing
                       pushes - TGTTPtr*/
  /*description
           Get a union type table pointer.  Create a semantic record
           and save the type pointer in it. Push the semantic record.*/
  stentry *punion;
  semanticrec *semrec;

  if (semtrace)
    printf("In PushUnion\n");
  newttptr(&punion, iftunion);
  if (flgaddtotable)
    putintable(&punion);
  newsemantic(&semrec, tgttptr);
  semrec->UU.ttptr = punion;
  pushsemantic(semrec);
}  /* PushUnion */


static void pushnulltype()
{
  /*action 21 PushNullType*/
  /*stack              pops - nothing
                       pushes - TGTTPtr*/
  /*description
           Get a null type table pointer.  Create a semantic record
           and save the type pointer in it. Push the semantic record.*/
  stentry *pbasic;
  semanticrec *semrec;

  if (semtrace)
    printf("In PushNullType\n");
  newttptr(&pbasic, iftbasic);
  pbasic = getbasictype(ifbnull);
  newsemantic(&semrec, tgttptr);
  semrec->UU.ttptr = pbasic;
  pushsemantic(semrec);
}  /* PushNullType */


static void checktypename(inputtoken, line, column)
stryng inputtoken;
int line, column;
{
  /*action 14 CheckTypeName*/
  /*stack              pops - nothing
                       pushes - TGTTPtr or TGSymList*/
  /*description
          Search for type name in the symbol type.  If not found and
          we are type parsing the type def section, make an entry and
          put it on the undef type list.  If it is not found, but we
          are done with the type defs, then declare an error.  If the
          SymTab entries typeptr is nil, push the SymTabPtr else
          push the typeptr.*/
  semanticrec *semrec;
  symtblbucket *syname;
  treestackobj *level;
  errorrecord *errorrec;
  boolean undef;

  if (semtrace) {
    printf("In CheckTypeName, name = ");
    writestring(stdout, &inputtoken);
    putchar('\n');
  }
  undef = false;
  findname(inputtoken, ttype, &level, &syname);
  if (syname == NULL) {
    undef = true;
    syname = getsymtabentry(inputtoken, ttype);
    addref(syname, line, column);
    addtotable(syname, currentlevel);
  }
  if (typedefsfinished) {
    newsemantic(&semrec, tgttptr);
    if (undef) {
      errorrec = newerrorptr(tnameundef);
      errorrec->UU.errorstr = inputtoken;
      errorrec->linenumber = line;
      semerror(errorrec);
      syname->typeptr = getbasictype(ifbwild);
      semrec->UU.ttptr = syname->typeptr;
    } else if (syname->typeptr == NULL) {
      printf("***** COMPILER ERROR*****");
      writestring(stdout, &syname->name);
      printf("  type ptr is nil\n");
    } else {
      semrec->UU.ttptr = syname->typeptr;
      addref(syname, line, column);
    }
  } else {
    if (undef) {
      newsemantic(&semrec, tgsymptr);
      semrec->UU.symptr = syname;
    } else if (syname->typeptr == NULL) {
      addref(syname, line, column);
      newsemantic(&semrec, tgsymptr);
      semrec->UU.symptr = syname;
    } else {
      addref(syname, line, column);
      newsemantic(&semrec, tgttptr);
      semrec->UU.ttptr = syname->typeptr;
    }
  }  /* else */
  pushsemantic(semrec);

  /* then */
  /*else*/
}  /* CheckTypeName */


static void finishtypelinks()
{
  /*action 13 FinishTypeLinks*/
  /*stack              pops - TGTTPtr or TGSymTblPtr
                              TGSymTblPtr
                       pushes - Nothing*/
  /*description
          Since this routine can be called recursively, check that the
          Type Ptr for SemName^.symptr is nil.  Then if the top stack
          entry is a typeptr we now have a type def for SemName^.symptr.
          Fill in its typeptr and search its UndefTypeptr list.  The
          items on the list can be TypePtrs or SymPtrs, for TypePtrs,
          just fill in the TypePtr with the new structure; for SymPtrs
          call this routine recursively after pushing the info back on
          the stack.  Otherwise the top item on the stack was a SymPtr.
          In this case, add this SymPtr to the UndefTypeList of the
          "lower" SymPtr.  This was when the "lower" SymPtr has its
          type definded we will also fill in the other SymPtr's typeptr.*/
  semanticrec *rsemtorn, *rsemname, *semtorn, *semname;
  stentry *tptr;
  symtblbucket *sptr;
  tornrec *undeftypelist, *old, *tornelem;

  if (semtrace)
    printf("In FinishTypeLinks\n");
  semtorn = popsemantic();
  semname = popsemantic();
  if (semname->UU.symptr->typeptr == NULL)
  {   /*if Double Def, might not be nil*/
    if (semtorn->tag == tgttptr) {
      semname->UU.symptr->typeptr = semtorn->UU.ttptr;
      semname->UU.symptr->typeptr->stliteral = semname->UU.symptr->name;
      undeftypelist = semname->UU.symptr->UU.undeftypeptrs;
      if (undeftypelist != NULL) {
        semname->UU.symptr->UU.undeftypeptrs = NULL;
        while (undeftypelist != NULL) {
          switch (undeftypelist->torntag) {

          case typetag:
            tptr = undeftypelist->UU.ttptr;
            switch (tptr->stsort) {

            case iftmultiple:
            case iftarray:
            case iftstream:
              tptr->UU.stbasetype = semtorn->UU.ttptr;
              break;

            case iftfield:
            case ifttag:
            case ifttuple:
              tptr->UU.U2.stelemtype = semtorn->UU.ttptr;
              break;

            case iftbasic:
            case iftwild:
            case iftrecord:
            case iftfunctiontype:
            case iftunion:   /* This should never occur */
              break;
            }/* case */
            break;

          case symtag:
            sptr = undeftypelist->UU.symptr;
            newsemantic(&rsemtorn, tgttptr);
            newsemantic(&rsemname, tgsymptr);
            rsemtorn->UU.ttptr = semtorn->UU.ttptr;
            rsemname->UU.symptr = sptr;
            pushsemantic(rsemname);
            pushsemantic(rsemtorn);
            finishtypelinks();
            break;
          }/*case*/
          old = undeftypelist;
          undeftypelist = undeftypelist->next;
          freetornlist(&old);
        }  /* while */
      }  /*then*/
    }  /*then*/
    else {  /*have 2 names*/
      newtornlist(&tornelem, symtag);
      tornelem->UU.symptr = semname->UU.symptr;
      semtorn->UU.symptr->UU.undeftypeptrs = linktorntype(tornelem,
          semtorn->UU.symptr->UU.undeftypeptrs);
    }  /*else*/
  }  /*then*/
  freesemantic(&semtorn);
  freesemantic(&semname);
}  /* FinishTypeLinks */


static void linkbase()
{
  /*action 15 LinkBase*/
  /*stack              pops - TGTTPtr or TGSymPtr
                              TGTTPtr
                       pushes - TGTTPtr*/
  /*description
          If the first semantic record is a symbol table pointer then
          add the second type table structure to the Undef list
          else set the base type of the second type
          table pointer to be the first type table pointer. Push the
          remaining type table structure.*/
  semanticrec *tpsemrec, *nxtsemrec;
  tornrec *torn;

  if (semtrace)
    printf("In LinkBase\n");
  tpsemrec = popsemantic();
  nxtsemrec = popsemantic();
  switch (tpsemrec->tag) {

  case tgsymptr:
    newtornlist(&torn, typetag);
    torn->UU.ttptr = nxtsemrec->UU.ttptr;
    tpsemrec->UU.symptr->UU.undeftypeptrs = linktorntype(torn,
        tpsemrec->UU.symptr->UU.undeftypeptrs);
    break;

  case tgttptr:
    nxtsemrec->UU.ttptr->UU.stbasetype = tpsemrec->UU.ttptr;
    break;
  default:
     ;
  }/* case */
  pushsemantic(nxtsemrec);
  freesemantic(&tpsemrec);
}  /* LinkBase */


static void buildfort(ifttype, flgaddtotable)
char ifttype;
boolean flgaddtotable;
{
  semanticrec *typef, *namelist, *struct_;
  namelistrec *dump, *names;
  stentry *fort, *oldnames;
  boolean done;
  tornrec *torn;
  errorrecord *errorrec;

  typef = popsemantic();
  namelist = popsemantic();
  struct_ = popsemantic();
  names = namelist->UU.namelist;
  while (names != NULL) {
    newttptr(&fort, ifttype);
    if (flgaddtotable)
      putintable(&fort);
    fort->stliteral = names->name;
    switch (typef->tag) {

    case tgsymptr:
      newtornlist(&torn, typetag);
      torn->UU.ttptr = fort;
      typef->UU.symptr->UU.undeftypeptrs = linktorntype(torn,
          typef->UU.symptr->UU.undeftypeptrs);
      break;

    case tgttptr:
      fort->UU.U2.stelemtype = typef->UU.ttptr;
      break;
    default:
       ;
    }/* case */
    oldnames = struct_->UU.ttptr->UU.stbasetype;
    if (oldnames != NULL) {
      done = false;
      while (!done) {
        if (equalstrings(&names->name, &oldnames->stliteral)) {
          if (ifttype == iftfield) {
            errorrec = newerrorptr(fieldnameddef);
            errorrec->UU.errorstr = names->name;
            semerror(errorrec);
          } else {
            errorrec = newerrorptr(tagnameddef);
            errorrec->UU.errorstr = names->name;
            semerror(errorrec);
          }
        }  /* if */
        if (oldnames->UU.U2.stnext != NULL)
          oldnames = oldnames->UU.U2.stnext;
        else
          done = true;
      }  /* while */
      oldnames->UU.U2.stnext = fort;
    }  /* if */
    else
      struct_->UU.ttptr->UU.stbasetype = fort;
    dump = names;
    names = names->next;
    freenamelist(&dump);
  }  /* while */
  pushsemantic(struct_);
}  /* BuildForT */


static void buildfield(flgaddtotable)
boolean flgaddtotable;
{
  /*action 18 BuildField*/
  /*stack              pops - TGTTPtr or TGSymptr
                              TGNameList
                              TGTTPtr
                       pushes - TGTTPtr*/
  /*description
          Create a field with name on TGNameList and type of the
          first type table pointer.  If this type has not been defined
          yet, its SymPtr will be on the stack.  Then a pointer to the
          field's typeptr will be saved in the SymPtr entry to be filled
          in later.  Be sure name is distinct from all other names in
          this record. Push resulting record.*/
  if (semtrace) {
    printf("In BuildField");
    if (flgaddtotable)
      printf(" and add to table\n");
    else
      printf(" do not add to table\n");
  }
  buildfort(iftfield, flgaddtotable);
}


static void buildtag(flgaddtotable)
boolean flgaddtotable;
{
  /*action 20 BuildTag*/
  /*stack              pops - TGTTPtr or TGSymPtr
                              TGNameList
                              TGTTPtr
                       pushes - TGTTPtr*/
  /*description
          Create a tag with name on TGNameList and type of the
          first type table pointer.  If this type has not been defined
          yet, its SymPtr will be on the stack.  Then a pointer to the
          field's typeptr will be saved in the SymPtr entry to be filled
          in later.  Be sure name is distinct from all other names in
          this union. Push resulting union.*/
  if (semtrace)
    printf("In BuildTag\n");
  buildfort(ifttag, flgaddtotable);
}


static void starttypedefs()
{
  /*action 152  StartTypeDefs*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Init variables for type definition section.*/
  typedefsfinished = false;
}



static void endtypedefs()
{
  /*action 145  EndTypeDefs*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the symtbl for any type names whose type ptrs are
          still nil.  These types are undefined.  Make them type
          wild, declare and error and fill in all the typeptrs
          on their UndefTypeptrs list with type wild.  The symptrs
          on the list can be ignored because they will be found in
          the sym tab search.  Do a global type smash of the type
          table.  If the XRef flag is set, print out each type name
          and its structure.*/
  int i;
  symtblbucket *buck;
  errorrecord *errorrec;
  tornrec *tlist;

  if (semtrace)
    printf("In EndTypeDefs\n");
  for (i = 0; i <= maxhashtable; i++) {
    buck = currentlevel->hashtable[i];
    while (buck != NULL) {
      if (buck->identtag == ttype) {
        if (buck->UU.undeftypeptrs != NULL || buck->typeptr == NULL) {
          errorrec = newerrorptr(tnameundef);
          errorrec->UU.errorstr = buck->name;
          if (buck->references->front != NULL)
            errorrec->linenumber = buck->references->front->line;
          else if (buck->defloc->fline != -1)
            errorrec->linenumber = buck->defloc->fline;
          else
            errorrec->linenumber = linenumber;
          semerror(errorrec);
          buck->typeptr = getbasictype(ifbwild);
          tlist = buck->UU.undeftypeptrs;
          while (tlist != NULL) {
            if (tlist->torntag == typetag) {
              switch (tlist->UU.ttptr->stsort) {

              case iftmultiple:
              case iftarray:
              case iftstream:
                tlist->UU.ttptr->UU.stbasetype = getbasictype(ifbwild);
                break;

              case iftfield:
              case ifttag:
              case ifttuple:
                tlist->UU.ttptr->UU.U2.stelemtype = getbasictype(ifbwild);
                break;

              case iftbasic:
              case iftwild:
              case iftrecord:
              case iftfunctiontype:
              case iftunion:   /* This should never occur */
                break;
              default:
                 ;
              }/* case */
            }  /*then*/
            tlist = tlist->next;
          }  /*while*/
        }  /*then*/
      }  /*then*/
      buck = buck->nextbucket;
    }  /*while*/
  }  /*for*/
  smashtypes();
  adjustgraphptrs();
  for (i = 0; i <= maxhashtable; i++) {
    buck = currentlevel->hashtable[i];
    while (buck != NULL) {
      if (buck->identtag == ttype) {
        buck->typeptr = buck->typeptr->stequivchain;
        if (xref)
          addtoxref(buck);
      }
      buck = buck->nextbucket;
    }  /*while*/
  }  /*for*/
  if (xref) {
    /* printtypelist(); */
    idxrefmax = 0;
  }
  compacttypetable(&tthwm, 7);
  typedefsfinished = true;
}


static void smashintotable()
{
  /*action  8  SmashIntoTable*/
  /*stackpops - TgTTPtr
                  pushes - TgTTPtr*/
  /*description
          Pop the type table pointer off the stack and smash it into the
          type table.  Save the resulting type table pointer on the stack. */
  semanticrec *semttptr;
  stentry *tempptr;

  if (semtrace)
    printf("In SmashIntoTable\n");
  semttptr = popsemantic();
  tempptr = addtotypetable(semttptr->UU.ttptr);
  semttptr->UU.ttptr = tempptr;
  pushsemantic(semttptr);
}


static void startabuild()
{
  /*action 99 StartABuild*/
  /*stackpops - nothing
                  pushes - tgexplist
                           tgTTptr*/
  /*description
          Get an ABuild node and store it in an explist record and push the
          record on the stack.*/
  semanticrec *semexplist;

  if (semtrace)
    printf("begin StartABuild\n");
  newsemantic(&semexplist, tgexplist);
  semexplist->UU.explist = newexplistptr();
  semexplist->UU.explist->graphinfo->node_ = newnodeptr(ndatomic, currentlevel);
  semexplist->UU.explist->graphinfo->node_->ndsrcline = linenumber;
  semexplist->UU.explist->graphinfo->node_->ndcode = ifnabuild;
  linkparent(semexplist->UU.explist->graphinfo->node_, currentlevel);
  pushsemantic(semexplist);
}


static void dolowerbound()
{
  /*action 101 DoLowerBound*/
  /*stackpops - tgexplist  (for lower bound)
                         tgexplist  (for ABuild node)
                  pushes - tgexplist  (for ABuild node)*/
  /*description
          Check that arity of lower bound exp = 1 and that it's type is
          integer.  Connect the lower bound exp to port 1 of the ABuild
          node.  If the lower bound expression is nil then wire in a
          literal 1 on port 1.*/
  semanticrec *semexplb, *semexpabuild;
  errorrecord *errorrec;
  inforecord *lbexp;

  if (semtrace)
    printf("begin DoLowerBound\n");
  semexplb = popsemantic();
  semexpabuild = popsemantic();
  if (semexplb->UU.explist == NULL) {
    lbexp = newinfoptr();   /* set the LB to 1 */
    lbexp->typeptr = getbasictype(ifbinteger);
    string10(&lbexp->litvalue, "1         ");
  } else {
    lbexp = semexplb->UU.explist->graphinfo;
    if (semexplb->UU.explist->next != NULL) {
      errorrec = newerrorptr(lbarity);
      errorrec->linenumber = semexpabuild->UU.explist->graphinfo->node_->ndsrcline;
      semerror(errorrec);
    }
    if (lbexp->typeptr->stlabel != intlabel) {
      errorrec = newerrorptr(lbtype);
      errorrec->linenumber = semexpabuild->UU.explist->graphinfo->node_->ndsrcline;
      semerror(errorrec);
      lbexp = newinfoptr();
      lbexp->typeptr = getbasictype(ifbinteger);
      string10(&lbexp->litvalue, "1         ");
    }
  }  /*else*/
  semexpabuild->UU.explist->graphinfo->port_ = 1;
  addedge(lbexp, semexpabuild->UU.explist->graphinfo);
  pushsemantic(semexpabuild);
  if (semexplb->UU.explist == NULL) {
    /* push the empty list back so we have
                                       an empty list for the array elem. */
    pushsemantic(semexplb);
  } else
    freesemantic(&semexplb);
}


static void endabuild()
{
  /*action 102 EndABuild*/
  /*stackpops - tgexplist  (array elem)
                         tgexplist  (Abuild node)
                         tgTTptr    (type name)
                  pushes - tgexplist (Abuild node output)*/
  /*description
          If not array elem is given than a type name must be given.  Check
          that the type name is for an array.  If both a name and an array
          elem are given make sure the types are compatible.  If array elems
          are given, connect then to the ABuild node starting with port 2.
          Push the graph info for the output of the Abuild onto the stack.  */
  semanticrec *semexpaelem, *semexpabuild, *semttname, *semttatype;
  errorrecord *errorrec;
  stentry *atype;
  explistnode *element;
  int portnum;

  if (semtrace)
    printf("begin EndABuild\n");
  semexpaelem = popsemantic();
  semexpabuild = popsemantic();
  semttname = popsemantic();
  if (semexpaelem->UU.explist == NULL) {   /* no element is supplied */
    if (semttname->UU.ttptr == NULL) {   /* no type name is supplied */
      errorrec = newerrorptr(notypeabuild);
      errorrec->linenumber = semexpabuild->UU.explist->graphinfo->node_->ndsrcline;
      semerror(errorrec);
      pusharray(noaddtottable);
      semttatype = popsemantic();
      atype = semttatype->UU.ttptr;
      atype->UU.stbasetype = getbasictype(ifbwild);
      atype = addtotypetable(atype);
          /* we've made a new type, so smash it */
    }  /*then*/
    else {  /* type name is supplied */
      if (semttname->UU.ttptr->stsort != iftarray)
      {   /* name is not an array type */
        errorrec = newerrorptr(notarraytype);
        errorrec->linenumber = semexpabuild->UU.explist->graphinfo->node_->
                               ndsrcline;
        semerror(errorrec);
        pusharray(noaddtottable);
        semttatype = popsemantic();
        atype = semttatype->UU.ttptr;
        atype->UU.stbasetype = getbasictype(ifbwild);
        atype = addtotypetable(atype);
            /* we've made a new type, so smash it */
      } else  /* have OK name, no element */
        atype = semttname->UU.ttptr;
    }  /*else*/
  }  /*then*/
  else {  /* an element is supplied */
    if (semttname->UU.ttptr == NULL) {   /* no type name supplied */
      pusharray(noaddtottable);
      semttatype = popsemantic();
      atype = semttatype->UU.ttptr;
      atype->UU.stbasetype = semexpaelem->UU.explist->graphinfo->typeptr;
      atype = addtotypetable(atype);
          /* we've made a new type, so smash it */
    } else {  /* have a name and an element */
      if (semttname->UU.ttptr->stsort != iftarray)
      {   /* type name isn't an array */
        errorrec = newerrorptr(notarraytype);
        errorrec->linenumber = semexpabuild->UU.explist->graphinfo->node_->
                               ndsrcline;
        semerror(errorrec);
        pusharray(noaddtottable);
        semttatype = popsemantic();
        atype = semttatype->UU.ttptr;
        atype->UU.stbasetype = getbasictype(ifbwild);
        atype = addtotypetable(atype);
            /* we've made a new type, so smash it */
      } else {  /* Check name and elem types are the same */
        if (semttname->UU.ttptr->UU.stbasetype !=
            semexpaelem->UU.explist->graphinfo->typeptr) {
          errorrec = newerrorptr(arraytypeclash);
          errorrec->linenumber = semexpabuild->UU.explist->graphinfo->node_->
                                 ndsrcline;
          semerror(errorrec);
          pusharray(noaddtottable);
          semttatype = popsemantic();
          atype = semttatype->UU.ttptr;
          atype->UU.stbasetype = semexpaelem->UU.explist->graphinfo->typeptr;
          if (atype == NULL)
            printf("atype is NIL inside\n");
          atype = addtotypetable(atype);
              /*we've made a new type,so smash it*/
        }  /*then*/
        else
          atype = semttname->UU.ttptr;
      }  /*else*/
    }  /*else*/
    /* now AType hold the array type, we have an element so connect it */
    element = semexpaelem->UU.explist;
    portnum = 2;
    while (element != NULL) {
      semexpabuild->UU.explist->graphinfo->port_ = portnum;
      if (element->graphinfo->typeptr != atype->UU.stbasetype) {
        errorrec = newerrorptr(abuildelemtype);
        errorrec->UU.elemnum = portnum - 1;
        errorrec->linenumber = semexpabuild->UU.explist->graphinfo->node_->
                               ndsrcline;
        semerror(errorrec);
      }
      addedge(element->graphinfo, semexpabuild->UU.explist->graphinfo);
      element = element->next;
      portnum++;
    }  /*while*/
  }  /*else*/
  /* push Graph Info for output of ABuild */
  semexpabuild->UU.explist->graphinfo->port_ = 1;
  semexpabuild->UU.explist->graphinfo->typeptr = atype;
  pushsemantic(semexpabuild);
  freesemantic(&semexpaelem);
  freesemantic(&semttname);
}


static void doarrayindex()
{
  /*action 109 DoArrayIndex*/
  /*stackpops - tgexplist  (for indexing expression)
                         tgexplist  (for primary)
                  pushes - tgexplist  (for output of AElements)*/
  /*description
          Check that the type of <PRIMARY> is array and has arity = 1.
          Get an AElements and connect <PRIMARY> to it.  For each expression
          in the expression list, do the following:
          - Check that type of the expression is integer.
          - Connect the expression to the next input port in the AElements node.
          - Set the type of the output port to the base type of the last
            dimension indexed.
          - Save the graph info for the output port on the stack. */
  semanticrec *semindexexp, *semarray, *semttatype;
  errorrecord *errorrec;
  inforecord *agraphinfo;
  stentry *atype;
  inforecord *aelemgi;
  int portnum;
  explistnode *indexexp;

  if (semtrace)
    printf("begin DoArrayIndex\n");
  semindexexp = popsemantic();
  semarray = popsemantic();
  if (semarray->UU.explist->next != NULL) {
    errorrec = newerrorptr(arrayarity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    semarray->UU.explist->next = NULL;
  }
  if (semarray->UU.explist->graphinfo->typeptr == NULL) {
    pusharray(noaddtottable);
    semttatype = popsemantic();
    atype = semttatype->UU.ttptr;
    atype->UU.stbasetype = getbasictype(ifbwild);
    atype = addtotypetable(atype);   /* we've made a new type, so smash it */
    semarray->UU.explist->graphinfo->typeptr = atype;
  }
  if (semarray->UU.explist->graphinfo->typeptr->stsort != iftarray) {
    errorrec = newerrorptr(needarraytype);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    pusharray(noaddtottable);
    semttatype = popsemantic();
    atype = semttatype->UU.ttptr;
    atype->UU.stbasetype = getbasictype(ifbwild);
    atype = addtotypetable(atype);   /* we've made a new type, so smash it */
    semarray->UU.explist->graphinfo->typeptr = atype;
  } else
    atype = semarray->UU.explist->graphinfo->typeptr;
  agraphinfo = semarray->UU.explist->graphinfo;
  indexexp = semindexexp->UU.explist;
  portnum = 1;
  aelemgi = newinfoptr();   /*connect the array to port 1*/
  aelemgi->node_ = newnodeptr(ndatomic, currentlevel);
  aelemgi->node_->ndcode = ifnaelement;
  aelemgi->node_->ndsrcline = linenumber;
  linkparent(aelemgi->node_, currentlevel);
  aelemgi->port_ = 1;
  addedge(agraphinfo, aelemgi);
  while (indexexp != NULL) {
    portnum++;
    if (indexexp->graphinfo->typeptr == NULL)
      indexexp->graphinfo->typeptr = getbasictype(ifbwild);
    if (indexexp->graphinfo->typeptr->stlabel != intlabel) {
      errorrec = newerrorptr(indexexperr);
      errorrec->linenumber = linenumber;
      semerror(errorrec);
    }
    if (atype->stsort != iftarray) {
      errorrec = newerrorptr(needarraytype);
      errorrec->linenumber = linenumber;
      semerror(errorrec);
      indexexp->next = NULL;   /*End the while loop*/
    } else
      atype = atype->UU.stbasetype;
    aelemgi->port_ = portnum;
    addedge(indexexp->graphinfo, aelemgi);
    indexexp = indexexp->next;
    aelemgi->typeptr = atype;
  }  /*while*/
  aelemgi->port_ = 1;
  semarray->UU.explist->graphinfo = aelemgi;
  pushsemantic(semarray);
  freesemantic(&semindexexp);
}


static void doarrayreplace()
{
  /*action 110 DoArrayReplace*/
  /*stackpops - tgexplist  (element to replace)
                         tgexplist  (indices to replace at)
                         tgexplist  (array to replace them in)
                  pushes - tgexplist  (for replaced array)*/
  /*description
          Check that the graph info for array really has the type of array
          and it's arity should be 1.  Get an AReplaceN node for the first
          expression on list1.  Connect the ports as follows; input port 1
          = array, input port 2 = # of expressions in list1 (check that
          each's type is integer).  Connect each expression on list1 to the
          next input port on the AReplaceN.  Next check that the type of all
          the expressions on list2 are the same as the base type of the array.
          Connect them to the next available input ports.  Save the graphinfo
          for the output of the AReplaceN node on the stack.  The type should
          be the same as the type coming in on port 1.*/
  semanticrec *semlist1, *semlist2, *semarray, *semttatype;
  errorrecord *errorrec;
  inforecord *replacegi, *numindiceslit;
  int portnum;
  stentry *atype;
  explistnode *explist;

  if (semtrace)
    printf("Begin DoArrayReplace\n");
  semlist2 = popsemantic();
  semlist1 = popsemantic();
  semarray = popsemantic();
  if (semarray->UU.explist->next != NULL) {
    errorrec = newerrorptr(arityareplace);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    semarray->UU.explist->next = NULL;
  }  /*then*/
  if (semarray->UU.explist->graphinfo->typeptr == NULL) {
    pusharray(noaddtottable);
    semttatype = popsemantic();
    semttatype->UU.ttptr->UU.stbasetype = getbasictype(ifbwild);
    semarray->UU.explist->graphinfo->typeptr = addtotypetable(semttatype->UU.ttptr);
  }  /*then*/
  if (semarray->UU.explist->graphinfo->typeptr->stsort != iftarray) {
    errorrec = newerrorptr(typeareplace);
    errorrec->linenumber = linenumber;
    pusharray(noaddtottable);
    semttatype = popsemantic();
    semttatype->UU.ttptr->UU.stbasetype = getbasictype(ifbwild);
    semarray->UU.explist->graphinfo->typeptr = addtotypetable(semttatype->UU.ttptr);
  }  /*then*/
  replacegi = newinfoptr();
  replacegi->node_ = newnodeptr(ndatomic, currentlevel);
  replacegi->node_->ndsrcline = linenumber;
  replacegi->node_->ndcode = ifnareplacen;
  linkparent(replacegi->node_, currentlevel);
  replacegi->port_ = 1;
  replacegi->typeptr = semarray->UU.explist->graphinfo->typeptr;
  addedge(semarray->UU.explist->graphinfo, replacegi);
  portnum = 3;
  atype = semarray->UU.explist->graphinfo->typeptr;
  explist = semlist1->UU.explist;
  while (explist != NULL) {
    if (atype->stsort != iftarray) {
      errorrec = newerrorptr(replaceoverdim);
      errorrec->linenumber = linenumber;
      semerror(errorrec);
      explist = NULL;   /*end the loop*/
      continue;
    }
    atype = atype->UU.stbasetype;
    if (explist->graphinfo->typeptr == NULL)
      explist->graphinfo->typeptr = getbasictype(ifbwild);
    if (explist->graphinfo->typeptr->stlabel != intlabel) {
      errorrec = newerrorptr(indexexperr);
      errorrec->linenumber = linenumber;
      semerror(errorrec);
      explist->graphinfo = getalit1();
    }  /*then*/
    replacegi->port_ = portnum;
    addedge(explist->graphinfo, replacegi);
    portnum++;
    explist = explist->next;
  }  /*while*/
  numindiceslit = newinfoptr();
  numindiceslit->typeptr = getbasictype(ifbinteger);
  integerstring(&numindiceslit->litvalue, portnum - 3, 4);
  while (stringchar(&numindiceslit->litvalue, 1) == ' ')
    deletestring(&numindiceslit->litvalue, 1, 1);
  replacegi->port_ = 2;
  addedge(numindiceslit, replacegi);
  explist = semlist2->UU.explist;
  while (explist != NULL) {
    if (explist->graphinfo->typeptr != atype) {
      errorrec = newerrorptr(replaceelemtype);
      errorrec->linenumber = linenumber;
      semerror(errorrec);
    }
    replacegi->port_ = portnum;
    addedge(explist->graphinfo, replacegi);
    portnum++;
    explist = explist->next;
  }  /*while*/
  replacegi->port_ = 1;
  semarray->UU.explist->graphinfo = replacegi;
  pushsemantic(semarray);
  freesemantic(&semlist1);
  freesemantic(&semlist2);

  /*else*/
}


static void startsbuild()
{
  /*action 100 StartSBuild                                                     */
  /*stack           pops - nothing
                    pushes - TGNodePtr                                         */
  /* description
            Create an ABuild node. Wire a '1' to input port one.  push node on
           stack.                                                              */
  node *abnode;
  inforecord *lit, *toinfo;
  semanticrec *nsem;

  if (semtrace)
    printf("In StartSBuild \n");
  abnode = newnodeptr(ndatomic, currentlevel);
  abnode->ndcode = ifnabuild;
  abnode->ndsrcline = linenumber;
  linkparent(abnode, currentlevel);
  lit = newinfoptr();
  string10(&lit->litvalue, "1         ");
  stripspaces(&lit->litvalue);
  lit->typeptr = getbasictype(ifbinteger);
  toinfo = newinfoptr();
  toinfo->node_ = abnode;
  toinfo->port_ = 1;
  addedge(lit, toinfo);
  newsemantic(&nsem, tgnodeptr);
  nsem->UU.nodeptr = abnode;
  pushsemantic(nsem);
}


inforecord *createerr(stype)
stentry **stype;
{
  inforecord *info;

  info = newinfoptr();
  string10(&info->litvalue, "error     ");
  (*stype)->UU.stbasetype = getbasictype(ifbwild);
  *stype = addtotypetable(*stype);
  info->typeptr = *stype;
  return info;
}  /* CreateErr */


static void endsbuild(line, col)
int line, col;
{
  /*action  103 EndSBuild                                                     */
  /*stack           pops - TGExpList
                            TGNodePtr
                            TGTTPtr
                            TGTTPtr          */
  /*description
            Make sure that either the type name is not nil or the explist is
           not nil. If they are both not nil then make sure the base type of
           the stream is the same as the type of the expressions. Wire the
           expressions on consecutive input ports of the ABuild. Push the
           output graph info of the ABuild onto the stack.                     */
  semanticrec *expl, *abnodes, *stypes, *tnamep;
  explistnode *exp;
  node *abnode;
  stentry *stype, *ntype;
  inforecord *info, *toinfo;
  int port_;
  errorrecord *errorrec;

  if (semtrace)
    printf("In EndSBuild\n");
  expl = popsemantic();
  abnodes = popsemantic();
  stypes = popsemantic();
  tnamep = popsemantic();
  exp = expl->UU.explist;
  abnode = abnodes->UU.nodeptr;
  stype = stypes->UU.ttptr;
  if (exp == NULL) {
    if (tnamep->UU.ttptr == NULL) {
      errorrec = newerrorptr(nothingsc);
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
      info = createerr(&stype);
    }  /* if */
    else {
      if (tnamep->UU.ttptr->stsort != iftstream) {
        errorrec = newerrorptr(typenssc);
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
        info = createerr(&stype);
      }  /* if */
      else {
        info = newinfoptr();
        info->node_ = abnode;
        info->port_ = 1;
        info->typeptr = tnamep->UU.ttptr;
      }  /* else */
    }  /* else */
  }  /* if exp = nil */
  else {
    toinfo = newinfoptr();
    toinfo->node_ = abnode;
    port_ = 2;
    ntype = NULL;
    while (exp != NULL) {
      if (ntype == NULL)
        ntype = exp->graphinfo->typeptr;
      if (ntype != exp->graphinfo->typeptr) {
        errorrec = newerrorptr(expsnstypesc);
        errorrec->UU.expnum = port_ - 1;
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
        info = createerr(&stype);
      }  /* if */
      else {
        toinfo->port_ = port_;
        addedge(exp->graphinfo, toinfo);
      }  /* else */
      port_++;
      exp = exp->next;
    }  /* while */
    stype->UU.stbasetype = ntype;
    stype = addtotypetable(stype);
    if (tnamep->UU.ttptr != NULL) {
      if (tnamep->UU.ttptr != stype) {
        errorrec = newerrorptr(typeclashsc);
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
        stype = tnamep->UU.ttptr;
      }  /* if */
    }
    info = newinfoptr();
    info->node_ = abnode;
    info->port_ = 1;
    info->typeptr = stype;
  }  /* else exp <> nil */
  expl->UU.explist = newexplistptr();
  expl->UU.explist->graphinfo = info;
  pushsemantic(expl);
}


static void beforeexp()
{
  /*action 86 BeforeExp*/
  /*stackpops - nothing
                  pushes - tgpreclevel
                           tgexplist*/
  /*description
          Push an empty expression list (used to collect all the expressions
          because the arity may be greater than 1).  Also push a precedence
          level rec with preclevel = -1, this is used to force total reduction
          of the expression, -1 is lower than the prec level of any operator. */
  semanticrec *semexplist, *sempreclevel;

  if (semtrace)
    printf("Begin BeforeExp\n");
  newsemantic(&semexplist, tgexplist);
  newsemantic(&sempreclevel, tgpreclevel);
  sempreclevel->UU.U5.preclevel = -1;
  pushsemantic(semexplist);
  pushsemantic(sempreclevel);
}


static void incboostfac()
{
  /*action 87 IncBoostFac*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          We have seen a ( so increase the Boost Factor by 10.*/
  if (semtrace)
    printf("Begin IncBoostFac\n");
  boostfac += 10;
}


static void decboostfac()
{
  /*action 88 DecBoostFac*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          We have seen a rt paran so decrement the BoostFactor by 10.*/
  if (semtrace)
    printf("Begin DecBoostFac\n");
  boostfac -= 10;
}


static void buildunarynode(exp1list, oper, line)
explistnode *exp1list;
opertype oper;
int line;
{
  explistnode *expresult;
  semanticrec *semexplist;
  errorrecord *errorrec;
  inforecord *exp;

  if (semtrace)
    printf("Begin BuildUnaryNode\n");
  if (exp1list->next != NULL) {   /* check that arity is 1 */
    errorrec = newerrorptr(unaryoparity);
    errorrec->UU.op = oper;
    errorrec->linenumber = line;
    semerror(errorrec);
  }
  exp = exp1list->graphinfo;
  expresult = newexplistptr();
  /*  Check that the type of expression is valid for this operation  */
  switch (oper) {

  case uplus:
    if ((unsigned)exp->typeptr->stlabel >= 32 ||
        ((1L << exp->typeptr->stlabel) & arithtypes) == 0) {
      errorrec = newerrorptr(unarytypeerr);
      errorrec->UU.U31.uop = oper;
      errorrec->UU.U31.utypeptr = exp->typeptr;
      semerror(errorrec);
    }  /*then*/
    break;

  case uminus:
    if ((unsigned)exp->typeptr->stlabel >= 32 ||
        ((1L << exp->typeptr->stlabel) & arithtypes) == 0) {
      errorrec = newerrorptr(unarytypeerr);
      errorrec->UU.U31.uop = oper;
      errorrec->UU.U31.utypeptr = exp->typeptr;
      semerror(errorrec);
    }  /*then*/
    expresult->graphinfo->node_ = newnodeptr(ndatomic, currentlevel);
    expresult->graphinfo->port_ = 1;
    expresult->graphinfo->node_->ndsrcline = line;
    linkparent(expresult->graphinfo->node_, currentlevel);
    expresult->graphinfo->node_->ndcode = ifnneg;
    expresult->graphinfo->typeptr = exp->typeptr;
    break;

  case unot:
    if (exp->typeptr->stlabel != boollabel) {
      errorrec = newerrorptr(unarytypeerr);
      errorrec->UU.U31.uop = oper;
      errorrec->UU.U31.utypeptr = exp->typeptr;
      semerror(errorrec);
    }  /*then*/
    expresult->graphinfo->node_ = newnodeptr(ndatomic, currentlevel);
    expresult->graphinfo->port_ = 1;
    expresult->graphinfo->node_->ndsrcline = line;
    linkparent(expresult->graphinfo->node_, currentlevel);
    expresult->graphinfo->node_->ndcode = ifnnot;
    expresult->graphinfo->typeptr = getbasictype(ifbboolean);
    break;
  default:
     ;
  }/*case*/
  newsemantic(&semexplist, tgexplist);
  if (oper != uplus) {
    addedge(exp, expresult->graphinfo);
    semexplist->UU.explist = expresult;
  }  /*then*/
  else
    semexplist->UU.explist = exp1list;
  /*uplus doesn't generate a node
                                             so just push the input info */
  pushsemantic(semexplist);
}  /*BuildUnaryNode*/

static void buildbinarynode(exp1list, exp2list, oper, line)
explistnode *exp1list, *exp2list;
opertype oper;
int line;
{
  inforecord *exp1, *exp2;
  explistnode *expresult;
  semanticrec *semexplist;
  errorrecord *errorrec;

  if (semtrace)
    printf("begin BuildBinaryNode\n");
  /* Check arity of exps are 1 */
  if (exp1list->next != NULL || exp2list->next != NULL) {
    errorrec = newerrorptr(binaryoparity);
    errorrec->UU.op = oper;
    errorrec->linenumber = line;
    semerror(errorrec);
  }
  exp1 = exp1list->graphinfo;
  exp2 = exp2list->graphinfo;
  if (exp1->typeptr != exp2->typeptr) {   /* types much be equal */
    errorrec = newerrorptr(binarytypesnoteq);
    errorrec->UU.op = oper;
    errorrec->linenumber = line;
    semerror(errorrec);
  }
  /* Check that the types of the expressions are valid for the operation */
  switch (oper) {

  case plus:
  case minus:
  case mult:
  case divd:
    if ((unsigned)exp1->typeptr->stlabel >= 32 ||
        ((1L << exp1->typeptr->stlabel) & arithtypes) == 0 ||
        (unsigned)exp2->typeptr->stlabel >= 32 ||
        ((1L << exp2->typeptr->stlabel) & arithtypes) == 0) {
      errorrec = newerrorptr(binarytypeerr);
      errorrec->UU.U18.bop = oper;
      errorrec->UU.U18.btypeptr = exp1->typeptr;
      errorrec->linenumber = line;
      semerror(errorrec);
    }  /*then*/
    break;

  case concat:
    if (((1L << exp1->typeptr->stsort) & streamorarray) == 0 ||
        ((1L << exp2->typeptr->stsort) & streamorarray) == 0) {
      errorrec = newerrorptr(binarytypeerr);
      errorrec->UU.U18.bop = oper;
      errorrec->UU.U18.btypeptr = exp1->typeptr;
      errorrec->linenumber = line;
      semerror(errorrec);
    }  /*then*/
    break;

  case lt:
  case le:
  case gt:
  case ge:
    if ((unsigned)exp1->typeptr->stlabel >= 32 ||
        ((1L << exp1->typeptr->stlabel) & (arithtypes | (1L << charlabel))) == 0 ||
        (unsigned)exp2->typeptr->stlabel >= 32 ||
        ((1L << exp2->typeptr->stlabel) & (arithtypes | (1L << charlabel))) == 0) {
      errorrec = newerrorptr(binarytypeerr);
      errorrec->UU.U18.bop = oper;
      errorrec->UU.U18.btypeptr = exp1->typeptr;
      errorrec->linenumber = line;
      semerror(errorrec);
    }  /*then*/
    break;

  case orop:
  case andop:
    if (exp1->typeptr->stlabel != boollabel ||
        exp2->typeptr->stlabel != boollabel) {
      errorrec = newerrorptr(binarytypeerr);
      errorrec->UU.U18.bop = oper;
      errorrec->UU.U18.btypeptr = exp1->typeptr;
      errorrec->linenumber = line;
      semerror(errorrec);
    }  /*then*/
    break;

  case equal:
  case notequal:
    if ((unsigned)exp1->typeptr->stlabel >= 32 ||
        ((1L << exp1->typeptr->stlabel) & (algebtypes | (1L << charlabel))) == 0 ||
        (unsigned)exp2->typeptr->stlabel >= 32 ||
        ((1L << exp2->typeptr->stlabel) & (algebtypes | (1L << charlabel))) == 0) {
      errorrec = newerrorptr(binarytypeerr);
      errorrec->UU.U18.bop = oper;
      errorrec->UU.U18.btypeptr = exp1->typeptr;
      errorrec->linenumber = line;
      semerror(errorrec);
    }
    break;
  default:
     ;
  }/*case*/
  expresult = newexplistptr();
  expresult->graphinfo->node_ = newnodeptr(ndatomic, currentlevel);
  expresult->graphinfo->port_ = 1;
  expresult->graphinfo->node_->ndsrcline = line;
  linkparent(expresult->graphinfo->node_, currentlevel);
  switch (oper) {

  case plus:
    expresult->graphinfo->node_->ndcode = ifnplus;
    expresult->graphinfo->typeptr = exp1->typeptr;
    break;

  case minus:
    expresult->graphinfo->node_->ndcode = ifnminus;
    expresult->graphinfo->typeptr = exp1->typeptr;
    break;

  case mult:
    expresult->graphinfo->node_->ndcode = ifntimes;
    expresult->graphinfo->typeptr = exp1->typeptr;
    break;

  case divd:
    expresult->graphinfo->node_->ndcode = ifndiv;
    expresult->graphinfo->typeptr = exp1->typeptr;
    break;

  case concat:
    expresult->graphinfo->node_->ndcode = ifnacatenate;
    expresult->graphinfo->typeptr = exp1->typeptr;
    break;

  case lt:
    expresult->graphinfo->node_->ndcode = ifnless;
    expresult->graphinfo->typeptr = getbasictype(ifbboolean);
    break;

  case le:
    expresult->graphinfo->node_->ndcode = ifnlessequal;
    expresult->graphinfo->typeptr = getbasictype(ifbboolean);
    break;

  case gt:
    expresult->graphinfo->node_->ndcode = ifnlessequal;
    expresult->graphinfo->typeptr = getbasictype(ifbboolean);
    break;

  case ge:
    expresult->graphinfo->node_->ndcode = ifnless;
    expresult->graphinfo->typeptr = getbasictype(ifbboolean);
    break;

  case andop:
    expresult->graphinfo->node_->ndcode = ifntimes;
    expresult->graphinfo->typeptr = getbasictype(ifbboolean);
    break;

  case orop:
    expresult->graphinfo->node_->ndcode = ifnplus;
    expresult->graphinfo->typeptr = getbasictype(ifbboolean);
    break;

  case equal:
    expresult->graphinfo->node_->ndcode = ifnequal;
    expresult->graphinfo->typeptr = getbasictype(ifbboolean);
    break;

  case notequal:
    expresult->graphinfo->node_->ndcode = ifnnotequal;
    expresult->graphinfo->typeptr = getbasictype(ifbboolean);
    break;
  default:
     ;
  }/*case*/
  addedge(exp2, expresult->graphinfo);
  expresult->graphinfo->port_ = 2;
  addedge(exp1, expresult->graphinfo);
  expresult->graphinfo->port_ = 1;   /*now work with output port 1*/
  /* > and >= need a NOT node since they are built with  <= and < */
  if (oper == gt || oper == ge) {
    buildunarynode(expresult, unot, line);
    return;
  }
  newsemantic(&semexplist, tgexplist);
  semexplist->UU.explist = expresult;
  pushsemantic(semexplist);

  /*else*/
}  /*BuildBinaryNode*/


boolean Reduce()
{
  /* This function checks the precedence of the top 2 operations on the
     stack.  If the one lower on the stack has higher or equal precedence,
     then its node it output, otherwise nothing happens.  The boolean value
     returned tells whether a reduction occured or not.  If one did occur
     others operation nodes may also need to be built.  False is returned
     to denote that the expression may not be fully reduced.*/
  boolean Result;
  semanticrec *oper1, *exp1, *oper2, *exp2;

  if (semtrace)
    printf("begin Reduce\n");
  oper1 = popsemantic();
  exp1 = popsemantic();
  oper2 = popsemantic();
  /*  If operation lower on stack has lower precedence then do nothing and return
      true otherwise output that operation.*/
  if (oper2->UU.U5.preclevel < oper1->UU.U5.preclevel) {
    Result = true;
    pushsemantic(oper2);
    pushsemantic(exp1);
    pushsemantic(oper1);
    return Result;
  }  /*then*/
  else {
    if (exp1->UU.explist->graphinfo->typeptr == NULL)
      exp1->UU.explist->graphinfo->typeptr = getbasictype(ifbwild);
    if (((1L << ((long)oper2->UU.U5.operation)) & binaryops) != 0) {
      exp2 = popsemantic();
      if (exp2->UU.explist->graphinfo->typeptr == NULL)
        exp2->UU.explist->graphinfo->typeptr = getbasictype(ifbwild);
      buildbinarynode(exp1->UU.explist, exp2->UU.explist,
                      oper2->UU.U5.operation, oper2->UU.U5.line);
      pushsemantic(oper1);
      freesemantic(&exp1);
      freesemantic(&oper2);
      freesemantic(&exp2);
      return false;
    }  /*then*/
    buildunarynode(exp1->UU.explist, oper2->UU.U5.operation,
                   oper2->UU.U5.line);
    pushsemantic(oper1);
    freesemantic(&oper2);
    freesemantic(&exp1);
    return false;
  }  /*else*/

}  /*Reduce*/


static void reduceexp()
{
  /*action 89 ReduceExp*/
  /*stackpops - All tgexplist and tgpreclevel down to tgpreclevel
                         with preclevel < current boost factor.
                  pushes - tgexplist*/
  /*description
          Push the current boost factor on the stack and call Reduce.  This
          will cause all operator with precedence levels > the pushed
          boost factor to be generated.  Then pop off the tgprcelevel
          on the top of the stack.*/
  boolean reduced;
  semanticrec *semboostfac;

  if (semtrace)
    printf("Begin ReduceExp\n");
  newsemantic(&semboostfac, tgpreclevel);
  semboostfac->UU.U5.preclevel = boostfac;
  pushsemantic(semboostfac);
  reduced = false;
  while (!reduced)
    reduced = Reduce();
  semboostfac = popsemantic();
  freesemantic(&semboostfac);
}


static void afterexp()
{
  /*action 91 AfterExp*/
  /*stackpops - tgexplist (single expression)
                         tgpreclevel
                         tgexplist (expression list)
                  pushes - tgpreclevel
                           tgexplist*/
  /*description
          Add the single expression's graphinfo to the end of the expression
          list.  Push the new list and the preclevel back on the stack.  This
          is how expressions of arity > 1 are collected.*/
  semanticrec *semexp, *sempreclevel, *semexplist;

  if (semtrace)
    printf("Begin AfterExp\n");
  semexp = popsemantic();
  sempreclevel = popsemantic();
  semexplist = popsemantic();
  addtoexplist(&semexplist->UU.explist, semexp->UU.explist);
  freesemantic(&semexp);
  pushsemantic(semexplist);
  pushsemantic(sempreclevel);
}


static void aftersimpexp()
{
  /*action 144 AfterSimpExp*/
  /*stackpops - tgexplist (single expression)
                         tgpreclevel
                         tgexplist (expression list)
                  pushes - tgexplist*/
  /*description
          Add the single expression's graphinfo to the end of the expression
          list.  Same as AfterExp accept the preclevel isn't pushed back
          on to the stack.  This is becasue a simple expression will only
          have arity one, so we know the whole expression is done at this
          point.  The preclevel is needed on the stack to separate expressions
          that are separated by commas.*/
  semanticrec *semexp, *sempreclevel, *semexplist;

  if (semtrace)
    printf("Begin AfterSimpExp\n");
  semexp = popsemantic();
  sempreclevel = popsemantic();
  semexplist = popsemantic();
  addtoexplist(&semexplist->UU.explist, semexp->UU.explist);
  freesemantic(&semexp);
  freesemantic(&sempreclevel);
  pushsemantic(semexplist);
}


static void dobinaryop(token, line, col)
int token, line, col;
{
  /*action 112 DoBinaryOp*/
  /*stackpops - nothing
                  pushes - tgpreclevel*/
  /*description
          Push the operator and it's precedence level on the stack.*/
  semanticrec *sempreclevel;
  boolean reduced;

  if (semtrace)
    printf("begin DoBinaryOp\n");
  reduced = false;
  newsemantic(&sempreclevel, tgpreclevel);
  sempreclevel->UU.U5.line = line;
  sempreclevel->UU.U5.column = col;
  switch (token) {

  case 1:
    sempreclevel->UU.U5.operation = andop;
    sempreclevel->UU.U5.preclevel = boostfac + 2;
    break;

  case 4:
    sempreclevel->UU.U5.operation = mult;
    sempreclevel->UU.U5.preclevel = boostfac + 7;
    break;

  case 5:
    sempreclevel->UU.U5.operation = plus;
    sempreclevel->UU.U5.preclevel = boostfac + 6;
    break;

  case 7:
    sempreclevel->UU.U5.operation = minus;
    sempreclevel->UU.U5.preclevel = boostfac + 6;
    break;

  case 9:
    sempreclevel->UU.U5.operation = divd;
    sempreclevel->UU.U5.preclevel = boostfac + 7;
    break;

  case 18:
    sempreclevel->UU.U5.operation = equal;
    sempreclevel->UU.U5.preclevel = boostfac + 4;
    break;

  case 74:
    sempreclevel->UU.U5.operation = ge;
    sempreclevel->UU.U5.preclevel = boostfac + 4;
    break;

  case 75:
    sempreclevel->UU.U5.operation = gt;
    sempreclevel->UU.U5.preclevel = boostfac + 4;
    break;

  case 76:
    sempreclevel->UU.U5.operation = le;
    sempreclevel->UU.U5.preclevel = boostfac + 4;
    break;

  case 77:
    sempreclevel->UU.U5.operation = lt;
    sempreclevel->UU.U5.preclevel = boostfac + 4;
    break;

  case 79:
    sempreclevel->UU.U5.operation = notequal;
    sempreclevel->UU.U5.preclevel = boostfac + 4;
    break;

  case 80:
    sempreclevel->UU.U5.operation = orop;
    sempreclevel->UU.U5.preclevel = boostfac + 1;
    break;

  case 81:
    sempreclevel->UU.U5.operation = concat;
    sempreclevel->UU.U5.preclevel = boostfac + 5;
    break;
  }/*case*/
  pushsemantic(sempreclevel);
  while (!reduced)
    reduced = Reduce();
}


static void poppreclevel()
{
  /*action 90 PopPrecLevel*/
  /*stackpops tgpreclevel
                  pushes - nothing*/
  /*description
          Pops a tgpreclevel off the stack.  This is the one pushed by
          BeforeExp.*/
  semanticrec *sempreclevel;

  sempreclevel = popsemantic();
  freesemantic(&sempreclevel);
}


static void findfieldname(name, fields, found, place)
stryng name;
stentry **fields;
boolean *found;
int *place;
{
  stryng name1, name2;

  name1 = name;
  stringlowercase(&name1);
  *found = false;
  *place = 1;
  while (!*found && *fields != NULL) {
    (*place)++;
    name2 = (*fields)->stliteral;
    stringlowercase(&name2);
    if (equalstrings(&name1, &name2))
      *found = true;
    else
      *fields = (*fields)->UU.U2.stnext;
  }  /* while */
}  /* FindFieldName */


inforecord *createerrlit()
{
  inforecord *info;

  info = newinfoptr();
  string10(&info->litvalue, "error     ");
  info->typeptr = getbasictype(ifbwild);
  return info;
}  /* CreateErrLit */


static void dofieldlist(line, col)
int line, col;
{
  /*action 92 DoFieldList                                                     */
  /*stack             pops - TGNameList
                             TGExpList
                      pushes - TGExpList                                      */
  /* description
          For each name on the list make sure it is a field of the current
         record. Create a relements node. Select the output corresponding
         to the name.  Push the output info for the last name.               */
  semanticrec *namel, *expl;
  namelistrec *name;
  explistnode *exp;
  inforecord *info, *toinfo;
  boolean found;
  int place;
  stentry *fields;
  node *renode;
  errorrecord *errorrec;

  if (semtrace)
    printf("In DoFieldList \n");
  namel = popsemantic();
  expl = popsemantic();
  name = namel->UU.namelist;
  exp = expl->UU.explist;
  if (exp->next != NULL) {
    exp->next = NULL;
    errorrec = newerrorptr(arityonrselect);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort != iftrecord) {
    info = createerrlit();
    errorrec = newerrorptr(etypeonrs);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  } else {
    info = exp->graphinfo;
    while (name != NULL) {
      fields = info->typeptr->UU.stbasetype;
      findfieldname(name->name, &fields, &found, &place);
      if (!found) {
        info = createerrlit();
        errorrec = newerrorptr(nameundrs);
        errorrec->UU.errorstr = name->name;
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
        name = NULL;
        continue;
      }  /* if */
      if (name->next != NULL && fields->UU.U2.stelemtype->stsort != iftrecord) {
        info = createerrlit();
        errorrec = newerrorptr(ntypeonrs);
        errorrec->UU.errorstr = name->name;
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
        name = NULL;
        continue;
      }  /* else if */
      renode = newnodeptr(ndatomic, currentlevel);
      renode->ndcode = ifnrelements;
      renode->ndsrcline = line;
      linkparent(renode, currentlevel);
      toinfo = newinfoptr();
      toinfo->node_ = renode;
      toinfo->port_ = 1;
      addedge(info, toinfo);
      info = newinfoptr();
      info->node_ = renode;
      info->port_ = place - 1;
      info->typeptr = fields->UU.stbasetype;
      name = name->next;
    }  /* while */
  }  /* else */
  exp->graphinfo = info;
  pushsemantic(expl);

  /* else */
}  /* DoFieldList */


static void startrbuild()
{
  /*action 95 StartRBuild                                                     */
  /*stack             pops - nothing
                      pushes - TGExpList                                      */
  /*description
           Create a RBuild node. Push it's graph information onto the stack.  */
  node *rbuildnode;
  semanticrec *sem;
  inforecord *info;
  explistnode *nexp;

  if (semtrace)
    printf("In StartRBuild \n");
  rbuildnode = newnodeptr(ndatomic, currentlevel);
  rbuildnode->ndcode = ifnrbuild;
  rbuildnode->ndsrcline = linenumber;
  linkparent(rbuildnode, currentlevel);
  info = newinfoptr();
  info->node_ = rbuildnode;
  info->port_ = 1;
  nexp = newexplistptr();
  nexp->graphinfo = info;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = nexp;
  pushsemantic(sem);
}


static void buildfieldlist(line, col)
int line, col;
{
  /*action 97 BuildFieldList                                                  */
  /*stack             pops - TGExpList
                             TGNameList
                             TGExpList
                             TGTTPtr
                      pushes - TGExpList                                      */
  /* description
           Create a new field of the record with type from explist and name
          from namelist.  Make sure the name is unique in this record. Connec
          expression to the next input port of the RBuild. Push the RBuild
          graph inof onto the stack.                                          */
  semanticrec *expl, *namel, *rnode, *ttstruct, *tsem;
  errorrecord *errorrec;

  if (semtrace)
    printf("In BuildFieldList \n");
  expl = popsemantic();
  namel = popsemantic();
  rnode = popsemantic();
  ttstruct = popsemantic();
  if (expl->UU.explist->next != NULL) {
    expl->UU.explist->next = NULL;
    errorrec = newerrorptr(arityonrbuild);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if*/
  newsemantic(&tsem, tgttptr);
  tsem->UU.ttptr = expl->UU.explist->graphinfo->typeptr;
  pushsemantic(ttstruct);
  pushsemantic(namel);
  pushsemantic(tsem);
  buildfield(noaddtottable);
  addedge(expl->UU.explist->graphinfo, rnode->UU.explist->graphinfo);
  rnode->UU.explist->graphinfo->port_++;
  pushsemantic(rnode);
}


static void endrbuild(line, col)
int line, col;
{
  /*action 98 EndRBuild                                                       */
  /*stack             pops - TGExpList
                             TGTTPtr
                             TGTTPtr
                      pushes - TGExpList                                      */
  /* description
           Smash the record stucture into the type table. If the type name
          pointer is not nil then the pointer returned from the samsh must
          be equal to the type name pointer else error.  Save the output graph
          info of the RBuild node on the stack.                               */
  semanticrec *rnode, *ttstruct, *tnamel;
  errorrecord *errorrec;
  stentry *intable;

  if (semtrace)
    printf("In EndRBuild \n");
  rnode = popsemantic();
  ttstruct = popsemantic();
  tnamel = popsemantic();
  intable = addtotypetable(ttstruct->UU.ttptr);
  if (tnamel->UU.ttptr != NULL) {
    if (tnamel->UU.ttptr != intable) {
      errorrec = newerrorptr(typeonrbuild);
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
    }  /* if */
  }
  rnode->UU.explist->graphinfo->typeptr = intable;
  rnode->UU.explist->graphinfo->port_ = 1;
  pushsemantic(rnode);
}


static void pushniltag()
{
  /*action  105  PushNilTag                                                    */
  /*stack            pops - nothing
                    pushes - TGExpList                                        */
  /*description
          Create a nil tag type stucture and push it on the stack.            */
  semanticrec *sem;
  explistnode *exp;
  inforecord *info;

  if (semtrace)
    printf("In PushNilTag \n");
  exp = newexplistptr();
  info = newinfoptr();
  info->typeptr = getbasictype(ifbnull);
  string10(&info->litvalue, "nil       ");
  exp->graphinfo = info;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}


static void builderrunion(expl, namel, tnt)
semanticrec *expl, *namel, **tnt;
{
  semanticrec *ntsem;

  pushunion(noaddtottable);
  pushsemantic(namel);
  newsemantic(&ntsem, tgttptr);
  ntsem->UU.ttptr = expl->UU.explist->graphinfo->typeptr;
  pushsemantic(ntsem);
  buildtag(noaddtottable);
  ntsem = popsemantic();
  (*tnt)->UU.ttptr = addtotypetable(ntsem->UU.ttptr);
}  /* BuildErrUnion */


static void endubuild(line, col)
int line, col;
{
  /*action  106  EndUBuild                                                    */
  /*stack              pops - TGExpList
                              TGNameList
                              TGTTPtr
                       pushes - TGExpList                                     */
  /* description
           Make sure the type is a union. Search for the name on the tag list
          of the union.  If it is not there then error.  Check that found tag
          has the same type as expression. Connect the expression to the input
          port of the RBuild node corresponding to the correct tag. Push the
          output graph info of the RBuild node.                               */
  semanticrec *expl, *namel, *tnt;
  stentry *tags;
  boolean found;
  int place;
  stryng name1, name2;
  inforecord *rinfo, *ininfo, *toinfo;
  node *ubuildnode;
  errorrecord *errorrec;

  if (semtrace)
    printf(" In EndUBuild\n");
  expl = popsemantic();
  namel = popsemantic();
  tnt = popsemantic();
  if (expl->UU.explist->next != NULL) {
    expl->UU.explist->next = NULL;
    errorrec = newerrorptr(arityonubuild);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if */
  if (tnt->UU.ttptr == getbasictype(ifbwild))
    builderrunion(expl, namel, &tnt);
  if (tnt->UU.ttptr->stsort != iftunion) {
    errorrec = newerrorptr(tnonubuild);
    errorrec->UU.errorstr = namel->UU.namelist->name;
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
    builderrunion(expl, namel, &tnt);
  }  /* if */
  name1 = namel->UU.namelist->name;
  stringlowercase(&name1);
  tags = tnt->UU.ttptr->UU.stbasetype;
  found = false;
  place = 0;
  while (!found) {
    place++;
    name2 = tags->stliteral;
    stringlowercase(&name2);
    if (equalstrings(&name1, &name2)) {
      found = true;
      break;
    }
    tags = tags->UU.U2.stnext;
    if (tags == NULL) {
      found = true;
      place = 0;
    }  /* if */
  }  /* while */
  if (place == 0) {
    rinfo = newinfoptr();
    string10(&rinfo->litvalue, "error     ");
    rinfo->typeptr = tnt->UU.ttptr;
    errorrec = newerrorptr(undeftagub);
    errorrec->UU.errorstr = namel->UU.namelist->name;
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if */
  else {
    ubuildnode = newnodeptr(ndatomic, currentlevel);
    ubuildnode->ndcode = ifnrbuild;
    linkparent(ubuildnode, currentlevel);
    ininfo = newinfoptr();
    if (expl->UU.explist->graphinfo->typeptr != tags->UU.U2.stelemtype) {
      string10(&ininfo->litvalue, "error     ");
      ininfo->typeptr = tags->UU.U2.stelemtype;
      errorrec = newerrorptr(typeclashub);
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
    }  /* if */
    else
      ininfo = expl->UU.explist->graphinfo;
    toinfo = newinfoptr();
    toinfo->node_ = ubuildnode;
    toinfo->port_ = place;
    addedge(ininfo, toinfo);
    rinfo = newinfoptr();
    rinfo->node_ = ubuildnode;
    rinfo->port_ = 1;
    rinfo->typeptr = tnt->UU.ttptr;
  }  /* else */
  expl->UU.explist->graphinfo = rinfo;
  pushsemantic(expl);

  /* else */
}  /* EndUBuild */


static void pushinfolist(infol, newinfo)
ilistrec **infol;
inforecord *newinfo;
{
  ilistrec *newl;

  newl = (ilistrec *)Malloc(sizeof(ilistrec));
  newl->graphinfo = newinfo;
  newl->next = *infol;
  *infol = newl;
}  /* PushInfoList */

static inforecord *popinfolist(infol)
ilistrec **infol;
{
  inforecord *Result;

  Result = (*infol)->graphinfo;
  *infol = (*infol)->next;
  return Result;
}  /* PopInfoList */

static void pushpositionlist(positionl, newpos)
plistrec **positionl;
int newpos;
{
  plistrec *newl;

  newl = (plistrec *)Malloc(sizeof(plistrec));
  newl->position = newpos;
  newl->next = *positionl;
  *positionl = newl;
}  /* PushPositionList */

static int poppositionlist(positionl)
plistrec **positionl;
{
  int Result;

  Result = (*positionl)->position;
  *positionl = (*positionl)->next;
  return Result;
}  /* PopPositionList */


static void buildreplace(line, col)
int line, col;
{  /* Build Replace */
  /*action  111  BuildReplace                                                 */
  /*stack              pops - TGExpList
                              TGNameList
                              TGExpList
                       pushes - TGExpList                                     */
  /* description
           For each name on the name list except for last one:
                - make sure the current type is a record
                - search for name as a field of that record
                - create a RElements node, record as input to port one
                - extract name from RElements node, make this the current type
                - save RElements graphinfo and location of name in record
           For last name
                - make sure the current type is a record
                - search for name as a field of that record
                - check that expression is of the same type as field
                - create a RReplace node, express input to corresponding port
           While saved lists are not nil
                - Build an RReplace node
                - connect graphinfo to node at port location
           push last output info on to stack */
  semanticrec *rexpl, *namel, *oexpl;
  explistnode *rexp, *oexp;
  namelistrec *names;
  inforecord *cinfo, *toinfo, *frinfo;
  stentry *fields, *save;
  boolean found, error;
  node *renode, *rrnode;
  int place;
  plistrec *positionl;
  ilistrec *infol;
  errorrecord *errorrec;

  if (semtrace)
    printf("In BuildReplace \n");
  positionl = NULL;
  infol = NULL;
  rexpl = popsemantic();
  namel = popsemantic();
  oexpl = popsemantic();
  rexp = rexpl->UU.explist;
  names = namel->UU.namelist;
  oexp = oexpl->UU.explist;
  if (rexp->next != NULL) {
    rexp->next = NULL;
    errorrec = newerrorptr(arityonrexp);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if */
  if (oexp->next != NULL) {
    oexp->next = NULL;
    errorrec = newerrorptr(arityonoexp);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if */
  cinfo = oexp->graphinfo;
  error = false;
  if (cinfo->typeptr == NULL)
    cinfo->typeptr = getbasictype(ifbwild);
  while (names->next != NULL && !error) {
    pushinfolist(&infol, cinfo);
    if (cinfo->typeptr->stsort != iftrecord) {
      cinfo = createerrlit();
      errorrec = newerrorptr(ntyperr);
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
      error = true;
      continue;
    }  /* if */
    fields = cinfo->typeptr->UU.stbasetype;
    findfieldname(names->name, &fields, &found, &place);
    if (found == false) {
      cinfo = createerrlit();
      errorrec = newerrorptr(nameundrr);
      errorrec->UU.errorstr = names->name;
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
      error = true;
      continue;
    }  /* if */
    pushpositionlist(&positionl, place);
    renode = newnodeptr(ndatomic, currentlevel);
    renode->ndcode = ifnrelements;
    linkparent(renode, currentlevel);
    toinfo = newinfoptr();
    toinfo->node_ = renode;
    toinfo->port_ = 1;
    addedge(cinfo, toinfo);
    cinfo = toinfo;
    cinfo->port_ = place - 1;
    cinfo->typeptr = fields->UU.U2.stelemtype;
    names = names->next;
  }  /* while */
  if (cinfo->typeptr->stsort != iftrecord) {
    cinfo = createerrlit();
    errorrec = newerrorptr(ntyperr);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
    error = true;
  }  /* if */
  if (!error) {
    fields = cinfo->typeptr->UU.stbasetype;
    findfieldname(names->name, &fields, &found, &place);
    if (!found) {
      cinfo = createerrlit();
      errorrec = newerrorptr(nameundrr);
      errorrec->UU.errorstr = names->name;
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
    }  /* if */
    else {
      rrnode = newnodeptr(ndatomic, currentlevel);
      rrnode->ndcode = ifnrreplace;
      linkparent(rrnode, currentlevel);
      toinfo = newinfoptr();
      toinfo->node_ = rrnode;
      toinfo->port_ = 1;
      addedge(cinfo, toinfo);
      toinfo->port_ = place;
      if (rexp->graphinfo->typeptr != fields->UU.U2.stelemtype) {
        errorrec = newerrorptr(typeclashrr);
        errorrec->UU.errorstr = names->name;
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
        rexp->graphinfo = newinfoptr();
        string10(&rexp->graphinfo->litvalue, "error     ");
        rexp->graphinfo->typeptr = fields->UU.U2.stelemtype;
      }  /* if */
      addedge(rexp->graphinfo, toinfo);
      save = cinfo->typeptr;
      cinfo = newinfoptr();
      cinfo->node_ = rrnode;
      cinfo->port_ = 1;
      cinfo->typeptr = save;
      freeinfoptr(&toinfo);
      while (infol != NULL) {
        rrnode = newnodeptr(ndatomic, currentlevel);
        rrnode->ndcode = ifnrreplace;
        linkparent(rrnode, currentlevel);
        toinfo = newinfoptr();
        toinfo->node_ = rrnode;
        toinfo->port_ = poppositionlist(&positionl);
        addedge(cinfo, toinfo);
        frinfo = popinfolist(&infol);
        toinfo->port_ = 1;
        addedge(frinfo, toinfo);
        cinfo = toinfo;
        cinfo->typeptr = frinfo->typeptr;
      }  /* while */
    }  /* else */
  }  /* if */
  rexp->graphinfo = cinfo;
  pushsemantic(rexpl);

  /* else */
  /* else */
}


static void popsymlist()
{
  /*action 113 PopSymList                                                   */
  /*stack          pops - TGSymList
                   pushes - nothing                                         */
  /* description
          Pop the symble table list off the stack                           */
  semanticrec *syml;

  if (semtrace)
    printf("In PopSymList\n");
  syml = popsemantic();
  freesemantic(&syml);
}  /* PopSymList */


static void startsymlist()
{
  /*action 32 StartSymList                                                    */
  /*stack          pops - nothing
                   pushes - TGSymList                                         */
  /* description
           Create a new semantic record of type symlist and push it onto the
           stack.                                                              */
  semanticrec *sem;

  if (semtrace)
    printf("In StartSymList\n");
  newsemantic(&sem, tgsymlist);
  pushsemantic(sem);
}  /* StartSymList */


static void checkatypes(line, col)
int line, col;
{
  /*action 33 CheckATypes                                                     */
  /*stack          pops - TGExpList
                          TGSymList
                   pushes - nothing                                           */
  /* description
           Follow the expression and symbol table pointer list pairwise and
          for each pair :
                 - make sure the types are the same
                 - insert definition line number in symbol table, if already
                   defined then error except for loop names which get
                   special treatment (see code)
                 - set the graph info of the symbol table entry to that of
                   expression
           make sure the lists are both the same length                       */
  semanticrec *exps, *syms;
  explistnode *expl;
  symlistnode *syml;
  symtblbucket *sym;
  loopvarflags vartype;
  errorrecord *errorrec;

  if (semtrace)
    printf("In CheckATypes\n");
  exps = popsemantic();
  syms = popsemantic();
  expl = exps->UU.explist;
  syml = syms->UU.symlist;
  while (syml != NULL && expl != NULL) {
    sym = syml->sym;
    /* Types must be equal  */
    if (sym->typeptr != expl->graphinfo->typeptr) {
      errorrec = newerrorptr(asstypeclash);
      errorrec->UU.U21.exptype = expl->graphinfo->typeptr;
      errorrec->UU.U21.nametype = sym->typeptr;
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
    }  /* if */
    /* find out if this variable is "involved" with a forinit loop  */
    if (sym->identtag == tvariable)
      vartype = getloopflag(sym);
    else
      vartype = lnone;
    /* If it is a loop constant then error, can't be reassigned  */
    if (vartype == lconst) {
      errorrec = newerrorptr(loopconsassn);
      errorrec->UU.errorstr = sym->name;
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
    }  /* if */
    else if (vartype == linit) {
      *sym->UU.U4.loopflag = lvar;
      vartype = lvar;
      sym->UU.U4.redefflag = true;
      sym->UU.U4.oldfrom = sym->graphinfo;
      insertchar(&sym->UU.U4.oldfrom->name, '-', 1);
      insertchar(&sym->UU.U4.oldfrom->name, 'd', 1);
      insertchar(&sym->UU.U4.oldfrom->name, 'l', 1);
      insertchar(&sym->UU.U4.oldfrom->name, 'o', 1);
    } else if (vartype == lvar) {
      if (sym->importedflag) {
        errorrec = newerrorptr(redefimlvar);
        errorrec->UU.errorstr = sym->name;
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
      }  /* if imported */
      else {
        if (!sym->UU.U4.redefflag) {
          sym->UU.U4.redefflag = true;
        }  /* if */
      }  /* else */
      /* Else it is a loop var and we are at it's outer scope.  So set the
         redef flag if it's not already set.  We check for double
         redefinitions below.*/
    }
    /* Else if it was defined in the initpart of the forloop, it is now
       becoming a loop var since it is being redefined.  Copy the graphinfo
       to the OldFrom.  GraphInfo holds the new value and OldFrom holds the
       old value.*/
    /*  Check for a redefintion of a non loop var or a third definition of
        a loop var.*/
    if (getdefline(sym, 1) != -1) {
      if ((getdefline(sym, 2) != -1 && vartype == lvar) || vartype != lvar) {
        errorrec = newerrorptr(vardoubledef);
        errorrec->UU.errorstr = sym->name;
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
      }  /* if */
      else  /* else assign the new definition location */
        setdefloc(sym, linenumber, -1);
    } else  /* else assign the new definition location */
      setdefloc(sym, linenumber, -1);
    /*  Fill in the new graphinfo  */
    sym->graphinfo = newinfoptr();
    sym->graphinfo->node_ = expl->graphinfo->node_;
    sym->graphinfo->port_ = expl->graphinfo->port_;
    sym->graphinfo->typeptr = expl->graphinfo->typeptr;
    sym->graphinfo->litvalue = expl->graphinfo->litvalue;
    sym->graphinfo->onlist = expl->graphinfo->onlist;
    sym->graphinfo->name = sym->name;
    expl = expl->next;
    syml = syml->next;
  }  /* while */
  if (expl != NULL) {  /* Check that there aren't extra exps */
    errorrec = newerrorptr(longexplist);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if */
  /* If there are extra names, assign them error values  */
  if (syml == NULL)
    return;
  errorrec = newerrorptr(longnamelist);
  semerror(errorrec);
  while (syml != NULL) {
    sym = syml->sym;
    /* find out if this variable is "involved" with a forinit loop  */
    if (sym->identtag == tvariable)
      vartype = getloopflag(sym);
    else
      vartype = lnone;
    /* If it is a loop constant then error, can't be reassigned  */
    if (vartype == lconst) {
      errorrec = newerrorptr(loopconsassn);
      errorrec->UU.errorstr = sym->name;
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
    }  /* if */
    else if (vartype == linit) {
      *sym->UU.U4.loopflag = lvar;
      vartype = lvar;
      sym->UU.U4.redefflag = true;
      sym->UU.U4.oldfrom = sym->graphinfo;
      insertchar(&sym->UU.U4.oldfrom->name, '-', 1);
      insertchar(&sym->UU.U4.oldfrom->name, 'd', 1);
      insertchar(&sym->UU.U4.oldfrom->name, 'l', 1);
      insertchar(&sym->UU.U4.oldfrom->name, 'o', 1);
    } else if (vartype == lvar) {
      if (sym->importedflag) {
        errorrec = newerrorptr(redefimlvar);
        errorrec->UU.errorstr = sym->name;
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
      }  /* if imported */
      else {
        if (!sym->UU.U4.redefflag) {
          sym->UU.U4.redefflag = true;
        }  /* if */
      }  /* else */
      /* Else it is a loop var and we are at it's outer scope.  So set the
         redef flag if it's not already set.  We check for double
         redefinitions below.*/
    }
    /* Else if it was defined in the initpart of the forloop, it is now
       becoming a loop var since it is being redefined.  Copy the graphinfo
       to the OldFrom.  GraphInfo holds the new value and OldFrom holds the
       old value.*/
    /*  Check for a redefintion of a non loop var or a third definition of
        a loop var.*/
    if (getdefline(sym, 1) != -1) {
      if ((getdefline(sym, 2) != -1 && vartype == lvar) || vartype != lvar) {
        errorrec = newerrorptr(vardoubledef);
        errorrec->UU.errorstr = sym->name;
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
      }  /* if */
      else  /* else assign the new definition location */
        setdefloc(sym, linenumber, -1);
    } else  /* else assign the new definition location */
      setdefloc(sym, linenumber, -1);
    /*  Fill in the new graphinfo  */
    sym->graphinfo = newinfoptr();
    sym->graphinfo->typeptr = sym->typeptr;
    string10(&sym->graphinfo->litvalue, "error     ");
    sym->graphinfo->name = sym->name;
    syml = syml->next;
  }  /* while */

  /* else if */
  /* Else if it is already a loop var and was pulled in from an outer
     scope, then error.  You can not redefine a loop var in an internal
     scope.  Only at the outer scope.*/
  /* else if */
  /* else if */
  /* Else if it is already a loop var and was pulled in from an outer
     scope, then error.  You can not redefine a loop var in an internal
     scope.  Only at the outer scope.*/
  /* else if */
}  /* CheckATypes */


static void checkarity()
{
  /*action 34 CheckArity                                                      */
  /*stack          pops - TGExpList
                          TGNameList
                          TGSymList
                   pushes - nothing                                           */
  /* description
           Follow the expression and name list pairwise and
          for each pair :
                 - look up name in symbol table, if it exists then
                   make sure the types are the same, else create a new symbol
                   table entry for name of type the expression.
                 - insert definition line number in symbol table, if already
                   defined then error except for loop names which get special
                   treatment (see code)
                 - set the graph info of the symbol table entry to that of
                   expression
           make sure the lists are both the same length                       */
  semanticrec *exps, *names /* , *syml*/;
  explistnode *expl;
  namelistrec *namel;
  symtblbucket *sym;
  loopvarflags vartype;
  errorrecord *errorrec;

  if (semtrace)
    printf("In CheckArity\n");
  exps = popsemantic();
  names = popsemantic();
  /* syml = */ (void)popsemantic();
  expl = exps->UU.explist;
  namel = names->UU.namelist;
  while (namel != NULL && expl != NULL) {
    /* Find the name in the symbol table  */
    sym = incurrentlevel(namel->name, tvariable);
    if (sym != NULL) {
      /* Find out if name is involved with a for init loop  */
      if (sym->identtag == tvariable)
        vartype = getloopflag(sym);
      else
        vartype = lnone;
      /* If a loop constant then error, can't be reassigned  */
      if (vartype == lconst) {
        errorrec = newerrorptr(loopconsassn);
        errorrec->UU.errorstr = sym->name;
        errorrec->linenumber = namel->linenum;
        semerror(errorrec);
      }  /* if */
      else if (vartype == linit) {
        *sym->UU.U4.loopflag = lvar;
        vartype = lvar;
        sym->UU.U4.redefflag = true;
        sym->UU.U4.oldfrom = sym->graphinfo;
        insertchar(&sym->UU.U4.oldfrom->name, '-', 1);
        insertchar(&sym->UU.U4.oldfrom->name, 'd', 1);
        insertchar(&sym->UU.U4.oldfrom->name, 'l', 1);
        insertchar(&sym->UU.U4.oldfrom->name, 'o', 1);
      } else if (vartype == lvar) {
        if (sym->importedflag) {
          errorrec = newerrorptr(redefimlvar);
          errorrec->UU.errorstr = sym->name;
          errorrec->linenumber = namel->linenum;
          semerror(errorrec);
        }  /* if imported */
        else {
          if (!sym->UU.U4.redefflag) {
            sym->UU.U4.redefflag = true;
          }  /* if */
        }  /* else */
        /*  Else it is a loop var and we are at the outer scope.  So set the
            redef flag if it's not already set.  We check for double
            redefinitions below.*/
      }
      /* if  in the initpart of a for loop make it a loop var now.
         Copy the graphinfo to the OldFrom.  Graphinfo hold the new value
         and OldFrom holds the old value.*/
      /* Check that the type of the name and the exp are the same */
      if (sym->typeptr != expl->graphinfo->typeptr) {
        errorrec = newerrorptr(asstypeclash);
        errorrec->UU.U21.exptype = expl->graphinfo->typeptr;
        errorrec->UU.U21.nametype = sym->typeptr;
        errorrec->linenumber = namel->linenum;
        semerror(errorrec);
      }  /* if */
    }  /* if */
    else {
      sym = getsymtabentry(namel->name, tvariable);
      sym->typeptr = expl->graphinfo->typeptr;
      addtotable(sym, currentlevel);
    }  /* else */
    /*  Else get a new symbol table entry for the name and set it's
        type to that of the expressionand put it in the sym tab.*/
    /*  Check for a redefinition of a non loop var or a third def of a
        loop var.*/
    if (getdefline(sym, 1) != -1) {
      if ((getdefline(sym, 2) != -1 && vartype == lvar) || vartype != lvar) {
        errorrec = newerrorptr(vardoubledef);
        errorrec->UU.errorstr = namel->name;
        errorrec->linenumber = namel->linenum;
        semerror(errorrec);
      }  /* if */
      else
        setdefloc(sym, namel->linenum, -1);
    } else
      setdefloc(sym, namel->linenum, -1);
    /* Fill in the new graph info  */
    sym->graphinfo = newinfoptr();
    sym->graphinfo->node_ = expl->graphinfo->node_;
    sym->graphinfo->port_ = expl->graphinfo->port_;
    sym->graphinfo->typeptr = expl->graphinfo->typeptr;
    sym->graphinfo->litvalue = expl->graphinfo->litvalue;
    sym->graphinfo->onlist = expl->graphinfo->onlist;
    sym->graphinfo->name = namel->name;
    namel = namel->next;
    expl = expl->next;
  }  /* while */
  if (expl != NULL) {  /* Check for extra expressions */
    errorrec = newerrorptr(longexplist);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }  /* if */
  if (namel == NULL) {  /* Check for extra names */
    return;
  }  /* if */
  errorrec = newerrorptr(longnamelist);
  errorrec->linenumber = linenumber;
  semerror(errorrec);
  while (namel != NULL) {
    sym = incurrentlevel(namel->name, tvariable);
    if (sym != NULL) {
      /* Find out if name is involved with a for init loop  */
      if (sym->identtag == tvariable)
        vartype = getloopflag(sym);
      else
        vartype = lnone;
      /* If a loop constant then error, can't be reassigned  */
      if (vartype == lconst) {
        errorrec = newerrorptr(loopconsassn);
        errorrec->UU.errorstr = sym->name;
        errorrec->linenumber = namel->linenum;
        semerror(errorrec);
      }  /* if */
      else if (vartype == linit) {
        *sym->UU.U4.loopflag = lvar;
        vartype = lvar;
        sym->UU.U4.redefflag = true;
        sym->UU.U4.oldfrom = sym->graphinfo;
        insertchar(&sym->UU.U4.oldfrom->name, '-', 1);
        insertchar(&sym->UU.U4.oldfrom->name, 'd', 1);
        insertchar(&sym->UU.U4.oldfrom->name, 'l', 1);
        insertchar(&sym->UU.U4.oldfrom->name, 'o', 1);
      } else if (vartype == lvar) {
        if (sym->importedflag) {
          errorrec = newerrorptr(redefimlvar);
          errorrec->UU.errorstr = sym->name;
          errorrec->linenumber = namel->linenum;
          semerror(errorrec);
        }  /* if imported */
        else {
          if (!sym->UU.U4.redefflag) {
            sym->UU.U4.redefflag = true;
          }  /* if */
        }  /* else */
        /*  Else it is a loop var and we are at the outer scope.  So set the
            redef flag if it's not already set.  We check for double
            redefinitions below.*/
      }
      /* if  in the initpart of a for loop make it a loop var now.
         Copy the graphinfo to the OldFrom.  Graphinfo hold the new value
         and OldFrom holds the old value.*/
    }  /* if */
    else {
      sym = getsymtabentry(namel->name, tvariable);
      sym->typeptr = getbasictype(ifbwild);
      addtotable(sym, currentlevel);
    }  /* else */
    /*  Else get a new symbol table entry for the name and set it's
        type to that of the expressionand put it in the sym tab.*/
    /*  Check for a redefinition of a non loop var or a third def of a
        loop var.*/
    if (getdefline(sym, 1) != -1) {
      if ((getdefline(sym, 2) != -1 && vartype == lvar) || vartype != lvar) {
        errorrec = newerrorptr(vardoubledef);
        errorrec->UU.errorstr = namel->name;
        errorrec->linenumber = namel->linenum;
        semerror(errorrec);
      }  /* if */
      else
        setdefloc(sym, namel->linenum, -1);
    } else
      setdefloc(sym, namel->linenum, -1);
    /* Fill in the new graph info  */
    sym->graphinfo->typeptr = sym->typeptr;
    string10(&sym->graphinfo->litvalue, "error     ");
    sym->graphinfo->name = namel->name;
    setdefloc(sym, namel->linenum, -1);
    namel = namel->next;
  }  /* while */

  /* else if */
  /* Else if it is already a loop var and was pulled in from an outer
     scope, then error.  You can not redefine a loop var in an inner
     scope.  Only at the outer scope.*/
  /* else if */
  /* else if */
  /* Else if it is already a loop var and was pulled in from an outer
     scope, then error.  You can not redefine a loop var in an inner
     scope.  Only at the outer scope.*/
  /* else if */
}  /* CheckArity */


static void assoctypes()
{
  /*action 35 AssocTypes                                                      */
  /*stack          pops - TGTTPtr
                          TGNameList
                          TGSymList
                   pushes - TGSymList                                         */
  /*description
           Follow the name list and for each name :
                 - look up name in symbol table, if it exists then
                   make sure the type is the same as the TTPtr,
                   else create a new symbol table entry for name of type TTPtr
           make sure the lists are both the same length                       */
  semanticrec *atype, *names, *syml;
  namelistrec *namel;
  errorrecord *errorrec;
  symtblbucket *sym;
  symlistnode *symentry, *findend;

  if (semtrace)
    printf("In AssocTypes\n");
  atype = popsemantic();
  names = popsemantic();
  syml = popsemantic();
  namel = names->UU.namelist;
  while (namel != NULL) {
    sym = incurrentlevel(namel->name, tvariable);
    if (sym != NULL) {
      if (sym->typeptr != atype->UU.ttptr) {
        errorrec = newerrorptr(vardoubledecl);
        errorrec->UU.U25.varname = sym->name;
        errorrec->UU.U25.exp1type = atype->UU.ttptr;
        errorrec->UU.U25.exp2type = sym->typeptr;
        errorrec->linenumber = linenumber;
        semerror(errorrec);
      }  /* if */
    }  /* if */
    else {
      sym = getsymtabentry(namel->name, tvariable);
      sym->typeptr = atype->UU.ttptr;
      addtotable(sym, currentlevel);
    }  /* else */
    symentry = newsymlistptr();
    symentry->sym = sym;
    if (syml->UU.symlist != NULL) {
      findend = syml->UU.symlist;
      while (findend->next != NULL)
        findend = findend->next;
      findend->next = symentry;
    } else
      syml->UU.symlist = symentry;
    namel = namel->next;
  }  /* while */
  pushsemantic(syml);
}


static void errindexnames(indexnames, col)
namelistrec **indexnames;
int col;
{
  symtblbucket *sym;

  while (*indexnames != NULL) {
    sym = getsymtabentry((*indexnames)->name, tvariable);
    setdefloc(sym, (*indexnames)->linenum, col);
    sym->graphinfo = getalit1();
    sym->typeptr = getbasictype(ifbinteger);
    sym->graphinfo->name = (*indexnames)->name;
    addtotable(sym, currentlevel);
    *indexnames = (*indexnames)->next;
  }  /* while */
}  /* ErrIndexNames */


static void startbody()
{
  /*action 39  StartBody*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Create the body subgraph.  Save it in the CurrentSubN0.  Also
          set BodyN0 and BodyPrevNode to the new subgraph.  These are
          used so we can switch between the body and returns subgraphs
          when processing the returns parts.  Search the current symbol
          tables looking for values whose node is the generator subgraph.
          Change their node to the body subgraph since that's where they
          will now come from. If the value is a loop var also check its
          OldFrom node.  It may need to be changed too.*/
  node *genn0, *bodyn0;
  int hashindex;
  symtblbucket *chain;

  if (semtrace)
    printf("In StartBody\n");
  genn0 = currentlevel->currentsubn0;
  bodyn0 = buildsubgraph(currentlevel->UU.U0.forallnode);
  currentlevel->UU.U0.bodyprevnode = bodyn0;
  currentlevel->UU.U0.bodyn0 = bodyn0;
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (genn0 == chain->graphinfo->node_) {
        chain->graphinfo->node_ = bodyn0;
        if (chain->typeptr == NULL)
          chain->typeptr = getbasictype(ifbwild);
        if (chain->typeptr->stsort == iftmultiple)
          chain->typeptr = chain->typeptr->UU.stbasetype;
      }  /* if */
      if (chain->identtag == tvariable) {
        if (chain->UU.U4.oldfrom->node_ == genn0)
          chain->UU.U4.oldfrom->node_ = bodyn0;
      }
      chain = chain->nextbucket;
    }  /* while */
    hashindex++;
  }  /* while */
}  /* StartBody */


static void checkcross()
{
  /*action 37  CheckCross*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          This routine checks to see if a cross product is legal at
          this point.  If we have already done a dot product we can
          not also do a cross product.  CrossDotError is set if there
          is a problem.  StartBody is called to create the body of the
          new forall created by the cross product.*/
  if (semtrace)
    printf("In CheckCross\n");
  if (currentlevel->UU.U0.crossdotflag == dotflag ||
      currentlevel->UU.U0.crossdoterror)
    currentlevel->UU.U0.crossdoterror = true;
  else {
    currentlevel->UU.U0.crossdotflag = crossflag;
    startbody();
  }  /* else */
}  /* CheckCross */


static void preparefordot()
{
  /*action 153 PrepareForDot*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Set CurrentLexLevel to next outer level.  This is to insure
          that all nodes created while building the dot expression are
          placed outside the forall instead of in the generator graph.
          The routine IncreaseGenerator will restore the current lex level.*/
  currentlevel = currentlevel->lastlevel;
}


static void endbody()
{
  /*action 77  EndBody*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the symbol table for values that are coming for the
          body subgraph node.  Change then to come from the returns
          subgraph node.  Also search for values that were created in the
          body and create and edge that connects them to the body subgraph.
          These values will not be on a list.  Copy the current subgraph
          values into the body values in the lex level and move the
          returns values in the current values.*/
  node *bodyn0, *returnn0;
  int hashindex;
  symtblbucket *chain;
  inforecord *toinfo;

  if (semtrace)
    printf("In EndBody\n");
  bodyn0 = currentlevel->currentsubn0;
  returnn0 = currentlevel->UU.U0.returnn0;
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (bodyn0 == chain->graphinfo->node_)
        chain->graphinfo->node_ = returnn0;
      if (chain->identtag == tvariable) {
        if (chain->UU.U4.oldfrom->node_ == bodyn0)
          chain->UU.U4.oldfrom->node_ = returnn0;
      }
      if (chain->graphinfo->onlist == NULL && chain->graphinfo->node_ != NULL) {
        toinfo = newinfoptr();
        toinfo->node_ = bodyn0;
        toinfo->onlist = addnametolist(&currentlevel->UU.U0.tflist,
                                       chain->name);
        addedge(chain->graphinfo, toinfo);
        chain->graphinfo->node_ = returnn0;
        chain->graphinfo->onlist = toinfo->onlist;
        chain->graphinfo->port_ = -1;
      }  /* if */
      chain = chain->nextbucket;
    }  /* while */
    hashindex++;
  }  /* while */
  currentlevel->UU.U0.bodyn0 = currentlevel->currentsubn0;
  currentlevel->UU.U0.bodyprevnode = currentlevel->prevnode;
  currentlevel->UU.U0.bodynodecount = currentlevel->nodecounter;
  currentlevel->currentsubn0 = currentlevel->UU.U0.returnn0;
  currentlevel->prevnode = currentlevel->UU.U0.returnn0;
  currentlevel->nodecounter = 1;
}  /* EndBody */


static explistnode *createerrint()
{
  explistnode *expr;

  expr = newexplistptr();
  expr->graphinfo->typeptr = getbasictype(ifbinteger);
  string10(&expr->graphinfo->litvalue, "error     ");
  return expr;
}  /* CreateErrInt */


static void checkexptype(exp, line, col)
explistnode **exp;
int line, col;
{
  errorrecord *errorrec;

  if (*exp == NULL) {
    errorrec = newerrorptr(arityonfa);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
    *exp = createerrint();
    return;
  }  /* if */
  if ((*exp)->graphinfo->typeptr->stlabel == intlabel) {
    return;
  }  /* else  if */
  errorrec = newerrorptr(typeonfa);
  errorrec->UU.typeptr = (*exp)->graphinfo->typeptr;
  errorrec->linenumber = line;
  errorrec->column = col;
  semerror(errorrec);
  *exp = createerrint();
}  /* CheckExpType */


static void makearrayfor(indexnames, exp, name, line, column)
namelistrec *indexnames;
explistnode *exp;
namelistrec *name;
int line, column;
{
  /* This routine builds the generator for a array or stream driven forall.
     It calls itself recursively to build nested foralls when implicit
     cross products are to be created.*/
  symtblbucket *sym;
  inforecord *toinfo, *asinfo;
  node *asnode, *alnode, *sub, *sfallnode, *saven0;
  stentry *mult;
  treestackobj *level;
  boolean implicitcross;
  explistnode *currentexp;
  stryng compname, oldname, newname;
  errorrecord *errorrec;
  node *genn0;
  int hashindex;
  symtblbucket *chain;

  if (indexnames == NULL)
    implicitcross = false;
  else if (indexnames->next == NULL)
    implicitcross = false;
  else
    implicitcross = true;
  if (exp->graphinfo->node_ != NULL) {
    if (exp->graphinfo->name.len != 0) {
      string10(&oldname, "old-      ");
      stripspaces(&oldname);
      /* if exp is an old value of a loop var we need to find the value in
         the outer scope and pull it in.  We can't just pull in the name
         in the expression because it isn't hashed in with the word old
         in it.*/
      if (findstring(&oldname, &exp->graphinfo->name, 1) == 1) {
        substring(&newname, &exp->graphinfo->name, 5,
                  exp->graphinfo->name.len);
        findname(newname, tvariable, &level, &sym);
        sym = pullname(sym, level, line);
        exp->graphinfo = sym->UU.U4.oldfrom;
      }  /* if */
      else {  /* else just find the value and pull in */
        findname(exp->graphinfo->name, tvariable, &level, &sym);
        sym = pullname(sym, level, line);
        exp->graphinfo = sym->graphinfo;
      }  /* else */
    }  /* else if */
    else {  /* else edge isn't named, give it a dummy name and */
      string10(&compname, "#1        ");   /* place it on the KList */
      stripspaces(&compname);
      string10(&exp->graphinfo->name, "#1        ");
      stripspaces(&exp->graphinfo->name);
      toinfo = newinfoptr();
      toinfo->node_ = currentlevel->UU.U0.forallnode;
      toinfo->onlist = addnametolist(&currentlevel->UU.U0.kflist, compname);
      addedge(exp->graphinfo, toinfo);
      exp->graphinfo->port_ = 1;
      exp->graphinfo->node_ = currentlevel->currentsubn0;
      exp->graphinfo->onlist = toinfo->onlist;
    }  /* else */
  }
  /* literal so do nothing */
  /* else if the edge has a name */
  asnode = newnodeptr(ndatomic, currentlevel);   /* create AScatter node */
  asnode->ndcode = ifnascatter;
  asnode->ndsrcline = line;
  linkparent(asnode, currentlevel);
  asinfo = newinfoptr();
  asinfo->node_ = asnode;
  asinfo->port_ = 1;
  addedge(exp->graphinfo, asinfo);
  newttptr(&mult, iftmultiple);
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  mult->UU.stbasetype = exp->graphinfo->typeptr->UU.stbasetype;
  asinfo->typeptr = addtotypetable(mult);
  toinfo = newinfoptr();
  toinfo->node_ = currentlevel->currentsubn0;
  if (implicitcross) {  /* then value out of AScatter doesn't */
    string10(&asinfo->name, "*1        ");
        /*have a name,give it one and place*/
    stripspaces(&asinfo->name);
    string10(&compname, "*1        ");   /* on the M List.     */
    stripspaces(&compname);
    toinfo->onlist = addnametolist(&currentlevel->UU.U0.mflist, compname);
  }  /* if */
  else {  /* else we have a name for the value */
    asinfo->name = name->name;
    toinfo->onlist = addnametolist(&currentlevel->UU.U0.mflist, name->name);
  }  /* else */
  addedge(asinfo, toinfo);   /* connect value to SG boundary */
  if (!implicitcross) {
    sym = getsymtabentry(name->name, tvariable);   /* add name to Sym Tab */
    setdefloc(sym, name->linenum, column);
    sym->typeptr = exp->graphinfo->typeptr->UU.stbasetype;
    sym->graphinfo->typeptr = exp->graphinfo->typeptr->UU.stbasetype;
    sym->graphinfo->name = name->name;
    sym->graphinfo->onlist = toinfo->onlist;
    sym->graphinfo->node_ = currentlevel->currentsubn0;
    addtotable(sym, currentlevel);
  }
  asinfo->port_ = 2;   /* output port 2 of AScatter to */
  newttptr(&mult, iftmultiple);   /* SG Boundary, make it a Multiple */
  mult->UU.stbasetype = getbasictype(ifbinteger);
  asinfo->typeptr = addtotypetable(mult);
  toinfo = newinfoptr();
  toinfo->node_ = currentlevel->currentsubn0;
  if (indexnames == NULL) {
    string10(&compname, "*1        ");   /*no index name,give it one and */
    stripspaces(&compname);   /*place it on the M List.*/
    mymemcpy(asinfo->name.str, blankstring, sizeof(stryngar));
    asinfo->name.len = 0;
    toinfo->onlist = addnametolist(&currentlevel->UU.U0.mflist, compname);
  }  /*then*/
  else {
    asinfo->name = indexnames->name;
    toinfo->onlist = addnametolist(&currentlevel->UU.U0.mflist,
                                   indexnames->name);
    sym = getsymtabentry(indexnames->name, tvariable);
        /* Add name to SymTab */
    setdefloc(sym, indexnames->linenum, column);
    sym->typeptr = getbasictype(ifbinteger);
    sym->graphinfo->typeptr = sym->typeptr;
    sym->graphinfo->name = indexnames->name;
    sym->graphinfo->onlist = toinfo->onlist;
    sym->graphinfo->node_ = currentlevel->currentsubn0;
    addtotable(sym, currentlevel);
    indexnames = indexnames->next;   /* move to next name */
  }
  addedge(asinfo, toinfo);
  if (indexnames == NULL) {
    return;
  }  /* if */
  /* if more names, then need an
                                                array or stream, else error */
  if (exp->graphinfo->typeptr->UU.stbasetype->stsort != iftarray &&
      exp->graphinfo->typeptr->UU.stbasetype->stsort != iftstream) {
    errorrec = newerrorptr(icnotas);
    errorrec->UU.typeptr = exp->graphinfo->typeptr->UU.stbasetype;
    errorrec->linenumber = line;
    errorrec->column = column;
    semerror(errorrec);
    errindexnames(&indexnames, column);
    return;
  }  /* if */
  /* more names means we have a cross product, make sure it's legal */
  if (currentlevel->UU.U0.crossdoterror ||
      currentlevel->UU.U0.crossdotflag == dotflag) {
    currentlevel->UU.U0.crossdoterror = true;
    errorrec = newerrorptr(cdmix);
    errorrec->linenumber = line;
    errorrec->column = column;
    semerror(errorrec);
    errindexnames(&indexnames, column);
    sym = getsymtabentry(name->name, tvariable);
    setdefloc(sym, name->linenum, column);
    sym->typeptr = exp->graphinfo->typeptr->UU.stbasetype;
    sym->graphinfo->typeptr = exp->graphinfo->typeptr->UU.stbasetype;
    sym->graphinfo->name = name->name;
    sym->graphinfo->onlist = toinfo->onlist;
    sym->graphinfo->node_ = currentlevel->currentsubn0;
    addtotable(sym, currentlevel);
    return;
  }
  currentlevel->UU.U0.crossdotflag = crossflag;
  genn0 = currentlevel->currentsubn0;
  sub = buildsubgraph(currentlevel->UU.U0.forallnode);
  currentlevel->UU.U0.bodyn0 = sub;
  currentlevel->UU.U0.bodyprevnode = sub;
  currentexp = newexplistptr();
  currentexp->graphinfo->node_ = currentlevel->currentsubn0;
  currentexp->graphinfo->typeptr = exp->graphinfo->typeptr->UU.stbasetype;
  currentexp->graphinfo->onlist = currentlevel->UU.U0.mflist;
  /*make the node GI of the things created in the generator the new
    body N0 */
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (chain->graphinfo->node_ == genn0)
        chain->graphinfo->node_ = currentlevel->UU.U0.bodyn0;
      if (chain->identtag == tvariable) {
        if (chain->UU.U4.oldfrom->node_ == genn0)
          chain->UU.U4.oldfrom->node_ = currentlevel->UU.U0.bodyn0;
      }
      if (chain->typeptr->stsort == iftmultiple)
        chain->typeptr = chain->typeptr->UU.stbasetype;
      chain = chain->nextbucket;
    }  /*while*/
    hashindex++;
  }  /*while*/
  /*  extract lower bound in case we return an array */
  alnode = newnodeptr(ndatomic, currentlevel);
  alnode->ndcode = ifnaliml;
  alnode->ndsrcline = line;
  linkparent(alnode, currentlevel);
  toinfo = newinfoptr();
  toinfo->node_ = alnode;
  toinfo->port_ = 1;
  addedge(currentexp->graphinfo, toinfo);
  toinfo->typeptr = getbasictype(ifbinteger);
  /* build a "special" forall in this body */
  sfallnode = buildcompound_(specfa);
  setlowerbound(currentlevel, toinfo);
  addtoassolist(sfallnode, 0);
  addtoassolist(sfallnode, 1);
  addtoassolist(sfallnode, 2);
  currentlevel->UU.U0.crossdotflag = crossflag;
  saven0 = buildsubgraph(sfallnode);
  currentlevel->UU.U0.returnn0 = buildsubgraph(sfallnode);
  currentlevel->UU.U0.returnprevnode = currentlevel->UU.U0.returnn0;
  currentlevel->currentsubn0 = saven0;
  currentlevel->prevnode = saven0;
  /* build the generator of this new forall */
  makearrayfor(indexnames, currentexp, name, line, column);

  /* It's legal. build the body of this forall */
  /* else */
}  /* MakeArrayFor */


static void makerangefor(exp, exp2, name, line, col)
explistnode *exp, *exp2;
namelistrec *name;
int line, col;
{
  /* This routine builds the generator for a range driven forall. */
  symtblbucket *sym;
  inforecord *toinfo, *rginfo;
  node *rgnode;
  stentry *mult;
  stryng compname, oldname, newname;
  treestackobj *level;


  /* Connect the range values to the Forall node.  If they are named they
     need to be pulled into this scope.  If they are "old" values, you
     must pull them by their non-old name. If they are not named, give
     them dummy names.  Add these inputs to the K List.*/
  if (exp->graphinfo->node_ != NULL) {
    if (exp->graphinfo->name.len != 0) {
      string10(&oldname, "old-      ");
      stripspaces(&oldname);
      if (findstring(&oldname, &exp->graphinfo->name, 1) == 1) {
        substring(&newname, &exp->graphinfo->name, 5,
                  exp->graphinfo->name.len);
        findname(newname, tvariable, &level, &sym);
        sym = pullname(sym, level, line);
        exp->graphinfo = sym->UU.U4.oldfrom;
      }  /* if */
      else {
        findname(exp->graphinfo->name, tvariable, &level, &sym);
        sym = pullname(sym, level, line);
        exp->graphinfo = sym->graphinfo;
      }  /* else */
    }  /* else if */
    else {
      string10(&compname, "#1        ");
      stripspaces(&compname);
      string10(&exp->graphinfo->name, "#1        ");
      stripspaces(&exp->graphinfo->name);
      toinfo = newinfoptr();
      toinfo->node_ = currentlevel->UU.U0.forallnode;
      toinfo->onlist = addnametolist(&currentlevel->UU.U0.kflist, compname);
      addedge(exp->graphinfo, toinfo);
      exp->graphinfo->port_ = 1;
      exp->graphinfo->node_ = currentlevel->currentsubn0;
      exp->graphinfo->onlist = toinfo->onlist;
    }  /* else */
  }
  /* literal so do nothing */
  if (exp2->graphinfo->node_ != NULL) {
    if (exp2->graphinfo->name.len != 0) {
      string10(&oldname, "old-      ");
      stripspaces(&oldname);
      if (findstring(&oldname, &exp2->graphinfo->name, 1) == 1) {
        substring(&newname, &exp2->graphinfo->name, 5,
                  exp2->graphinfo->name.len);
        findname(newname, tvariable, &level, &sym);
        sym = pullname(sym, level, line);
        exp2->graphinfo = sym->UU.U4.oldfrom;
      }  /* if */
      else {
        findname(exp2->graphinfo->name, tvariable, &level, &sym);
        sym = pullname(sym, level, line);
        exp2->graphinfo = sym->graphinfo;
      }  /* else */
    }  /* else if */
    else {
      string10(&compname, "#2        ");
      stripspaces(&compname);
      string10(&exp2->graphinfo->name, "#2        ");
      stripspaces(&exp2->graphinfo->name);
      toinfo = newinfoptr();
      toinfo->node_ = currentlevel->UU.U0.forallnode;
      toinfo->onlist = addnametolist(&currentlevel->UU.U0.kflist, compname);
      addedge(exp2->graphinfo, toinfo);
      exp2->graphinfo->port_ = 1;
      exp2->graphinfo->node_ = currentlevel->currentsubn0;
      exp2->graphinfo->onlist = toinfo->onlist;
    }  /* else */
  }
  /* literal so do nothing */
  rgnode = newnodeptr(ndatomic, currentlevel);
      /* Create the Range Gen node */
  rgnode->ndcode = ifnrangegenerate;
  rgnode->ndsrcline = line;
  linkparent(rgnode, currentlevel);
  rginfo = newinfoptr();
  rginfo->node_ = rgnode;
  rginfo->port_ = 1;
  addedge(exp->graphinfo, rginfo);
  rginfo->port_ = 2;
  addedge(exp2->graphinfo, rginfo);
  rginfo->port_ = 1;
  newttptr(&mult, iftmultiple);
  mult->UU.stbasetype = getbasictype(ifbinteger);
  rginfo->typeptr = addtotypetable(mult);
  rginfo->name = name->name;
  toinfo = newinfoptr();
  toinfo->node_ = currentlevel->currentsubn0;
  toinfo->onlist = addnametolist(&currentlevel->UU.U0.mflist, name->name);
  addedge(rginfo, toinfo);   /* connect the output to SG */
  sym = getsymtabentry(name->name, tvariable);   /* add name to SymTab */
  setdefloc(sym, name->linenum, col);
  sym->typeptr = exp->graphinfo->typeptr;
  sym->graphinfo->typeptr = exp->graphinfo->typeptr;
  sym->graphinfo->name = name->name;
  sym->graphinfo->onlist = toinfo->onlist;
  sym->graphinfo->node_ = currentlevel->currentsubn0;
  addtotable(sym, currentlevel);
}  /* MakeRangeFor */


static void makeforall(line, col)
int line, col;
{
  /*action 41  MakeForAll*/
  /*stackpops - tgnamelist  (index names)
                         tgexplist   (array/stream or range exp)
                         tgnamelist  (loop name)*/
  /*description
          Check the type of the exp.  If it is an array or stream,
          then it's arity must be 1.  Otherwise the arity must be 2
          and the types of both expressions must be integer.  If
          array/stream then output a ALimL node to extract the lower
          bound.  Save the value in the new LexLevel (for a range for just
          save the info, no node is created).  Create a ForAll node and
          a new lexlevel.  Build the association list and create the
          returns subgraph, saving its infomation in the rerturns part
          of the lexlevel.  The body will be created later.  If we
          are building an array/stream forall then call MakeArrayFor
          else call MakeRangeFor.  Also if this is a range forall
          the index name list must be empty.*/
  semanticrec *indexnamesl, *expl, *namel;
  namelistrec *indexnames, *name;
  explistnode *exp, *exp2;
  boolean isarray;
  node *alnode, *fallnode, *saven0;
  inforecord *toinfo;
  errorrecord *errorrec;

  if (semtrace)
    printf("In MakeForall\n");
  indexnamesl = popsemantic();
  expl = popsemantic();
  namel = popsemantic();
  indexnames = indexnamesl->UU.namelist;
  exp = expl->UU.explist;
  name = namel->UU.namelist;
  isarray = false;
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort == iftarray ||
      exp->graphinfo->typeptr->stsort == iftstream)
  {   /* array/stream forall */
    if (exp->next != NULL) {
      errorrec = newerrorptr(arityonfa);   /* arity must be 1 */
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
      exp->next = NULL;
    }  /* if */
    alnode = newnodeptr(ndatomic, currentlevel);
    alnode->ndcode = ifnaliml;   /* save lower bound to set it on the */
    alnode->ndsrcline = line;   /* output if we return an array */
    linkparent(alnode, currentlevel);
    toinfo = newinfoptr();
    toinfo->node_ = alnode;
    toinfo->port_ = 1;
    addedge(exp->graphinfo, toinfo);
    toinfo->typeptr = getbasictype(ifbinteger);
    isarray = true;
  }  /* if */
  else {  /* range forall */
    exp2 = exp->next;   /* exp must have arity 2 and be integers */
    checkexptype(&exp, line, col);
    checkexptype(&exp2, line, col);
    toinfo = newinfoptr();   /* save lower value of range to set */
    toinfo->node_ = exp->graphinfo->node_;
        /* lower bound if we return an array */
    toinfo->port_ = exp->graphinfo->port_;
    toinfo->typeptr = exp->graphinfo->typeptr;
    toinfo->name = exp->graphinfo->name;
    toinfo->onlist = exp->graphinfo->onlist;
    toinfo->litvalue = exp->graphinfo->litvalue;
  }  /* else */
  fallnode = buildcompound_(forloop);   /* create the forall node */
  setlowerbound(currentlevel, toinfo);
  addtoassolist(fallnode, 0);
  addtoassolist(fallnode, 1);
  addtoassolist(fallnode, 2);
  saven0 = buildsubgraph(fallnode);
  currentlevel->UU.U0.returnn0 = buildsubgraph(fallnode);
  currentlevel->UU.U0.returnprevnode = currentlevel->UU.U0.returnn0;
  currentlevel->currentsubn0 = saven0;
  currentlevel->prevnode = saven0;
  if (isarray) {   /* build Array/stream generator */
    makearrayfor(indexnames, exp, name, line, col);
    return;
  }
  makerangefor(exp, exp2, name, line, col);   /* build the range generator */
  if (indexnames == NULL) {  /* index name list must be */
    return;
  }  /* if */
  errorrec = newerrorptr(atinrg);   /* empty for a range forall */
  errorrec->linenumber = line;
  errorrec->column = col;
  semerror(errorrec);
  errindexnames(&indexnamesl->UU.namelist, col);

  /* else */
}  /* MakeForall */


static void increasegenerator(line, col)
int line, col;
{
  /*action 36  IncreaseGenerator*/
  /*stackpops - tgnamelist  (index names)
                         tgexplist   (array/stream/range exp)
                         tgnamelist  (loop value name)
                  pushes - nothing*/
  /*description
          This routine implements a dot product forall.  Restore the lex level
          for the forall node.  We were popped back to the outer level by
          PrepareForDot.  If we are building an array/stream dot prod, check
          that the arity of the expression is 1.  Else we are doing an range
          dot prod, the arity should be 2 and the types should both be integers.
          Check that a dot product is ok at this point.  Dots and crosses can
          not be combined.  Then call MakeArrayFor or MakeRangeFor to fill in
          the generator subgraph.*/
  semanticrec *indexnamesl, *expl, *namel;
  explistnode *exp, *exp2;
  boolean isarray;
  symtblbucket *sym;
  errorrecord *errorrec;

  if (semtrace)
    printf("In IncreaseGenerator\n");
  indexnamesl = popsemantic();
  expl = popsemantic();
  namel = popsemantic();
  currentlevel = currentlevel->nextlevel;
  /*restore the lexlevel for the
                                               forall node.*/
  isarray = false;
  exp = expl->UU.explist;   /* check exp arity and type */
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort == iftarray ||
      exp->graphinfo->typeptr->stsort == iftstream) {
    if (exp->next != NULL) {
      errorrec = newerrorptr(arityonfa);
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
      exp->next = NULL;
    }  /* if */
    isarray = true;
  }  /* if */
  else {
    exp2 = exp->next;
    checkexptype(&exp, line, col);
    checkexptype(&exp2, line, col);
  }  /* else */
  if (currentlevel->UU.U0.crossdoterror ||
      currentlevel->UU.U0.crossdotflag == crossflag)
  {   /* check if dot is legal */
    currentlevel->UU.U0.crossdoterror = true;
    errorrec = newerrorptr(cdmix);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
    sym = getsymtabentry(namel->UU.namelist->name, tvariable);
    setdefloc(sym, namel->UU.namelist->linenum, col);
    if (isarray)
      sym->typeptr = exp->graphinfo->typeptr->UU.stbasetype;
    else
      sym->typeptr = getbasictype(ifbinteger);
    sym->graphinfo->typeptr = sym->typeptr;
    string10(&sym->graphinfo->litvalue, "error     ");
    addtotable(sym, currentlevel);
    errindexnames(&indexnamesl->UU.namelist, col);
    return;
  }  /* if */
  currentlevel->UU.U0.crossdotflag = dotflag;
  if (isarray) {
    makearrayfor(indexnamesl->UU.namelist, expl->UU.explist,
                 namel->UU.namelist, line, column);
    return;
  }
  makerangefor(exp, exp2, namel->UU.namelist, line, column);
  if (indexnamesl->UU.namelist == NULL) {
    return;
  }  /* if */
  errorrec = newerrorptr(atinrg);
  errorrec->linenumber = line;
  errorrec->column = col;
  semerror(errorrec);
  errindexnames(&indexnamesl->UU.namelist, col);

  /* else */
  /* else */
}  /* IncreaseGenerator */


static void explicitcross(line, col)
int line, col;
{
  /*action 38  ExplicitCross*/
  /*stackpops - tgnamelist  (index names)
                         tgexplist   (array/stream/range exp)
                         tgnamelist  (loop value name)
                  pushes - nothing*/
  /*description
          This routine implements a cross product forall.  If we are building
          an array/stream cross prod, check that the arity of the expression is
          1.  Else we are doing an range cross prod, the arity should be 2 and
          the types should both be integers.  Check that a cross product is
          ok at this point.  Dots and crosses can not be combined.  Extract
          the lower bound of the array or range in case an array is returned.
          Build a new forall node and then call MakeArrayFor or MakeRangeFor
          to fill in the generator subgraph.*/
  semanticrec *indexnamesl, *expl, *namel;
  explistnode *exp, *exp2;
  boolean isarray;
  symtblbucket *sym;
  node *alnode, *sfallnode, *saven0;
  inforecord *toinfo;
  errorrecord *errorrec;

  if (semtrace)
    printf("In ExplicitCross\n");
  indexnamesl = popsemantic();
  expl = popsemantic();
  namel = popsemantic();
  isarray = false;
  exp = expl->UU.explist;   /* check exp arity and type */
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort == iftarray ||
      exp->graphinfo->typeptr->stsort == iftstream) {
    if (exp->next != NULL) {
      errorrec = newerrorptr(arityonfa);
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
      exp->next = NULL;
    }  /* if */
    isarray = true;
  }  /* if */
  else {
    exp2 = exp->next;
    checkexptype(&exp, line, col);
    checkexptype(&exp2, line, col);
    toinfo = exp->graphinfo;
  }  /* else */
  if (currentlevel->UU.U0.crossdoterror) {
    errorrec = newerrorptr(cdmix);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
    sym = getsymtabentry(namel->UU.namelist->name, tvariable);
    setdefloc(sym, namel->UU.namelist->linenum, col);
    if (isarray)
      sym->typeptr = exp->graphinfo->typeptr->UU.stbasetype;
    else
      sym->typeptr = getbasictype(ifbinteger);
    sym->graphinfo->typeptr = sym->typeptr;
    string10(&sym->graphinfo->litvalue, "error     ");
    addtotable(sym, currentlevel);
    errindexnames(&indexnamesl->UU.namelist, col);
    return;
  }  /* if */
  if (isarray) {
    alnode = newnodeptr(ndatomic, currentlevel);
    alnode->ndcode = ifnaliml;
    alnode->ndsrcline = line;
    linkparent(alnode, currentlevel);
    toinfo = newinfoptr();
    toinfo->node_ = alnode;
    toinfo->port_ = 1;
    addedge(exp->graphinfo, toinfo);
    toinfo->typeptr = getbasictype(ifbinteger);
  }  /* if */
  sfallnode = buildcompound_(specfa);
  setlowerbound(currentlevel, toinfo);
  addtoassolist(sfallnode, 0);
  addtoassolist(sfallnode, 1);
  addtoassolist(sfallnode, 2);
  saven0 = buildsubgraph(sfallnode);
  currentlevel->UU.U0.returnn0 = buildsubgraph(sfallnode);
  currentlevel->UU.U0.returnprevnode = currentlevel->UU.U0.returnn0;
  currentlevel->currentsubn0 = saven0;
  currentlevel->prevnode = saven0;
  if (isarray) {
    makearrayfor(indexnamesl->UU.namelist, exp, namel->UU.namelist, line, col);
    return;
  }
  makerangefor(exp, exp2, namel->UU.namelist, line, col);
  if (indexnamesl->UU.namelist == NULL) {
    return;
  }  /* if */
  errorrec = newerrorptr(atinrg);
  errorrec->linenumber = line;
  errorrec->column = col;
  semerror(errorrec);
  errindexnames(&indexnamesl->UU.namelist, col);

  /* else */
  /* else */
}  /* ExplicitCross */


static void endforall()
{
  /*action 140  EndForAll*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          While the current lex level is not a real forall (versus a forall
          created by a cross product) do the following.
                  - swap the 2nd and 3rd graphs on the grlist of the
                    forall node.  This is required because the returns
                    SG is created before the body.
                  - Assign port number to the inputs of the forall
                  - order the edges on the input and output lists of
                    each subgraph.
                  - End the level*/
  int portnum;
  graph *gr;
  boolean done;

  if (semtrace)
    printf("begin EndForAll \n");
  done = false;   /*fix up the ass list*/
  while (!done) {
    gr = currentlevel->UU.U0.forallnode->UU.U2.ndsubsid->grnext;
    currentlevel->UU.U0.forallnode->UU.U2.ndsubsid->grnext = gr->grnext;
    gr->grnext->grnext = gr;
    gr->grnext = NULL;
    portnum = assignports(currentlevel->UU.U0.kflist, 1);
    portnum = assignports(currentlevel->UU.U0.mflist, portnum);
    portnum = assignports(currentlevel->UU.U0.tflist, portnum);
    currentlevel->UU.U0.forallnode->ndilist = orderilist(
        currentlevel->UU.U0.forallnode->ndilist);
    gr = currentlevel->UU.U0.forallnode->UU.U2.ndsubsid;
    gr->grnode->ndilist = orderilist(gr->grnode->ndilist);
    /* order input ports
                                                                of generator*/
    gr->grnode->ndolist = orderolist(gr->grnode->ndolist);
    /*order output ports
                                                                of generator */
    gr = gr->grnext;
    gr->grnode->ndilist = orderilist(gr->grnode->ndilist);
    /* order input ports
                                                                 of body*/
    gr->grnode->ndolist = orderolist(gr->grnode->ndolist);
    /*order output ports
                                                                 of body */
    gr = gr->grnext;
    gr->grnode->ndilist = orderilist(gr->grnode->ndilist);
    /* order input ports
                                                                of returns */
    gr->grnode->ndolist = orderolist(gr->grnode->ndolist);
    /*order output ports
                                                                of returns */
    if (currentlevel->lleveltag == forloop)
      done = true;
    endlevel();
  }  /*while*/
}


edgelisthead *findnameonlist(name, list)
stryng name;
edgelisthead *list;
{
  /* returns nil if name is not found */
  boolean found;

  found = false;
  while (list != NULL && !found) {
    if (equalstrings(&name, &list->edgename))
      found = true;
    else
      list = list->next;
  }
  return list;
}  /* FindNameOnList */


static void endinitpart()
{
  /*action 50  EndInitPart*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the symbol table for all values defined in the Init
          part of the loop.  These will be variables that do not
          have their imported flag set.  Set their loop flag to Linit
          and create an edge from them to the SG boundary.  The edge it
          put on the L list.*/
  int hashindex;
  symtblbucket *chain;
  inforecord *toinfo;

  if (semtrace)
    printf("In EndInitPart\n");
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (chain->identtag == tvariable) {
        if (!chain->importedflag &&
            (chain->graphinfo->node_ != NULL ||
             chain->graphinfo->litvalue.len != 0)) {
          *chain->UU.U4.loopflag = linit;
          toinfo = newinfoptr();
          toinfo->node_ = currentlevel->currentsubn0;
          toinfo->onlist = addnametolist(&currentlevel->UU.U5.lilist,
                                         chain->name);
          addedge(chain->graphinfo, toinfo);
          chain->graphinfo->onlist = toinfo->onlist;
          chain->graphinfo->node_ = currentlevel->currentsubn0;
          chain->graphinfo->port_ = -1;
        }  /* if */
      }
      chain = chain->nextbucket;
    }  /* while */
    hashindex++;
  }  /* while */
}  /* EndInitPart */


static void endabody(line, col)
int line, col;
{
  /*action 40  EndABody*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the symbol table looking for the following
                  - loop temporaries
                          These will have their LoopFlag set to LNone
                          and not be imported.  Create an edge from
                          them to the SG boundary and place the edge
                          on the T list.
                  - loop vars that were redefined
                          These will have their LoopFlag set to LVar,
                          will have their 2nd definition location filled
                          in and will not be imported.  Create an edge
                          from the value to the SG boundary.  This value
                          will already have an entry on the L list.
                          Also since the old values may be used in the test
                          we have to wire them thru the body like a temporary.
                          Put in a straight thru edge in the body and put the
                          value on a T Port.
                  - loop constants
                          These will have their LoopFlag set to LConst
                          and will not be imported.  Do the same thing
                          that was done for loop vars.
                  - loop vars that were not redefined
                          These will have their LoopFlag set to LVar
                          and will not be imported, but DO NOT have their
                          second definition location filled in.  Declare an
                          error.  We do connect an edge from the value to
                          to the SG anyway.*/
  symtblbucket *chain;
  int hashindex;
  inforecord *toinfo;
  errorrecord *errorrec;

  if (semtrace)
    printf("In EndABody\n");
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (chain->identtag == tvariable && !chain->importedflag) {
        if (chain->graphinfo->onlist == NULL &&
            *chain->UU.U4.loopflag == lnone) {
          chain->UU.U4.tflag = true;
          toinfo = newinfoptr();
          toinfo->node_ = currentlevel->currentsubn0;
          toinfo->onlist = addnametolist(&currentlevel->UU.U5.tilist,
                                         chain->name);
          addedge(chain->graphinfo, toinfo);
          chain->graphinfo->node_ = currentlevel->currentsubn0;
          chain->graphinfo->onlist = toinfo->onlist;
          chain->graphinfo->port_ = -1;
        }  /* if */
        else if ((((*chain->UU.U4.loopflag == lvar) & (getdefline(chain, 2) != -1)) ||
                  *chain->UU.U4.loopflag == lconst) &&
                 chain->importedflag == false) {
          toinfo = newinfoptr();
          toinfo->node_ = currentlevel->currentsubn0;
          toinfo->onlist = findnameonlist(chain->name,
                                          currentlevel->UU.U5.lilist);
          addedge(chain->graphinfo, toinfo);
          chain->graphinfo->node_ = currentlevel->currentsubn0;
          chain->graphinfo->onlist = toinfo->onlist;
          chain->graphinfo->port_ = -1;
          if (*chain->UU.U4.loopflag == lvar) {
            toinfo = newinfoptr();
            toinfo->node_ = currentlevel->currentsubn0;
            toinfo->onlist = addnametolist(&currentlevel->UU.U5.tilist,
                                           chain->name);
            addedge(chain->UU.U4.oldfrom, toinfo);
            chain->UU.U4.oldfrom->node_ = currentlevel->currentsubn0;
            chain->UU.U4.oldfrom->onlist = toinfo->onlist;
            chain->UU.U4.oldfrom->port_ = -1;
          } else if (getdefline(chain, 2) == -1 &&
                     *chain->UU.U4.loopflag == lvar && !chain->importedflag) {
            errorrec = newerrorptr(lvarneverredef);
            errorrec->UU.errorstr = chain->name;
            errorrec->linenumber = line;
            errorrec->column = col;
            semerror(errorrec);
            toinfo = newinfoptr();
            toinfo->node_ = currentlevel->currentsubn0;
            toinfo->onlist = findnameonlist(chain->name,
                                            currentlevel->UU.U5.lilist);
            addedge(chain->UU.U4.oldfrom, toinfo);
            chain->UU.U4.oldfrom->node_ = currentlevel->currentsubn0;
            chain->UU.U4.oldfrom->onlist = toinfo->onlist;
            chain->UU.U4.oldfrom->port_ = -1;
          }
        }
      }
      chain = chain->nextbucket;
    }  /* while */
    hashindex++;
  }  /* while */

  /*then*/
  /* else if */
}  /* EndABody */


static void endbbody(line, col)
int line, col;
{
  /*action 143  EndBBody*/
  /*stackpops - nothing
                  pushed - nothing*/
  /*description
          Search the symbol table looking for the following (all of these
          types of symbol table entries will not have their imported flag
          set.
                   - loop temporaries
                          They will have a LoopFlag of LNone.  Remove these
                          entries from the table.  In LoopB's loop temporaries
                          are not allowed in the returns part.
                  - loop var and loop constants
                          These are entries with the LoopFlag set to LoopVar
                          and have their second definition location filled in
                          (loop var) or have their LoopFlag set to LConst or LInit
                          (loop constants).  Create an edge from these values
                          to the SG boundary.  They will already have an entry
                          on the L list.
                  - loop var that weren't redefined
                          These are entries with their LoopFlag set to LoopVar
                          but their second definition location is not filled
                          in.  Declare and error.  We do connect and edge from
                          the value to the SG boundary anyway.*/
  symtblbucket *chain, *prev, *dump;
  int hashindex;
  inforecord *toinfo;
  errorrecord *errorrec;

  if (semtrace)
    printf("In EndBBody\n");
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    prev = NULL;
    while (chain != NULL) {
      if (chain->identtag != tvariable || chain->importedflag) {
        prev = chain;
        chain = chain->nextbucket;
        continue;
      }  /* then */
      if (chain->graphinfo->onlist == NULL && *chain->UU.U4.loopflag == lnone) {
        if (prev == NULL)
          currentlevel->hashtable[hashindex] = chain->nextbucket;
        else
          prev->nextbucket = chain->nextbucket;
        dump = chain;
        chain = chain->nextbucket;
        freesymptr(dump);
        continue;
      }  /* then */
      if ((((*chain->UU.U4.loopflag == lvar) & (getdefline(chain, 2) != -1)) ||
           *chain->UU.U4.loopflag == lconst ||
           *chain->UU.U4.loopflag == linit) && !chain->importedflag) {
        toinfo = newinfoptr();
        toinfo->node_ = currentlevel->currentsubn0;
        toinfo->onlist = findnameonlist(chain->name, currentlevel->UU.U5.lilist);
        addedge(chain->graphinfo, toinfo);
        chain->graphinfo->node_ = currentlevel->currentsubn0;
        chain->graphinfo->onlist = toinfo->onlist;
        chain->graphinfo->port_ = -1;
        prev = chain;
        chain = chain->nextbucket;
        continue;
      }
      if (getdefline(chain, 2) != -1 || *chain->UU.U4.loopflag != lvar ||
          chain->importedflag) {
        prev = chain;
        chain = chain->nextbucket;
        continue;
      }  /* elseif */
      errorrec = newerrorptr(lvarneverredef);
      errorrec->UU.errorstr = chain->name;
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
      toinfo = newinfoptr();
      toinfo->node_ = currentlevel->currentsubn0;
      toinfo->onlist = findnameonlist(chain->name, currentlevel->UU.U5.lilist);
      addedge(chain->UU.U4.oldfrom, toinfo);
      chain->UU.U4.oldfrom->node_ = currentlevel->currentsubn0;
      chain->UU.U4.oldfrom->onlist = toinfo->onlist;
      chain->UU.U4.oldfrom->port_ = -1;
      prev = chain;
      chain = chain->nextbucket;
    }  /* while */
    hashindex++;
  }  /* while */

  /*else*/
  /* else */
}  /* EndBBody */


static void startbtest()
{
  /*action 80  StartBTest*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the symbol table for values whose graphinfo node is the
          init SG of this for loop.  Change their graphinfo node and their
          oldfrom node info if they are a loop var (of an outer loop) to
          the test SG.  If the value was created in the init SG (LoopFlag =
          LInit) change their LoopFlag to LBInit.  This is required because
          when we enter the body we must be able to tell what values were
          defined in the init part.  If we just labeled them LInit, they
          could be confused with an LInit value that was pulled into this
          scope for use in the test subgraph.*/
  node *oldn0, *testn0;
  int hashindex;
  symtblbucket *chain;

  if (semtrace)
    printf("In StartBTest\n");
  oldn0 = currentlevel->currentsubn0;
  testn0 = buildsubgraph(currentlevel->UU.U5.initnode);
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (oldn0 == chain->graphinfo->node_)
        chain->graphinfo->node_ = testn0;
      if (chain->identtag == tvariable) {
        if (oldn0 == chain->UU.U4.oldfrom->node_)
          chain->UU.U4.oldfrom->node_ = testn0;
        if (getloopflag(chain) == linit && !chain->importedflag)
          *chain->UU.U4.loopflag = lbinit;
      }
      chain = chain->nextbucket;
    }  /* while */
    hashindex++;
  }  /* while */
}  /* StartBTest */


static void startatest()
{
  /*action 53  StartATest*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the symbol table for values whose graphinfo node is the
          body SG of this for loop.  Change their graphinfo node and their
          oldfrom node info if they are a loop var to the test SG.*/
  node *oldn0, *testn0;
  int hashindex;
  symtblbucket *chain;

  if (semtrace)
    printf("In StartATest\n");
  oldn0 = currentlevel->currentsubn0;
  testn0 = buildsubgraph(currentlevel->UU.U5.initnode);
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (oldn0 == chain->graphinfo->node_)
        chain->graphinfo->node_ = testn0;
      if (chain->identtag == tvariable) {
        if (oldn0 == chain->UU.U4.oldfrom->node_)
          chain->UU.U4.oldfrom->node_ = testn0;
      }
      chain = chain->nextbucket;
    }  /* while */
    hashindex++;
  }  /* while */
}  /* StartATest */


static void startbinitbody()
{
  /*action 84  StartBInitBody*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the symbol table looking for values whose graphinfo
          node or OldFrom node is the test SG.  Change it to be the
          Body SG.  If its LoopFlag is LBInit, set it to LInit. */
  node *oldn0, *bodyn0;
  int hashindex;
  symtblbucket *chain;

  if (semtrace)
    printf("In StartBInitBody\n");
  oldn0 = currentlevel->currentsubn0;
  bodyn0 = buildsubgraph(currentlevel->UU.U5.initnode);
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (oldn0 == chain->graphinfo->node_)
        chain->graphinfo->node_ = bodyn0;
      if (chain->identtag == tvariable) {
        if (oldn0 == chain->UU.U4.oldfrom->node_)
          chain->UU.U4.oldfrom->node_ = bodyn0;
        if (getloopflag(chain) == lbinit && !chain->importedflag)
          *chain->UU.U4.loopflag = linit;
      }
      chain = chain->nextbucket;
    }  /* while */
    hashindex++;
  }  /* while */
}  /* StartBInitBody */


static void startainitbody()
{
  /*action 76  StartAInitBody*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the symbol table for values whose GraphInfo node or
          OldFrom node is the Init SG of this for loop.  Change the
          node to be the Body SG.*/
  node *oldn0, *bodyn0;
  int hashindex;
  symtblbucket *chain;

  if (semtrace)
    printf("In StartAInitBody\n");
  oldn0 = currentlevel->currentsubn0;
  bodyn0 = buildsubgraph(currentlevel->UU.U5.initnode);
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (oldn0 == chain->graphinfo->node_)
        chain->graphinfo->node_ = bodyn0;
      if (chain->identtag == tvariable) {
        if (oldn0 == chain->UU.U4.oldfrom->node_)
          chain->UU.U4.oldfrom->node_ = bodyn0;
      }
      chain = chain->nextbucket;
    }  /* while */
    hashindex++;
  }  /* while */
}  /* StartAInitBody */


static void startforinit()
{
  /*action 49  StartForInit*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Build the compound node for the ForInit loop.  Start a new
          lex level and create the init subgraph.*/
  node *compnode /* , *subgr */;

  if (semtrace)
    printf("Begin StartForInit \n");
  compnode = buildcompound_(initloop);
  /* subgr = */ (void)buildsubgraph(compnode);
}


static void pushwhile()
{
  /*action 51  PushWhile*/
  /*stackpops - nothing
                  pushes - tgTestFlag*/
  /*description
          Push a flag that notes that the test of this loop is a while
          statement.*/
  semanticrec *semrec;

  if (semtrace)
    printf("Begin PushWhile \n");
  newsemantic(&semrec, tgtestflag);
  semrec->UU.testflag = whileloop;
  pushsemantic(semrec);
}


static void pushuntil()
{
  /*action 52  PushUntil*/
  /*stackpops - nothing
                  pushes - tgTestFlag*/
  /*description
          Push a flag that notes that the test of this loop is an until
          statement.*/
  semanticrec *semrec;

  if (semtrace)
    printf("Begin PushUntil \n");
  newsemantic(&semrec, tgtestflag);
  semrec->UU.testflag = untilloop;
  pushsemantic(semrec);
}


static void endtest()
{
  /*action 54  EndTest*/
  /*stackpops - tgExpList
                         tgTestFlag
                  pushes - nothing*/
  /*description
          Check that the arity of the expression is 1 and that its type
          is boolean.  If the TestFlag says that this is an until test
          then output a Not node, connect the expression to its input.
          Connent the result (if until) or just the exp (if while) to
          the SG boundary, port 1.*/
  semanticrec *semexplist, *semflag;
  inforecord *testgi, *subgi, *errorgi;
  errorrecord *errorrec;

  if (semtrace)
    printf("Begin EndTest \n");
  semexplist = popsemantic();
  semflag = popsemantic();
  if (semexplist->UU.explist->next != NULL) {
    errorrec = newerrorptr(testarity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    semexplist->next = NULL;
  }
  if (semexplist->UU.explist->graphinfo->typeptr->stlabel != boollabel) {
    errorrec = newerrorptr(testnotbool);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    errorgi = newinfoptr();
    string10(&errorgi->litvalue, "error     ");
    errorgi->typeptr = getbasictype(ifbboolean);
    semexplist->UU.explist->graphinfo = errorgi;
  }
  testgi = newinfoptr();
  if (semflag->UU.testflag == untilloop) {
    testgi->node_ = newnodeptr(ndatomic, currentlevel);
    testgi->node_->ndcode = ifnnot;
    testgi->node_->ndsrcline = linenumber;
    linkparent(testgi->node_, currentlevel);
    testgi->port_ = 1;
    addedge(semexplist->UU.explist->graphinfo, testgi);
    testgi->typeptr = getbasictype(ifbboolean);
  } else
    testgi = semexplist->UU.explist->graphinfo;
  subgi = newinfoptr();
  subgi->node_ = currentlevel->currentsubn0;
  subgi->port_ = 1;
  addedge(testgi, subgi);
  freesemantic(&semflag);
  freesemantic(&semexplist);
}  /* EndTest */


assoclist *buildforinitasslist(initnode)
node *initnode;
{
  assoclist *Result;
  int count;
  assoclist *al;
  PSBLOCK b;

  /* initnode->UU.U2.ndassoc = (assoclist *)Malloc(sizeof(assoclist)); */
  b = MySBlockAlloc(); /* CANN */
  initnode->UU.U2.ndassoc = &(b->al); /* CANN */

  initnode->UU.U2.ndassoc->next = NULL;
  al = initnode->UU.U2.ndassoc;
  Result = al;
  for (count = 1; count <= 3; count++) {
    /* al->next = (assoclist *)Malloc(sizeof(assoclist)); */
    b = MySBlockAlloc(); /* CANN */
    al->next = &(b->al); /* CANN */

    al->next->next = NULL;
    al = al->next;
  }
  return Result;
}


static void loopbassoclist()
{
  /*action 55  LoopBAssocList*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Set the NDCode of the ForInit to LoopB.  Build the association
          list.*/
  int grnum;
  assoclist *asslistptr;

  if (semtrace)
    printf("Begin LoopBAssoclist \n");
  currentlevel->UU.U5.initnode->ndcode = ifnloopb;
  asslistptr = buildforinitasslist(currentlevel->UU.U5.initnode);
  for (grnum = 0; grnum <= 3; grnum++) {
    asslistptr->graphnum = grnum;
    asslistptr = asslistptr->next;
  }  /*for*/
}


static void loopaassoclist()
{
  /*action 56  LoopAAssocList*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Set the NDCode of the ForInit to LoopA.  Build the association
          list.*/
  int grnum;
  assoclist *asslistptr;

  if (semtrace)
    printf("Begin LoopAAssocList \n");
  currentlevel->UU.U5.initnode->ndcode = ifnloopa;
  asslistptr = buildforinitasslist(currentlevel->UU.U5.initnode);
  for (grnum = 0; grnum <= 3; grnum++) {
    asslistptr->graphnum = grnum;
    asslistptr = asslistptr->next;
  }  /*for*/
}


static void pushold()
{
  /*action 57 PushOld*/
  /*stackpops - nothing
                  pushes - tgoldflag*/
  /*description
          Push a true old flag onto the stack.*/
  semanticrec *semold;

  if (semtrace)
    printf("begin PushOld\n");
  newsemantic(&semold, tgoldflag);
  semold->UU.oldflag = true;
  pushsemantic(semold);
}


static void pushnoold()
{
  /*action 58 PushNoOld*/
  /*stackpops - nothing
                  pushes - tgoldflag*/
  /*description
          Push a false old flag onto the stack.*/
  semanticrec *semold;

  if (semtrace)
    printf("begin PushNoOld\n");
  newsemantic(&semold, tgoldflag);
  semold->UU.oldflag = false;
  pushsemantic(semold);
}


static void doreduce(action)
int action;
{
  /*action 59 DoRedRight
           60 DoRedLeft
           61 DoRedTree
           62 DoReduce*/
  /*stackpops - nothing
                  pushes - IFN Code for the appropriate reduce node*/
  /*decscription
          Push IFN Code for the type of reduce node specified.*/
  semanticrec *semrednodetype;

  if (semtrace)
    printf("begin DoReduce\n");
  newsemantic(&semrednodetype, tgrednodetype);
  switch (action) {

  case lbdoredright:
    semrednodetype->UU.rednodetype = ifnredright;
    break;

  case lbdoredleft:
    semrednodetype->UU.rednodetype = ifnredleft;
    break;

  case lbdoredtree:
    semrednodetype->UU.rednodetype = ifnredtree;
    break;

  case lbdoreduce:
    semrednodetype->UU.rednodetype = ifnreduce;
    break;
  }/*case*/
  pushsemantic(semrednodetype);
}


static void dosum()
{
  /*action 63 DoSum*/
  /*stackpops - nothing
                  pushes - tgReduceFlag*/
  /*description
          Push a Reduce flag equal to sum.*/
  semanticrec *semredflag;

  if (semtrace)
    printf("begin DoSum\n");
  newsemantic(&semredflag, tgreduceflag);
  semredflag->UU.redflag = rfsum;
  pushsemantic(semredflag);
}


static void doproduct()
{
  /*action 64 DoProduct*/
  /*stackpops - nothing
                  pushes - tgReduceFlag*/
  /*description
          Push a Reduce flag equal to RFProduct.*/
  semanticrec *semredflag;

  if (semtrace)
    printf("begin DoProduct\n");
  newsemantic(&semredflag, tgreduceflag);
  semredflag->UU.redflag = rfproduct;
  pushsemantic(semredflag);
}


static void dogreatest()
{
  /*action 65 DoGreatest*/
  /*stackpops - nothing
                  pushes - tgReduceFlag*/
  /*description
          Push a Reduce flag equal to RFGreatest.*/
  semanticrec *semredflag;

  if (semtrace)
    printf("begin DoGreatest\n");
  newsemantic(&semredflag, tgreduceflag);
  semredflag->UU.redflag = rfgreatest;
  pushsemantic(semredflag);
}


static void doleast()
{
  /*action 66 DoLeast*/
  /*stackpops - nothing
                  pushes - tgReduceFlag*/
  /*description
          Push a Reduce flag equal to RFLeast.*/
  semanticrec *semredflag;

  if (semtrace)
    printf("begin DoLeast\n");
  newsemantic(&semredflag, tgreduceflag);
  semredflag->UU.redflag = rfleast;
  pushsemantic(semredflag);
}


static void docatenate()
{
  /*action 67 DoCatenate*/
  /*stackpops - nothing
                  pushes - tgReduceFlag*/
  /*description
          Push a Reduce flag equal to RFCatenate.*/
  semanticrec *semredflag;

  if (semtrace)
    printf("begin DoCatenate\n");
  newsemantic(&semredflag, tgreduceflag);
  semredflag->UU.redflag = rfcatenate;
  pushsemantic(semredflag);
}


static void noredop()
{
  /*action 68  NoRedOp*/
  /*stackpops - nothing
                  pushes - tgexplist  empty for no reduce node
                           tgReduceFlag  flag set to none*/
  /*description
          Push an empty explist to signify no reduction is specified and
          a reduceflag set to none.*/
  semanticrec *semrec;

  if (semtrace)
    printf("begin NoRedOp\n");
  newsemantic(&semrec, tgrednodetype);
  semrec->UU.rednodetype = 0;
  pushsemantic(semrec);
  newsemantic(&semrec, tgreduceflag);
  semrec->UU.redflag = rfnone;
  pushsemantic(semrec);
}


static void checkmask(explist)
explistnode *explist;
{
  errorrecord *errorrec;

  if (explist->next != NULL) {
    errorrec = newerrorptr(maskingarity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    explist->next = NULL;
  }
  if (explist->graphinfo->typeptr == getbasictype(ifbboolean)) {
    return;
  }  /*then*/
  errorrec = newerrorptr(masknotbool);
  errorrec->linenumber = linenumber;
  semerror(errorrec);
  explist = NULL;   /*just remove the mask*/
}


static void dounlessexp()
{
  /*action 69  DoUnlessExp*/
  /*stackpops - tgexplist
                  pushes - tgexplist*/
  /*description
          Check that the masking exp has arity 1 and type boolean.
          Connect a negate node to the expression and save the graphinfo
          for the output of the negate node on the stack.*/
  semanticrec *semexplist;
  inforecord *gi;

  if (semtrace)
    printf("begin DoUnlessExp\n");
  semexplist = popsemantic();
  checkmask(semexplist->UU.explist);
  if (semexplist->UU.explist != NULL) {
    gi = newinfoptr();
    gi->node_ = newnodeptr(ndatomic, currentlevel);
    gi->node_->ndcode = ifnnot;
    gi->node_->ndsrcline = linenumber;
    linkparent(gi->node_, currentlevel);
    gi->port_ = 1;
    addedge(semexplist->UU.explist->graphinfo, gi);
    gi->typeptr = getbasictype(ifbboolean);
    semexplist->UU.explist->graphinfo = gi;
  }
  pushsemantic(semexplist);
}


static void dowhenexp()
{
  /*action 70 DoWhenExp*/
  /*stackpops - tgexplist
                  pushes - tgexplist*/
  /*description
          Check that masking exp had arity 1 and type bool.*/
  semanticrec *semexplist;

  if (semtrace)
    printf("begin DoWhenExp\n");
  semexplist = popsemantic();
  checkmask(semexplist->UU.explist);
  pushsemantic(semexplist);
}


static void nomaskingexp()
{
  /*action 71 NoMaskingExp*/
  /*stackpops - nothing
                  pushes - tgexplist  (empty)*/
  /*description
          Push an empty explist on the stack.*/
  semanticrec *semrec;

  if (semtrace)
    printf("begin NoMaskingExp\n");
  newsemantic(&semrec, tgexplist);
  pushsemantic(semrec);
}


inforecord *removelast(inputgi, level)
inforecord *inputgi;
treestackobj *level;
{
  /* Attach an AllButLastValue node to the expression supplied and return
     graph info for the output of the ABLV node.*/
  inforecord *outputgi;

  outputgi = newinfoptr();
  outputgi->node_ = newnodeptr(ndatomic, level);
  outputgi->node_->ndcode = ifnallbutlastvalue;
  outputgi->node_->ndsrcline = linenumber;
  linkparent(outputgi->node_, level);
  outputgi->port_ = 1;
  addedge(inputgi, outputgi);
  outputgi->typeptr = inputgi->typeptr;
  return outputgi;
}


stentry *buildredtype(intypeptr)
stentry *intypeptr;
{
  stentry *functtype, *tuple1type, *tuple2type;

  newttptr(&functtype, iftfunctiontype);
  newttptr(&tuple1type, ifttuple);
  newttptr(&tuple2type, ifttuple);
  tuple1type->UU.U2.stelemtype = intypeptr;
  tuple1type->UU.U2.stnext = tuple2type;
  tuple2type->UU.U2.stelemtype = intypeptr;
  functtype->UU.U3.starg = tuple1type;
  newttptr(&tuple1type, ifttuple);
  tuple1type->UU.U2.stelemtype = intypeptr;
  tuple1type->UU.U2.stelemtype = intypeptr;
  functtype->UU.U3.stres = tuple1type;
  return (addtotypetable(functtype));
}


static void switchtoreturngraph(level)
treestackobj *level;
{
  level->UU.U0.bodynodecount = level->nodecounter;
  level->nodecounter = level->UU.U0.returnnodecount;
  level->UU.U0.bodyprevnode = level->prevnode;
  level->prevnode = level->UU.U0.returnprevnode;
  level->currentsubn0 = level->UU.U0.returnn0;
}


static void switchtobodygraph(level)
treestackobj *level;
{
  level->UU.U0.returnnodecount = level->nodecounter;
  level->nodecounter = level->UU.U0.bodynodecount;
  level->UU.U0.returnprevnode = level->prevnode;
  level->prevnode = level->UU.U0.bodyprevnode;
  level->currentsubn0 = level->UU.U0.bodyn0;
}


static void dovalueof()
{
  /*action 72  DoValueOf*/
  /*stackpops - tgExpList     (masking exp)
                         tgExpList     (return value)
                         tgRedFlag     (reduction operation type, Sum, Least, etc)
                         tgRedNodeType (type of reduce node, RedLeft,RedTree, etc)
                         tgOldFlag     (returning old or not)
                         tgExpList     (list of results already created)
                  pushes - tgExpList   (list of results)*/
  /*description
          This procedure constructs the returns graphs for "value of"
          returns.  It takes care of masking expressions, "old value of",
          and reduction nodes.  Also if we have nested for all nodes
          due to cross products, we have to build those returns graphs
          also.  See the code for a more complete description.*/
  semanticrec *semmaskexp, *semvalueexp, *semredflag, *semrednodetype,
              *semoldflag, *semresults;
  errorrecord *errorrec;
  inforecord *gi;
  explistnode *resexp;
  boolean done;
  inforecord *bodyportgi;
  stryng bodyportname;
  treestackobj *level;
  inforecord *abinfo, *tyinfo;
  node *abnode;
  inforecord *rednodegi;

  if (semtrace)
    printf("begin DoValueOf\n");
  semmaskexp = popsemantic();
  semvalueexp = popsemantic();
  semredflag = popsemantic();
  semrednodetype = popsemantic();
  semoldflag = popsemantic();
  semresults = popsemantic();
  if (semvalueexp->UU.explist->graphinfo->typeptr == NULL)
    semvalueexp->UU.explist->graphinfo->typeptr = getbasictype(ifbwild);
  if (semvalueexp->UU.explist->next != NULL)   /* check arity of value exp */
  {  /* should be 1 */
    errorrec = newerrorptr(valueofarity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    semvalueexp->UU.explist->next = NULL;
  }  /*then*/
  done = false;
  level = currentlevel;
  /* if we have nested foralls due to cross products, we will have to
     execute this code for each of them.*/
  while (!done) {
    if (semoldflag->UU.oldflag)   /* if "old value of" then */
    {  /* output AllButLastValue node */
      semvalueexp->UU.explist->graphinfo = removelast(
          semvalueexp->UU.explist->graphinfo, level);
      if (semmaskexp->UU.explist != NULL)
            /* do the same for mask exp if it exists */
              semmaskexp->UU.explist->graphinfo = removelast(
                  semmaskexp->UU.explist->graphinfo, level);
    }
    if (semrednodetype->UU.rednodetype == 0)   /* if no reduction operation */
    {  /* output a final value node */
      gi = newinfoptr();
      gi->node_ = newnodeptr(ndatomic, level);
      gi->node_->ndcode = ifnfinalvalue;
      gi->node_->ndsrcline = linenumber;
      linkparent(gi->node_, level);
      gi->port_ = 1;
      addedge(semvalueexp->UU.explist->graphinfo, gi);
      if (semmaskexp->UU.explist != NULL) {   /* if mask exists, connect it */
        gi->port_ = 2;
        addedge(semmaskexp->UU.explist->graphinfo, gi);
      }
      gi->port_ = 1;   /*set up for the output graph info*/
      gi->typeptr = semvalueexp->UU.explist->graphinfo->typeptr;
    }  /*then*/
    else {  /* else get a reduce node */
      rednodegi = newinfoptr();
      rednodegi->node_ = newnodeptr(ndatomic, level);
      rednodegi->node_->ndcode = semrednodetype->UU.rednodetype;
      rednodegi->node_->ndsrcline = linenumber;
      linkparent(rednodegi->node_, level);
      /* case on the type of reduction.  Connect the operation to port 1.
         Check that the value exp is a legal type for this reduction.
         Connect the correct unit value to port 2.*/
      switch (semredflag->UU.redflag) {

      case rfsum:
        gi = newinfoptr();
        string10(&gi->litvalue, "SUM       ");
        gi->typeptr = buildredtype(semvalueexp->UU.explist->graphinfo->typeptr);
        rednodegi->port_ = 1;
        addedge(gi, rednodegi);
        if ((unsigned)semvalueexp->UU.explist->graphinfo->typeptr->stlabel >= 32 ||
            ((1L << semvalueexp->UU.explist->graphinfo->typeptr->stlabel) &
             algebtypes) == 0) {
/* p2c: mono.bin.noblank.p, line 17218: Note:
 * Line breaker spent 0.7+0.36 seconds, 440 tries on line 20103 [251] */
          errorrec = newerrorptr(reducetype);
          errorrec->UU.U91.redtype = semvalueexp->UU.explist->graphinfo->typeptr;
          errorrec->UU.U91.redflag = semredflag->UU.redflag;
          errorrec->linenumber = linenumber;
          semerror(errorrec);
        } else {
          switch (semvalueexp->UU.explist->graphinfo->typeptr->stlabel) {

          case boollabel:
            string10(&gi->litvalue, "false     ");
            break;

          case doublabel:
            string10(&gi->litvalue, "0.0D0     ");
            break;

          case intlabel:
            string10(&gi->litvalue, "0         ");
            break;

          case reallabel:
            string10(&gi->litvalue, "0.0       ");
            break;
          }/*case*/
        }  /*else*/
        gi->typeptr = semvalueexp->UU.explist->graphinfo->typeptr;
        rednodegi->port_ = 2;
        addedge(gi, rednodegi);
        break;
        /*RFSum*/

      case rfproduct:
        gi = newinfoptr();
        string10(&gi->litvalue, "PRODUCT   ");
        gi->typeptr = buildredtype(semvalueexp->UU.explist->graphinfo->typeptr);
        rednodegi->port_ = 1;
        addedge(gi, rednodegi);
        if ((unsigned)semvalueexp->UU.explist->graphinfo->typeptr->stlabel >= 32 ||
            ((1L << semvalueexp->UU.explist->graphinfo->typeptr->stlabel) &
             algebtypes) == 0) {
          errorrec = newerrorptr(reducetype);
          errorrec->UU.U91.redtype = semvalueexp->UU.explist->graphinfo->typeptr;
          errorrec->UU.U91.redflag = semredflag->UU.redflag;
          errorrec->linenumber = linenumber;
          semerror(errorrec);
        } else {
          switch (semvalueexp->UU.explist->graphinfo->typeptr->stlabel) {

          case boollabel:
            string10(&gi->litvalue, "true      ");
            break;

          case doublabel:
            string10(&gi->litvalue, "1.0D0     ");
            break;

          case intlabel:
            string10(&gi->litvalue, "1         ");
            break;

          case reallabel:
            string10(&gi->litvalue, "1.0       ");
            break;
          }/*case*/
        }  /*else*/
        gi->typeptr = semvalueexp->UU.explist->graphinfo->typeptr;
        rednodegi->port_ = 2;
        addedge(gi, rednodegi);
        break;
        /*RFProduct*/

      case rfleast:
        if ((unsigned)semvalueexp->UU.explist->graphinfo->typeptr->stlabel >= 32 ||
            ((1L << semvalueexp->UU.explist->graphinfo->typeptr->stlabel) &
             algebtypes) == 0) {
          errorrec = newerrorptr(reducetype);
          errorrec->UU.U91.redtype = semvalueexp->UU.explist->graphinfo->typeptr;
          errorrec->UU.U91.redflag = semredflag->UU.redflag;
          errorrec->linenumber = linenumber;
          semerror(errorrec);
        }
        gi = newinfoptr();
        string10(&gi->litvalue, "LEAST     ");
        gi->typeptr = buildredtype(semvalueexp->UU.explist->graphinfo->typeptr);
        rednodegi->port_ = 1;
        addedge(gi, rednodegi);
        string10(&gi->litvalue, "max       ");
        gi->typeptr = semvalueexp->UU.explist->graphinfo->typeptr;
        rednodegi->port_ = 2;
        addedge(gi, rednodegi);
        break;
        /*RFLeast*/

      case rfgreatest:
        if ((unsigned)semvalueexp->UU.explist->graphinfo->typeptr->stlabel >= 32 ||
            ((1L << semvalueexp->UU.explist->graphinfo->typeptr->stlabel) &
             algebtypes) == 0) {
          errorrec = newerrorptr(reducetype);
          errorrec->UU.U91.redtype = semvalueexp->UU.explist->graphinfo->typeptr;
          errorrec->UU.U91.redflag = semredflag->UU.redflag;
          errorrec->linenumber = linenumber;
          semerror(errorrec);
        }
        gi = newinfoptr();
        string10(&gi->litvalue, "GREATEST  ");
        gi->typeptr = buildredtype(semvalueexp->UU.explist->graphinfo->typeptr);
        rednodegi->port_ = 1;
        addedge(gi, rednodegi);
        string10(&gi->litvalue, "min       ");
        gi->typeptr = semvalueexp->UU.explist->graphinfo->typeptr;
        rednodegi->port_ = 2;
        addedge(gi, rednodegi);
        break;
        /*RFGreatest*/

      case rfcatenate:
        if (semvalueexp->UU.explist->graphinfo->typeptr->stsort != iftarray &&
            semvalueexp->UU.explist->graphinfo->typeptr->stsort != iftstream) {
          errorrec = newerrorptr(reducetype);
          errorrec->UU.U91.redtype = semvalueexp->UU.explist->graphinfo->typeptr;
          errorrec->UU.U91.redflag = semredflag->UU.redflag;
          errorrec->linenumber = linenumber;
          semerror(errorrec);
        }
        gi = newinfoptr();
        string10(&gi->litvalue, "CATENATE  ");
        gi->typeptr = buildredtype(semvalueexp->UU.explist->graphinfo->typeptr);
        rednodegi->port_ = 1;
        addedge(gi, rednodegi);
        abnode = newnodeptr(ndatomic, level);
        abnode->ndcode = ifnabuild;
        linkparent(abnode, level);
        abinfo = newinfoptr();
        abinfo->node_ = abnode;
        abinfo->port_ = 1;
        tyinfo = newinfoptr();
        tyinfo->typeptr = getbasictype(ifbinteger);
        string10(&tyinfo->litvalue, "1         ");
        addedge(tyinfo, abinfo);
        abinfo->typeptr = semvalueexp->UU.explist->graphinfo->typeptr;
        rednodegi->port_ = 2;
        addedge(abinfo, rednodegi);
        break;
        /*RFCatenate*/
      default:
         ;
      }/*case*/
      /*connect the values to reduce to port 3*/
      rednodegi->port_ = 3;
      addedge(semvalueexp->UU.explist->graphinfo, rednodegi);
      /*connect the mask to port 4 if one exists*/
      if (semmaskexp->UU.explist != NULL) {
        rednodegi->port_ = 4;
        addedge(semmaskexp->UU.explist->graphinfo, rednodegi);
      }
      gi = rednodegi;   /* set up the output value */
      gi->port_ = 1;
      gi->typeptr = semvalueexp->UU.explist->graphinfo->typeptr;
    }  /*else*/
    resexp = newexplistptr();   /* connect the value to the SG */
    resexp->graphinfo->node_ = level->currentsubn0;
    resexp->graphinfo->port_ = nextreturnport(level);
    resexp->graphinfo->typeptr = gi->typeptr;
    addedge(gi, resexp->graphinfo);
    switch (level->lleveltag) {

    case forloop:
    case specfa:
      resexp->graphinfo->node_ = level->UU.U0.forallnode;
      break;

    case initloop:
      resexp->graphinfo->node_ = level->UU.U5.initnode;
      break;
    default:
       ;
    }/*case*/
    /*  Determine if we have to process some outer foralls due to
        cross products.*/
    if (level->lleveltag == initloop || level->lleveltag == forloop)
    {  /* if not, add this value to return exp list */
      addtoexplist(&semresults->UU.explist, resexp);
      pushsemantic(semresults);   /* and push it */
      done = true;
      continue;
    }  /*then*/
    level = level->lastlevel;   /* levels body subgraph.   */
    if (level->currentsubn0 == level->UU.U0.returnn0)
      switchtobodygraph(level);
    bodyportgi = newinfoptr();   /* Connect the value to the body SG */
    bodyportgi->node_ = level->currentsubn0;
    bodyportgi->typeptr = resexp->graphinfo->typeptr;
    nextbodyportname(level, &bodyportname);
    bodyportgi->onlist = addnametolist(&level->UU.U0.tflist, bodyportname);
    addedge(resexp->graphinfo, bodyportgi);
    if (level->currentsubn0 == level->UU.U0.bodyn0)
          /* switch to the returns graph */
            switchtoreturngraph(level);
    /* Change the node of the returns value to the returns SG.  Copy it
       to the place where the looping code expects it and continue the loop. */
    bodyportgi->node_ = level->currentsubn0;
    semvalueexp->UU.explist->graphinfo = bodyportgi;
    semmaskexp->UU.explist = NULL;
    /*masking only occurs in the inner
                                         most forall node.*/
  }  /*while*/
  /* Set the context back to the body SGs of all the foralls except
     for the inner most, so that pull name will connect the edges
     correctly.*/
  while (level->nextlevel != NULL) {
    if (level->currentsubn0 == level->UU.U0.returnn0)
      switchtobodygraph(level);
    level = level->nextlevel;
  }
  freesemantic(&semmaskexp);
  freesemantic(&semvalueexp);
  freesemantic(&semrednodetype);
  freesemantic(&semoldflag);

  /* else pop back a level and switch to that */
  /*else*/
}


static void doarrayof(action)
int action;
{
  /*action 73 DoArrayOf  74 DoStreamOf*/
  /*stackpops tgexplist  (masking exp)
                       tgexplist  (array/stream expression)
                       tgoldflag
                       tgexplist  (results list)
                  pushes tgexplist*/
  /*description
          This procedure constructs the returns graphs for "array of" or
          "stream of" returns.  It takes care of masking, "old array/
          stream of" and setting the lower bound of the arrays in the
          "array of" returns.  Also if we have nested for all nodes due
          to cross products, we have to build those returns graphs also.
          See the code for a more complete description.*/
  semanticrec *semmaskexp, *semarrayexp, *semoldflag, *semresults, *sematype;
  inforecord *lit1, *agathergi;
  explistnode *resexp;
  errorrecord *errorrec;
  boolean done;
  treestackobj *level;
  inforecord *bodyportgi, *asetlgi;
  stryng bodyportname;

  if (semtrace) {
    if (action == lbdoarrayof)
      printf("begin DoArrayOf \n");
    else
      printf("begin DoStreamOf \n");
  }
  semmaskexp = popsemantic();
  semarrayexp = popsemantic();
  semoldflag = popsemantic();
  semresults = popsemantic();
  if (semarrayexp->UU.explist->next != NULL)   /*check arity of array/stream*/
  {  /*expression, should be 1 */
    if (action == lbdoarrayof)
      errorrec = newerrorptr(arrayofarity);
    else
      errorrec = newerrorptr(streamofarity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    semarrayexp->UU.explist->next = NULL;
  }  /*then*/
  done = false;
  level = currentlevel;
  /* If we have nested foralls due to cross products, we will have
     to execute this code for each of them.*/
  while (!done) {
    if (semoldflag->UU.oldflag)   /* if "old array/stream of" then */
    {  /* output AllButLastValue node */
      semarrayexp->UU.explist->graphinfo = removelast(
          semarrayexp->UU.explist->graphinfo, level);
      if (semmaskexp->UU.explist != NULL)   /* do the same for the mask exp */
        semmaskexp->UU.explist->graphinfo = removelast(
            semmaskexp->UU.explist->graphinfo, level);
    }
    agathergi = newinfoptr();   /* output an AGather node */
    agathergi->node_ = newnodeptr(ndatomic, level);
    agathergi->node_->ndcode = ifnagather;
    agathergi->node_->ndsrcline = linenumber;
    linkparent(agathergi->node_, level);
    agathergi->port_ = 1;
    lit1 = getalit1();   /* Set lower bound to 1 */
    addedge(lit1, agathergi);
    agathergi->port_ = 2;
    addedge(semarrayexp->UU.explist->graphinfo, agathergi);
    if (semmaskexp->UU.explist != NULL) {   /* connect mask if it exists */
      agathergi->port_ = 3;
      addedge(semmaskexp->UU.explist->graphinfo, agathergi);
    }
    resexp = newexplistptr();   /* set up the output info */
    resexp->graphinfo->node_ = level->currentsubn0;
    if (action == lbdoarrayof)
      pusharray(noaddtottable);
    else
      pushstream(noaddtottable);
    sematype = popsemantic();   /* type = array[input type] */
    sematype->UU.ttptr->UU.stbasetype = semarrayexp->UU.explist->graphinfo->
                                        typeptr;
    agathergi->typeptr = addtotypetable(sematype->UU.ttptr);
    agathergi->port_ = 1;
    resexp->graphinfo->port_ = nextreturnport(level);
    addedge(agathergi, resexp->graphinfo);   /* connect to SG boundary */
    resexp->graphinfo->typeptr = agathergi->typeptr;
    switch (level->lleveltag) {

    case forloop:
    case specfa:
      resexp->graphinfo->node_ = level->UU.U0.forallnode;
      break;

    case initloop:
      resexp->graphinfo->node_ = level->UU.U5.initnode;
      break;
    default:
       ;
    }/*case*/
    /* If we have a for initial loop, or a forall loop with a
       returns stream of, add the value to the returns list
       and push the list.*/
    if (level->lleveltag == initloop ||
        (level->lleveltag == forloop && action == lbdostreamof)) {
      addtoexplist(&semresults->UU.explist, resexp);
      pushsemantic(semresults);
      done = true;
      continue;
    }  /*then*/
    /* If we have a forall loop with a returns array of, we need
       to set the lower bound on the array.Output an ASetL node
       outside the forall node.  Connect the lower bound info
       found in the lex level to the node along with the output
       value.  Add the output of the ASetL node to the result exp
       list and push the list.*/
    if (level->lleveltag == forloop && action == lbdoarrayof) {
      asetlgi = newinfoptr();
      asetlgi->node_ = newnodeptr(ndatomic, level->lastlevel);
      asetlgi->node_->ndcode = ifnasetl;
      asetlgi->node_->ndsrcline = linenumber;
      linkparent(asetlgi->node_, level->lastlevel);
      asetlgi->port_ = 1;
      addedge(resexp->graphinfo, asetlgi);
      asetlgi->typeptr = resexp->graphinfo->typeptr;
      asetlgi->port_ = 2;
      addedge(level->UU.U0.lowerbound, asetlgi);
      asetlgi->port_ = 1;
      resexp->graphinfo = asetlgi;
      addtoexplist(&semresults->UU.explist, resexp);
      pushsemantic(semresults);
      done = true;
      continue;
    }  /*then*/
    /* Else we have a special forall node generated due to a cross
       product.  We need to process the outer forall's returns
       graph.*/
    level = level->lastlevel;   /* pop back a level */
    if (level->currentsubn0 == level->UU.U0.returnn0)
          /* switch to it's body SG */
            switchtobodygraph(level);
    bodyportgi = newinfoptr();   /* set up to connect to */
    bodyportgi->node_ = level->currentsubn0;   /* the body SG */
    bodyportgi->typeptr = resexp->graphinfo->typeptr;
    nextbodyportname(level, &bodyportname);
    bodyportgi->onlist = addnametolist(&level->UU.U0.tflist, bodyportname);
    /* If we are returning an array, output an ASetL node.  Connect
       the lower bound info found in the inner lex level to the node
       along with the output value.  Then connect the output of the
       ASetL node to the Body SG boundary.*/
    if (action == lbdoarrayof) {
      asetlgi = newinfoptr();
      asetlgi->node_ = newnodeptr(ndatomic, level);
      asetlgi->node_->ndcode = ifnasetl;
      asetlgi->node_->ndsrcline = linenumber;
      linkparent(asetlgi->node_, level);
      asetlgi->port_ = 1;
      addedge(resexp->graphinfo, asetlgi);
      asetlgi->typeptr = resexp->graphinfo->typeptr;
      asetlgi->port_ = 2;
      addedge(level->nextlevel->UU.U0.lowerbound, asetlgi);
      asetlgi->port_ = 1;
      addedge(asetlgi, bodyportgi);
    } else  /* otherwise, just connect the value to the SG boundary */
      addedge(resexp->graphinfo, bodyportgi);
    if (level->currentsubn0 == level->UU.U0.bodyn0)
          /* Switch to the returns SG */
            switchtoreturngraph(level);
    /* Change the node of the returns calue to the returns SG.  Copy it
       to the place where the looping code expects it and continue the loop. */
    bodyportgi->node_ = level->currentsubn0;
    semarrayexp->UU.explist->graphinfo = bodyportgi;
    semmaskexp->UU.explist = NULL;
    /*masking only occurs in the inner
                                          most loop */
  }  /*while*/
  /* Set the context back to the body SGs of all the foralls except
     for the inner most, so that pullname will connect the edges
     correctly.*/
  while (level->nextlevel != NULL) {
    if (level->currentsubn0 == level->UU.U0.returnn0)
      switchtobodygraph(level);
    level = level->nextlevel;
  }
  freesemantic(&semmaskexp);
  freesemantic(&semarrayexp);
  freesemantic(&semoldflag);
  freesemantic(&sematype);

  /*else*/
}


static void startreturns()
{
  /*action 75  StartReturns*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the symbol table for the following
                  - loop temporaries  ( not imported )
                          These have their TFlag set.  Remove these
                          from the table, they can not appear in the
                          returns part.
                  - loop vars  ( not imported )
                          These have their LoopFlag set to LVar.  Change
                          it to LNone.  These will then not allow the
                          word old to appear in the returns with these
                          values.
                  - all values that have their graphinfo node or oldfrom
                    node equal to the previous subgraph (this may be the
                    body in a LoopB or the test in a LoopA).  Change the
                    node into to the returns SG.*/
  symtblbucket *buck, *lastbuck, *dump;
  node *oldn0, *returnn0;
  int hashvalue;

  if (semtrace)
    printf("begin StartReturns \n");
  oldn0 = currentlevel->currentsubn0;
  returnn0 = buildsubgraph(currentlevel->UU.U5.initnode);
  for (hashvalue = 0; hashvalue <= maxhashtable; hashvalue++) {
    buck = currentlevel->hashtable[hashvalue];
    lastbuck = NULL;
    while (buck != NULL) {
      if (buck->identtag != tvariable && buck->identtag != tparam) {
        buck = buck->nextbucket;
        continue;
      }  /*if*/
      if (buck->UU.U4.tflag && !buck->importedflag) {
        if (lastbuck == NULL)
          currentlevel->hashtable[hashvalue] = buck->nextbucket;
        else
          lastbuck->nextbucket = buck->nextbucket;
        dump = buck;
        buck = buck->nextbucket;
        freesymptr(dump);
        continue;
      }  /*then*/
      if (buck->identtag == tvariable) {   /*TParams don't have LoopFlags*/
        if (*buck->UU.U4.loopflag == lvar && !buck->importedflag)
          *buck->UU.U4.loopflag = lnone;
      }
      /*don't allow old in Returns*/
      if (oldn0 == buck->graphinfo->node_)
        buck->graphinfo->node_ = returnn0;
      if (buck->identtag == tvariable) {   /*TParams don't have OldFrom*/
        if (oldn0 == buck->UU.U4.oldfrom->node_)
          buck->UU.U4.oldfrom->node_ = returnn0;
      }
      lastbuck = buck;
      buck = buck->nextbucket;
    }  /*while*/
  }  /*for*/

  /*else*/
}


static void endforinit()
{
  /*action 78  EndForInit*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          If this is a LoopA forinit, swap the test and body subgraphs.
          Assign the port number to the edges on the lists held in the
          lex level.  Order the output lists and input lists for each of
          the subgraphs.  End the lexlevel.*/
  int portnum;
  graph *gr, *bodygr, *testgr;

  if (semtrace)
    printf("begin EndForinit \n");
  if (currentlevel->UU.U5.initnode->ndcode == ifnloopa) {
    bodygr = currentlevel->UU.U5.initnode->UU.U2.ndsubsid->grnext;
    testgr = bodygr->grnext;
    currentlevel->UU.U5.initnode->UU.U2.ndsubsid->grnext = testgr;
    bodygr->grnext = testgr->grnext;
    testgr->grnext = bodygr;
  }
  portnum = assignports(currentlevel->UU.U5.kilist, 1);
  portnum = assignports(currentlevel->UU.U5.lilist, portnum);
  portnum = assignports(currentlevel->UU.U5.tilist, portnum);
  gr = currentlevel->UU.U5.initnode->UU.U2.ndsubsid;
  gr->grnode->ndilist = orderilist(gr->grnode->ndilist);
  gr->grnode->ndolist = orderolist(gr->grnode->ndolist);
  gr = gr->grnext;
  gr->grnode->ndilist = orderilist(gr->grnode->ndilist);
  gr->grnode->ndolist = orderolist(gr->grnode->ndolist);
  gr = gr->grnext;
  gr->grnode->ndilist = orderilist(gr->grnode->ndilist);
  gr->grnode->ndolist = orderolist(gr->grnode->ndolist);
  gr = gr->grnext;
  gr->grnode->ndilist = orderilist(gr->grnode->ndilist);
  gr->grnode->ndolist = orderolist(gr->grnode->ndolist);
  endlevel();
}


static void notenoughargs(functname, LINK)
stryng functname;
struct LOC_dopredefined *LINK;
{
  errorrecord *errorrec;

  errorrec = newerrorptr(numfunctarg);
  errorrec->UU.U29.argnum = -1;
  errorrec->UU.U29.functionname = functname;
  errorrec->linenumber = LINK->line;
  semerror(errorrec);
}

static void toomanyargs(functname, LINK)
stryng functname;
struct LOC_dopredefined *LINK;
{
  errorrecord *errorrec;

  errorrec = newerrorptr(numfunctarg);
  errorrec->UU.U29.argnum = 1;
  errorrec->UU.U29.functionname = functname;
  errorrec->linenumber = LINK->line;
  semerror(errorrec);
}

static void wrongargtype(argnum, functname, LINK)
int argnum;
stryng functname;
struct LOC_dopredefined *LINK;
{
  errorrecord *errorrec;

  errorrec = newerrorptr(typefunctarg);
  errorrec->UU.U29.argnum = argnum;
  errorrec->UU.U29.functionname = functname;
  errorrec->linenumber = LINK->line;
  semerror(errorrec);
}

static inforecord *getalit1_(LINK)
struct LOC_dopredefined *LINK;
{
  inforecord *info;

  info = newinfoptr();
  info->typeptr = getbasictype(ifbinteger);
  string10(&info->litvalue, "1         ");
  return info;
}

static void checknumberofargs(expl, num, functname, LINK)
semanticrec *expl;
int num;
stryng functname;
struct LOC_dopredefined *LINK;
{
  int cnum;
  explistnode *listptr;

  listptr = expl->UU.explist;
  if (listptr == NULL)
    cnum = 0;
  else {
    cnum = 1;
    while (listptr->next != NULL) {
      listptr = listptr->next;
      cnum++;
    }  /* while */
  }  /* else */
  if (cnum < num) {
    notenoughargs(functname, LINK);
    while (cnum < num) {
      if (cnum == 0) {
        expl->UU.explist = newexplistptr();
        expl->UU.explist->graphinfo = getalit1_(LINK);
        listptr = expl->UU.explist;
      }  /* if */
      else {
        listptr->next = newexplistptr();
        listptr = listptr->next;
        listptr->graphinfo = getalit1_(LINK);
      }  /* else */
      cnum++;
    }  /* while */
  }  /* if */
  if (cnum <= num) {
    return;
  }  /* if */
  toomanyargs(functname, LINK);
  if (num == 0) {
    expl->UU.explist = NULL;
    return;
  }
  listptr = expl->UU.explist;
  cnum = 1;
  while (cnum != num) {
    listptr = listptr->next;
    cnum++;
  }  /* while */
  listptr->next = NULL;

  /* else */
}  /* CheckNumberOfArgs */

static inforecord *addintnode(gi, LINK)
inforecord *gi;
struct LOC_dopredefined *LINK;
{
  /* Since the IF1 exp node does not output integer values we need to
     add an integer node after the exp node if the inputs were integers. */
  node *intnode;
  inforecord *intgi;

  intnode = newnodeptr(ndatomic, currentlevel);
  intnode->ndcode = ifnint;
  intnode->ndsrcline = linenumber;
  linkparent(intnode, currentlevel);
  intgi = newinfoptr();
  intgi->node_ = intnode;
  intgi->port_ = 1;
  addedge(gi, intgi);
  intgi->typeptr = getbasictype(ifbinteger);
  return intgi;
}

static inforecord *buildpredefnode(nodecode, line, LINK)
int nodecode, line;
struct LOC_dopredefined *LINK;
{
  inforecord *predefgraphinfo;

  predefgraphinfo = newinfoptr();
  predefgraphinfo->node_ = newnodeptr(ndatomic, currentlevel);
  predefgraphinfo->node_->ndcode = nodecode;
  predefgraphinfo->node_->ndsrcline = line;
  linkparent(predefgraphinfo->node_, currentlevel);
  return predefgraphinfo;
}

static inforecord *errtype_(iftype, base, LINK)
char iftype;
stentry *base;
struct LOC_dopredefined *LINK;
{
  stentry *ptype;
  inforecord *info;

  newttptr(&ptype, iftype);
  ptype->UU.stbasetype = base;
  ptype = addtotypetable(ptype);
  info = newinfoptr();
  string10(&info->litvalue, "error     ");
  info->typeptr = ptype;
  return info;
}  /* ErrType */

static inforecord *maxmin(ifntype, expl, line, functname, LINK)
unchar ifntype;
semanticrec *expl;
int line;
stryng functname;
struct LOC_dopredefined *LINK;
{
  explistnode *exp1, *exp2;
  inforecord *preinfo;

  checknumberofargs(expl, 2, functname, LINK);
  exp1 = expl->UU.explist;
  exp2 = expl->UU.explist->next;
  if (exp1->graphinfo->typeptr == NULL)
    exp1->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp2->graphinfo->typeptr == NULL)
    exp2->graphinfo->typeptr = getbasictype(ifbwild);
  if ((unsigned)exp1->graphinfo->typeptr->stlabel >= 32 ||
      ((1L << exp1->graphinfo->typeptr->stlabel) & arithtypes) == 0) {
    exp1->graphinfo = getalit1_(LINK);
    wrongargtype(1, functname, LINK);
  }  /* if */
  if ((unsigned)exp2->graphinfo->typeptr->stlabel >= 32 ||
      ((1L << exp2->graphinfo->typeptr->stlabel) & arithtypes) == 0) {
    exp2->graphinfo = getalit1_(LINK);
    wrongargtype(2, functname, LINK);
  }  /* if */
  if (exp1->graphinfo->typeptr != exp2->graphinfo->typeptr) {
    exp2->graphinfo = newinfoptr();
    string10(&exp2->graphinfo->litvalue, "error     ");
    exp2->graphinfo->typeptr = exp1->graphinfo->typeptr;
    wrongargtype(2, functname, LINK);
  }  /* if */
  preinfo = buildpredefnode(ifntype, line, LINK);
  preinfo->port_ = 1;
  addedge(exp1->graphinfo, preinfo);
  preinfo->port_ = 2;
  addedge(exp2->graphinfo, preinfo);
  preinfo->port_ = 1;
  preinfo->typeptr = exp1->graphinfo->typeptr;
  return preinfo;
}  /* MaxMin */

static inforecord *addhlarrayorstream(iftype, expl, ifntype, line, functname, LINK)
char iftype;
semanticrec *expl;
unchar ifntype;
int line;
stryng functname;
struct LOC_dopredefined *LINK;
{
  explistnode *exp;
  inforecord *predefgraphinfo;

  checknumberofargs(expl, 2, functname, LINK);
  exp = expl->UU.explist;
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort != iftype) {
    wrongargtype(1, functname, LINK);
    exp->graphinfo = errtype_(iftype, exp->next->graphinfo->typeptr, LINK);
  }  /* if */
  if (exp->graphinfo->typeptr->UU.stbasetype != exp->next->graphinfo->typeptr)
    wrongargtype(2, functname, LINK);
  predefgraphinfo = buildpredefnode(ifntype, line, LINK);
  predefgraphinfo->port_ = 1;
  addedge(exp->graphinfo, predefgraphinfo);
  predefgraphinfo->port_ = 2;
  addedge(exp->next->graphinfo, predefgraphinfo);
  predefgraphinfo->port_ = 1;
  predefgraphinfo->typeptr = exp->graphinfo->typeptr;
  return predefgraphinfo;
}  /* AddHLArrayOrStream */

static inforecord *sizearrayorstream(predefkind, iftype, expl, line, functname, LINK)
predeftype predefkind;
char iftype;
semanticrec *expl;
int line;
stryng functname;
struct LOC_dopredefined *LINK;
{
  explistnode *exp;
  inforecord *info;

  checknumberofargs(expl, 1, functname, LINK);
  exp = expl->UU.explist;
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort != iftype) {
    info = newinfoptr();
    string10(&info->litvalue, "error     ");
    wrongargtype(1, functname, LINK);
  }  /* if */
  else {
    if (predefkind == tgarraysize || predefkind == tgstreamsize)
      info = buildpredefnode(ifnasize, line, LINK);
    else
      info = buildpredefnode(ifnaprefixsize, line, LINK);
    info->port_ = 1;
    addedge(exp->graphinfo, info);
  }  /* else */
  info->typeptr = getbasictype(ifbinteger);
  return info;
}  /* SizeArrayOrStream */

static inforecord *remhlarrayorstream(iftype, expl, ifntype, line, functname, LINK)
char iftype;
semanticrec *expl;
unchar ifntype;
int line;
stryng functname;
struct LOC_dopredefined *LINK;
{
  stentry *bwild;
  inforecord *info;
  explistnode *exp;

  checknumberofargs(expl, 1, functname, LINK);
  exp = expl->UU.explist;
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort != iftype) {
    bwild = getbasictype(ifbwild);
    exp->graphinfo = errtype_(iftype, bwild, LINK);
    wrongargtype(1, functname, LINK);
  }  /* if */
  info = buildpredefnode(ifntype, line, LINK);
  info->port_ = 1;
  addedge(exp->graphinfo, info);
  info->typeptr = exp->graphinfo->typeptr;
  return info;
}  /* RemHLArrayOrStream */

static inforecord *arraylimhorl(ntype, semexplist, line, functname, LINK)
unchar ntype;
semanticrec *semexplist;
int line;
stryng functname;
struct LOC_dopredefined *LINK;
{
  stentry *bwild;
  inforecord *predefgraphinfo;
  explistnode *exp;

  checknumberofargs(semexplist, 1, functname, LINK);
  exp = semexplist->UU.explist;
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort != iftarray) {
    wrongargtype(1, functname, LINK);
    bwild = getbasictype(ifbwild);
    exp->graphinfo = errtype_(iftarray, bwild, LINK);
  }
  predefgraphinfo = buildpredefnode(ntype, line, LINK);
  predefgraphinfo->port_ = 1;
  addedge(exp->graphinfo, predefgraphinfo);
  predefgraphinfo->typeptr = getbasictype(ifbinteger);
  return predefgraphinfo;
}  /* ArrayLimHOrL*/

static inforecord *floorortrunc(ntype, semexplist, line, functname, LINK)
unchar ntype;
semanticrec *semexplist;
int line;
stryng functname;
struct LOC_dopredefined *LINK;
{
  explistnode *exp;
  inforecord *predefgraphinfo;

  checknumberofargs(semexplist, 1, functname, LINK);
  exp = semexplist->UU.explist;
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stlabel != reallabel &&
      exp->graphinfo->typeptr->stlabel != doublabel) {
    exp->graphinfo = newinfoptr();
    string10(&exp->graphinfo->litvalue, "error     ");
    exp->graphinfo->typeptr = getbasictype(ifbreal);
    wrongargtype(1, functname, LINK);
  }  /* if */
  predefgraphinfo = buildpredefnode(ntype, line, LINK);
  predefgraphinfo->port_ = 1;
  addedge(exp->graphinfo, predefgraphinfo);
  predefgraphinfo->typeptr = getbasictype(ifbinteger);
  return predefgraphinfo;
}  /* FloorOrTrunc */


static void dopredefined(symptr, semexplist, line_)
symtblbucket *symptr;
semanticrec *semexplist;
int line_;
{
  /*  This procedure builds a call node for any of the predefined SISAL
      functions.  It checks the types and arity of the arguments and
      pushes an explist containing the graphinfo for the output of the
      call node.*/
  struct LOC_dopredefined V;
  inforecord *predefgraphinfo, *index;
  stentry *bwild, *newt;
  explistnode *exp, *exp2, *low, *high;

  V.line = line_;
  if (semtrace)
    printf("begin DoPreDefined\n");
  if (semexplist->UU.explist == NULL) {
    notenoughargs(symptr->name, &V);
    semexplist->UU.explist = newexplistptr();
    semexplist->UU.explist->graphinfo->typeptr = getbasictype(ifbwild);
    string10(&semexplist->UU.explist->graphinfo->name, "ERROR     ");
    stripspaces(&semexplist->UU.explist->graphinfo->name);
    string10(&semexplist->UU.explist->graphinfo->litvalue, "ERROR     ");
  } else {
    switch (symptr->UU.predefined) {

    case tgfloor:
      semexplist->UU.explist->graphinfo = floorortrunc(ifnfloor, semexplist,
          V.line, symptr->name, &V);
      break;

    case tgtrunc:
      semexplist->UU.explist->graphinfo = floorortrunc(ifntrunc, semexplist,
          V.line, symptr->name, &V);
      break;

    case tgmax:
      semexplist->UU.explist->graphinfo = maxmin(ifnmax, semexplist, V.line,
                                                 symptr->name, &V);
      break;

    case tgmin:
      semexplist->UU.explist->graphinfo = maxmin(ifnmin, semexplist, V.line,
                                                 symptr->name, &V);
      break;

    case tgmod:
      checknumberofargs(semexplist, 2, symptr->name, &V);
      exp = semexplist->UU.explist;
      if (exp->graphinfo->typeptr == NULL)
        exp->graphinfo->typeptr = getbasictype(ifbwild);
      exp2 = exp->next;
      if (exp2->graphinfo->typeptr == NULL)
        exp2->graphinfo->typeptr = getbasictype(ifbwild);
      if (exp->graphinfo->typeptr->stlabel != intlabel) {
        exp->graphinfo = getalit1_(&V);
        wrongargtype(1, symptr->name, &V);
      }  /* if */
      if (exp2->graphinfo->typeptr->stlabel != intlabel) {
        exp2->graphinfo = getalit1_(&V);
        wrongargtype(2, symptr->name, &V);
      }  /* if */
      predefgraphinfo = buildpredefnode(ifnmod, V.line, &V);
      predefgraphinfo->port_ = 1;
      addedge(exp->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 2;
      addedge(exp2->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 1;
      predefgraphinfo->typeptr = exp->graphinfo->typeptr;
      semexplist->UU.explist->graphinfo = predefgraphinfo;
      break;

    case tgabs:
      checknumberofargs(semexplist, 1, symptr->name, &V);
      if (semexplist->UU.explist->graphinfo->typeptr == NULL)
        semexplist->UU.explist->graphinfo->typeptr = getbasictype(ifbwild);
      if ((unsigned)semexplist->UU.explist->graphinfo->typeptr->stlabel >= 32 ||
          ((1L << semexplist->UU.explist->graphinfo->typeptr->stlabel) &
           arithtypes) == 0)
        wrongargtype(1, symptr->name, &V);
      predefgraphinfo = buildpredefnode(ifnabs, V.line, &V);
      predefgraphinfo->port_ = 1;
      addedge(semexplist->UU.explist->graphinfo, predefgraphinfo);
      predefgraphinfo->typeptr = semexplist->UU.explist->graphinfo->typeptr;
      semexplist->UU.explist->graphinfo = predefgraphinfo;
      break;

    case tgexp:
      predefgraphinfo = buildpredefnode(ifnexp, V.line, &V);
      checknumberofargs(semexplist, 2, symptr->name, &V);
      if (semexplist->UU.explist->graphinfo->typeptr == NULL)
        semexplist->UU.explist->graphinfo->typeptr = getbasictype(ifbwild);
      if ((unsigned)semexplist->UU.explist->graphinfo->typeptr->stlabel >= 32 ||
          ((1L << semexplist->UU.explist->graphinfo->typeptr->stlabel) &
           arithtypes) == 0)
        wrongargtype(1, symptr->name, &V);
      else {
        predefgraphinfo->typeptr = semexplist->UU.explist->graphinfo->typeptr;
        switch (semexplist->UU.explist->graphinfo->typeptr->stlabel) {

        case intlabel:
          if (semexplist->UU.explist->next->graphinfo->typeptr->stlabel !=
              intlabel)
            wrongargtype(2, symptr->name, &V);
          break;

        case reallabel:
          if (semexplist->UU.explist->next->graphinfo->typeptr->stlabel !=
              intlabel && semexplist->UU.explist->next->graphinfo->typeptr->
                          stlabel != reallabel)
            wrongargtype(2, symptr->name, &V);
          break;

        case doublabel:
          if (semexplist->UU.explist->next->graphinfo->typeptr->stlabel !=
              intlabel && semexplist->UU.explist->next->graphinfo->typeptr->
                          stlabel != doublabel)
            wrongargtype(2, symptr->name, &V);
          break;
        }/*case*/
      }  /*else*/
      predefgraphinfo->port_ = 1;
      addedge(semexplist->UU.explist->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 2;
      addedge(semexplist->UU.explist->next->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 1;
      if (predefgraphinfo->typeptr == getbasictype(ifbinteger)) {
        predefgraphinfo->typeptr = getbasictype(ifbreal);
        predefgraphinfo = addintnode(predefgraphinfo, &V);
      }
      semexplist->UU.explist->graphinfo = predefgraphinfo;
      break;

    case tgarrayaddh:
      semexplist->UU.explist->graphinfo = addhlarrayorstream(iftarray,
          semexplist, ifnaaddh, V.line, symptr->name, &V);
      break;

    case tgarrayaddl:
      semexplist->UU.explist->graphinfo = addhlarrayorstream(iftarray,
          semexplist, ifnaaddl, V.line, symptr->name, &V);
      break;

    case tgarraysize:
    case tgarrayprefixsize:
      semexplist->UU.explist->graphinfo = sizearrayorstream(
          symptr->UU.predefined, iftarray, semexplist, V.line, symptr->name,
          &V);
      break;

    case tgarrayreml:
      semexplist->UU.explist->graphinfo = remhlarrayorstream(iftarray,
          semexplist, ifnareml, V.line, symptr->name, &V);
      break;

    case tgarrayremh:
      semexplist->UU.explist->graphinfo = remhlarrayorstream(iftarray,
          semexplist, ifnaremh, V.line, symptr->name, &V);
      break;

    case tgarraylimh:
      semexplist->UU.explist->graphinfo = arraylimhorl(ifnalimh, semexplist,
          V.line, symptr->name, &V);
      break;

    case tgarrayliml:
      semexplist->UU.explist->graphinfo = arraylimhorl(ifnaliml, semexplist,
          V.line, symptr->name, &V);
      break;

    case tgarrayadjust:
      checknumberofargs(semexplist, 3, symptr->name, &V);
      exp = semexplist->UU.explist;
      if (exp->graphinfo->typeptr == NULL)
        exp->graphinfo->typeptr = getbasictype(ifbwild);
      if (exp->graphinfo->typeptr->stsort != iftarray) {
        bwild = getbasictype(ifbwild);
        exp->graphinfo = errtype_(iftarray, bwild, &V);
        wrongargtype(1, symptr->name, &V);
      }  /* if */
      low = exp->next;
      if (low->graphinfo->typeptr == NULL)
        low->graphinfo->typeptr = getbasictype(ifbwild);
      if (low->graphinfo->typeptr->stlabel != intlabel) {
        low->graphinfo = getalit1_(&V);
        wrongargtype(2, symptr->name, &V);
      }  /* if */
      high = low->next;
      if (high->graphinfo->typeptr == NULL)
        high->graphinfo->typeptr = getbasictype(ifbwild);
      if (high->graphinfo->typeptr->stlabel != intlabel) {
        high->graphinfo = getalit1_(&V);
        wrongargtype(3, symptr->name, &V);
      }  /* if */
      predefgraphinfo = buildpredefnode(ifnaextract, V.line, &V);
      predefgraphinfo->port_ = 1;
      addedge(exp->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 2;
      addedge(low->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 3;
      addedge(high->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 1;
      predefgraphinfo->typeptr = exp->graphinfo->typeptr;
      exp->graphinfo = predefgraphinfo;
      break;

    case tgarrayfill:
      checknumberofargs(semexplist, 3, symptr->name, &V);
      low = semexplist->UU.explist;
      if (low->graphinfo->typeptr == NULL)
        low->graphinfo->typeptr = getbasictype(ifbwild);
      if (low->graphinfo->typeptr->stlabel != intlabel) {
        low->graphinfo = getalit1_(&V);
        wrongargtype(1, symptr->name, &V);
      }  /* if */
      high = low->next;
      if (high->graphinfo->typeptr == NULL)
        high->graphinfo->typeptr = getbasictype(ifbwild);
      if (high->graphinfo->typeptr->stlabel != intlabel) {
        high->graphinfo = getalit1_(&V);
        wrongargtype(2, symptr->name, &V);
      }  /* if */
      exp = high->next;
      predefgraphinfo = buildpredefnode(ifnafill, V.line, &V);
      predefgraphinfo->port_ = 1;
      addedge(low->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 2;
      addedge(high->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 3;
      addedge(exp->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 1;
      newttptr(&newt, iftarray);
      newt->UU.stbasetype = exp->graphinfo->typeptr;
      predefgraphinfo->typeptr = addtotypetable(newt);
      semexplist->UU.explist->graphinfo = predefgraphinfo;
      break;

    case tgarraysetl:
      checknumberofargs(semexplist, 2, symptr->name, &V);
      exp = semexplist->UU.explist;
      if (exp->graphinfo->typeptr == NULL)
        exp->graphinfo->typeptr = getbasictype(ifbwild);
      if (exp->graphinfo->typeptr->stsort != iftarray) {
        bwild = getbasictype(ifbwild);
        exp->graphinfo = errtype_(iftarray, bwild, &V);
        wrongargtype(1, symptr->name, &V);
      }  /* if */
      low = exp->next;
      if (low->graphinfo->typeptr == NULL)
        low->graphinfo->typeptr = getbasictype(ifbwild);
      if (low->graphinfo->typeptr->stlabel != intlabel) {
        low->graphinfo = getalit1_(&V);
        wrongargtype(2, symptr->name, &V);
      }  /* if */
      predefgraphinfo = buildpredefnode(ifnasetl, V.line, &V);
      predefgraphinfo->port_ = 1;
      addedge(exp->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 2;
      addedge(low->graphinfo, predefgraphinfo);
      predefgraphinfo->port_ = 1;
      predefgraphinfo->typeptr = exp->graphinfo->typeptr;
      semexplist->UU.explist->graphinfo = predefgraphinfo;
      break;

/* CANN PEEK */ case tgpeek:
/* CANN PEEK */ predefgraphinfo = buildpredefnode(ifnpeek, V.line, &V);
/* CANN PEEK */ {
/* CANN PEEK */   int c;
/* CANN PEEK */   for ( c=1, exp = semexplist->UU.explist; exp != NULL; exp = exp->next, c++ ) {
/* CANN PEEK */     if (exp->graphinfo->typeptr == NULL)
/* CANN PEEK */       exp->graphinfo->typeptr = getbasictype(ifbwild);
/* CANN PEEK */     predefgraphinfo->port_ = c;
/* CANN PEEK */     addedge(exp->graphinfo, predefgraphinfo);
/* CANN PEEK */     }
/* CANN PEEK */ }
/* CANN PEEK */ predefgraphinfo->port_ = 1;
/* CANN PEEK */ predefgraphinfo->typeptr = getbasictype(ifbinteger);
/* CANN PEEK */ semexplist->UU.explist->graphinfo = predefgraphinfo;
/* CANN PEEK */ break;

    case tgstreamempty:
      checknumberofargs(semexplist, 1, symptr->name, &V);
      exp = semexplist->UU.explist;
      if (exp->graphinfo->typeptr == NULL)
        exp->graphinfo->typeptr = getbasictype(ifbwild);
      if (exp->graphinfo->typeptr->stsort != iftstream) {
        bwild = getbasictype(ifbwild);
        exp->graphinfo = errtype_(iftstream, bwild, &V);
        wrongargtype(1, symptr->name, &V);
      }
      predefgraphinfo = buildpredefnode(ifnaisempty, V.line, &V);
      predefgraphinfo->port_ = 1;
      addedge(exp->graphinfo, predefgraphinfo);
      predefgraphinfo->typeptr = getbasictype(ifbboolean);
      semexplist->UU.explist->graphinfo = predefgraphinfo;
      break;

    case tgstreamrest:
      semexplist->UU.explist->graphinfo = remhlarrayorstream(iftstream,
          semexplist, ifnareml, V.line, symptr->name, &V);
      break;

    case tgstreamsize:
    case tgstreamprefixsize:
      semexplist->UU.explist->graphinfo = sizearrayorstream(
          symptr->UU.predefined, iftstream, semexplist, V.line, symptr->name,
          &V);
      break;

    case tgstreamappend:
      semexplist->UU.explist->graphinfo = addhlarrayorstream(iftstream,
          semexplist, ifnaaddh, V.line, symptr->name, &V);
      break;

    case tgstreamfirst:
      checknumberofargs(semexplist, 1, symptr->name, &V);
      if (semexplist->UU.explist->graphinfo->typeptr == NULL)
        semexplist->UU.explist->graphinfo->typeptr = getbasictype(ifbwild);
      if (semexplist->UU.explist->graphinfo->typeptr->stsort != iftstream) {
        wrongargtype(1, symptr->name, &V);
        bwild = getbasictype(ifbwild);
        semexplist->UU.explist->graphinfo = errtype_(iftstream, bwild, &V);
      }  /* if */
      predefgraphinfo = buildpredefnode(ifnaelement, V.line, &V);
      predefgraphinfo->port_ = 1;
      addedge(semexplist->UU.explist->graphinfo, predefgraphinfo);
      index = newinfoptr();
      string10(&index->litvalue, "1         ");
      index->typeptr = getbasictype(ifbinteger);
      predefgraphinfo->port_ = 2;
      addedge(index, predefgraphinfo);
      predefgraphinfo->port_ = 1;
      predefgraphinfo->typeptr = semexplist->UU.explist->graphinfo->typeptr->
                                 UU.stbasetype;
      semexplist->UU.explist->graphinfo = predefgraphinfo;
      break;
      /* TGStreamFirst */
    default:
       ;
    }/*case*/
  }  /*else*/
  semexplist->UU.explist->next = NULL;
  pushsemantic(semexplist);
}  /*DoPreDefined*/


static void initsem()
{
  /*action 9 initsem*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Initialize the symbol table, semantic stack, the if1 graph
          for the program and misc variables.*/
  if (semtrace)
    printf("begin initsem\n");
  initsymtable();
  initnames();
  initmodule();
  P_expset(stampset, 0L);
  topsemstk = NULL;
  topincludestk = NULL;
  univnodecnt = 1;
  binaryops = (1L << ((long)orop)) | (1L << ((long)andop)) |
      (1L << ((long)mult)) | (1L << ((long)divd)) | (1L << ((long)plus)) |
      (1L << ((long)minus)) | (1L << ((long)concat)) | (1L << ((long)lt)) |
      (1L << ((long)le)) | (1L << ((long)gt)) | (1L << ((long)ge)) |
      (1L << ((long)equal)) | (1L << ((long)notequal));
/* p2c: mono.bin.noblank.p, line 18087: Note:
 * Line breaker spent 1.9+0.96 seconds, 1390 tries on line 21328 [251] */
  arithtypes = (1L << intlabel) | (1L << doublabel) | (1L << reallabel);
  algebtypes = arithtypes | (1L << boollabel);
  streamorarray = (1L << iftarray) | (1L << iftstream);
  boostfac = 0;
  idxrefmax = 0;
}


static boolean linkdefinename(name, list)
stryng name;
namelistrec **list;
{
  /* Check to see if name is already on list, if not return false and
     add it to the end of the list, else return true.*/
  namelistrec *listptr;
  boolean found, error;
  stryng name1, name2;

  found = false;
  error = false;
  if (*list == NULL) {
    newnamelist(list);
    (*list)->name = name;
    (*list)->linenum = linenumber;
    return error;
  }
  name1 = name;
  stringuppercase(&name1);
  listptr = *list;
  while (listptr->next != NULL) {
    name2 = listptr->name;
    stringuppercase(&name2);
    if (equalstrings(&name1, &name2))
      found = true;
    listptr = listptr->next;
  }  /*while*/
  name2 = listptr->name;
  stringuppercase(&name2);
  if (equalstrings(&name1, &name2) || found) {
    error = true;
    return error;
  }
  newnamelist(&listptr->next);
  listptr->next->name = name;
  listptr->next->linenum = linenumber;
  listptr->next->prev = listptr;
  return error;

  /*else*/
  /*else*/
}  /*LinkDefineName*/


static void addtodefinelist(inputtoken)
stryng inputtoken;
{
  /*action 23*/
  /*stackpops - tgnamelist
                  pushes - tgnamelist*/
  /*description
    Pop the namelist off the stack.  Check that <NAME> (input token) isn't
    already on the list, if so declare a warning else add it to the list
    and save the list back on the stack.*/
  semanticrec *semrec;
  boolean error;
  errorrecord *errorrec;

  if (semtrace)
    printf("begin AddToDefineList\n");
  semrec = popsemantic();
  error = linkdefinename(inputtoken, &semrec->UU.namelist);
  if (error) {
    errorrec = newerrorptr(defineerr);
    errorrec->UU.errorstr = inputtoken;
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  pushsemantic(semrec);
}  /* addtodefinelist */


static void addtotypelist()
{
  /*action 5 AddToTypeList*/
  /*stackpops - tgTTptr
                         tgtypelist
                  pushes - tgtypelist*/
  /*description
          Add the TTptr to the end of the typelist.*/
  semanticrec *semttptr, *semtypelist;
  typelistrec *curtypelist, *entry_;

  if (semtrace)
    printf("Begin addtotypelist\n");
  semttptr = popsemantic();
  semtypelist = popsemantic();
  newtypelist(&entry_);
  entry_->typeptr = semttptr->UU.ttptr;
  entry_->linenum = linenumber;
  curtypelist = semtypelist->UU.typelist;
  if (curtypelist == NULL)
    semtypelist->UU.typelist = entry_;
  else {
    while (curtypelist->next != NULL)
      curtypelist = curtypelist->next;
    curtypelist->next = entry_;
    entry_->prev = curtypelist;
  }  /*else*/
  freesemantic(&semttptr);
  pushsemantic(semtypelist);
}  /* addtotypelist */


static void starttypelist()
{
  /*action 4 StartTypeList*/
  /*stackpops - nothing
                  pushes - tgtypelist (empty)*/
  /*description
          Places an empty typelist on the stack*/
  semanticrec *semrec;

  if (semtrace)
    printf("Begin StartTypeList \n");
  newsemantic(&semrec, tgtypelist);
  pushsemantic(semrec);
}  /* starttypelist */


stryng buildfunctname(name)
stryng name;
{
  /* Build the IF1 function name by prepending all the outer function names
     to the SISAL function name.  This is required because IF1 doesn't have
     a Lex Level structure.*/
  stryng newname;
  treestackobj *level;
  symtblbucket *symptrlevelname;
  stryng levelname, dot;

  mymemcpy(dot.str, blankstring, sizeof(stryngar));
  dot.len = 0;
  insertchar(&dot, '.', 1);
  newname = name;
  level = currentlevel;
  while (level->lleveltag != root) {
    if (level->lleveltag != funct) {
      continue;
    }  /*then*/
    symptrlevelname = level->UU.lfunctname;
    levelname = symptrlevelname->name;
    insertstring(&newname, &dot, 1);
    insertstring(&newname, &levelname, 1);
    level = level->lastlevel;
  }  /*while*/
  return newname;
}  /*BuildFunctName*/


static void addlkptr(lk)
linkrec *lk;
{
  linkrec *curlkptr;

  curlkptr = funclist;   /* global pointer to linkage rec list */
  if (curlkptr == NULL) {   /*  the list is empty */
    funclist = lk;
    return;
  }
  while (curlkptr->lknext != NULL)
    curlkptr = curlkptr->lknext;
  curlkptr->lknext = lk;

  /* else */
}  /*AddLKptr*/

static void addgrptr_(gr)
graph *gr;
{
  graph *curgrptr;

  curgrptr = module->UU.U2.ndsubsid;
  if (curgrptr == NULL) {   /* the list is empty */
    module->UU.U2.ndsubsid = gr;
    firstfunction = gr->grnode;
    return;
  }  /*then*/
  while (curgrptr->grnext != NULL)
    curgrptr = curgrptr->grnext;
  curgrptr->grnext = gr;

  /*else*/
}  /*AddGRptr*/

static void buildfunctgraph(symptr, functname, action, exported)
symtblbucket *symptr;
stryng functname;
int action;
boolean exported;
{
  /* Build the framework for a new function and hook it into the
     IF1 graph we are creating.*/
  graph *gr;
  linkrec *lk;
  node *nd;
  int defloc2;

  nd = newnodeptr(ndgraph, currentlevel);
  if (action == 1 && exported)
    lk = newlinkageptr(lsexported);
  else if (action == 1)
    lk = newlinkageptr(lslocal);
  else
    lk = newlinkageptr(lsimported);
  gr = newgraphptr();
  gr->grnode = nd;
  lk->lkgraph = nd;
  lk->lkname = functname;
  addlkptr(lk);
  addgrptr_(gr);
  nd->ndcode = ifngraph;
  nd->ndparent = module;
  nd->UU.U1.ndlink = lk;
  nd->UU.U1.ndtype = symptr->typeptr;
  defloc2 = getdefline(symptr, 2);
  if (defloc2 == -1)   /* If 2nd Def Loc = -1 there was no forward dec.*/
    nd->ndsrcline = getdefline(symptr, 1);
  else
    nd->ndsrcline = defloc2;
  /*use 2nd, cause 1st is for the forward*/
  currentlevel->prevnode = nd;
  symptr->graphinfo->node_ = nd;
}  /*BuildFunctGraph*/

static boolean checkdefinelist(functname, action)
stryng functname;
int action;
{
  /*Check the DefineList for FunctName, if found remove it.*/
  namelistrec *nameptr;
  boolean found;
  namelistrec *nextnameptr;
  stryng lowerfunctname, lowername;

  found = false;
  nameptr = definelist;
  lowerfunctname = functname;
  stringlowercase(&lowerfunctname);
  while (nameptr != NULL && !found) {
    lowername = nameptr->name;
    stringlowercase(&lowername);
    if (!equalstrings(&lowername, &lowerfunctname)) {
      nameptr = nameptr->next;
      continue;
    }  /*then*/
    found = true;
    if (action != 1) {   /* if not a global function also */
      continue;
    }  /*then*/
    if (nameptr->next != NULL)
      nameptr->next->prev = nameptr->prev;
    if (nameptr->prev != NULL)
      nameptr->prev->next = nameptr->next;
    nextnameptr = nameptr->next;
    if (nameptr == definelist)
      definelist = nextnameptr;
    freenamelist(&nameptr);
    nameptr = nextnameptr;
  }  /*while*/
  return found;
}  /*CheckDefineList*/


static void startfunction(inputtoken, action, line, col)
stryng inputtoken;
int action, line, col;
{
  /*action 1 StartFunction and 25 StartGlobalFunct*/
  /*stackpops - nothing
                  pushes - tgsymptr*/
  /*description
          If we are at the outer most level, then check to see if the
          funct name is on the DefineList.  If so, remove it.  If this
          is not a Global function def, get a SymTblPtr and set it's type
          to TFunction.  If this is a global function def, make sure
          that the name did not appear on the DefineList.  Build the
          if1 function name by prepending any outer function names to
          this function name.  This is needed because if1 had a flat
          scope.  Start a new lexlevel of type Funct if this is a local
          function.  Build the function graph structure.  Save the
          SymTblPtr on the stack.*/
  semanticrec *semrec;
  stentry *ttptr;
  stryng functname;
  boolean exported;
  errorrecord *errorrec;

  if (semtrace) {
    if (action == 1)
      printf("Begin StartFunction\n");
    else
      printf("Begin StartGlobalFunct\n");
  }
  newsemantic(&semrec, tgsymptr);
  if (currentlevel->lleveltag == root)   /*if at outer level, check for */
    exported = checkdefinelist(inputtoken, action);   /*name on DefineList*/
  else
    exported = false;
  if (action == 1)
    semrec->UU.symptr = createbucket(tfunction);
  else {
    semrec->UU.symptr = createbucket(tglobal);
    if (exported) {   /* can't be both global and exported */
      errorrec = newerrorptr(expimporterr);
      errorrec->UU.errorstr = inputtoken;
      errorrec->linenumber = line;
      semerror(errorrec);
    }  /*then*/
  }
  functname = buildfunctname(inputtoken);
  setname(semrec->UU.symptr, inputtoken);
  setdefloc(semrec->UU.symptr, line, col);
  semrec->UU.symptr->graphinfo->port_ = 1;
  semrec->UU.symptr->graphinfo->litvalue = functname;
  newttptr(&ttptr, iftfunctiontype);
  semrec->UU.symptr->typeptr = ttptr;
  if (action == 1) {   /* if this is a local function */
    createlevel(funct);
    currentlevel->UU.lfunctname = semrec->UU.symptr;
  }
  buildfunctgraph(semrec->UU.symptr, functname, action, exported);
  pushsemantic(semrec);
}  /* startfunction */


static void enddefinelist()
{
  /*action 22 EndDefineList*/
  /*stackpops - tgnamelist
                  pushes - nothing*/
  /*description
          Save the namelist found on the stack in the variable called
          DefineList.  As functions at the outer most level are ,
          if their name occurs in the DefineList, it is removed.  At the
          end of compiling a modlue, no functions names should remain
          on the DefineList.*/
  semanticrec *semrec;

  if (semtrace)
    printf("Begin EndDefineList\n");
  semrec = popsemantic();
  definelist = semrec->UU.namelist;
  freesemantic(&semrec);
}


static void startforwardfunct(inputtoken, line, col)
stryng inputtoken;
int line, col;
{
  /*action 24 StartForwardFunct*/
  /*stackpops - nothing
                  pushes - tgsymptr*/
  /*description
          Get a symbol table pointer and set its tag to TForward.  Get a
          type table pointer for a function and connect it to the symptr.
          Save the symptr on the stack.*/
  semanticrec *semrec;
  stentry *ttptr;
  stryng functname;

  if (semtrace)
    printf("begin StartForwardFunct\n");
  newsemantic(&semrec, tgsymptr);
  semrec->UU.symptr = createbucket(tforward);
  setname(semrec->UU.symptr, inputtoken);
  setdefloc(semrec->UU.symptr, line, col);
  newttptr(&ttptr, iftfunctiontype);
  semrec->UU.symptr->typeptr = ttptr;
  functname = buildfunctname(inputtoken);
  semrec->UU.symptr->graphinfo->litvalue = functname;
  pushsemantic(semrec);
}


static void addfunctargtype(functttptr, argttptr)
stentry *functttptr, *argttptr;
{
  /* Add the type ArgTTptr to the argument type list of function type
     functTTptr.*/
  stentry *tupptr, *curtupptr;

  newttptr(&tupptr, ifttuple);
  tupptr->UU.U2.stelemtype = argttptr;
  curtupptr = functttptr->UU.U3.starg;
  if (curtupptr == NULL) {
    functttptr->UU.U3.starg = tupptr;
    return;
  }
  while (curtupptr->UU.U2.stnext != NULL)
    curtupptr = curtupptr->UU.U2.stnext;
  curtupptr->UU.U2.stnext = tupptr;

  /*else*/
}  /*AddFunctArgType*/


static void processparam()
{
  /*action 27 ProcessParam*/
  /*stackpops - tgTTPtr
                       - tgnamelist
                       - tgsymptr
                  pushes - tgsymptr*/
  /*description
          The tgsymptr is for a function name.  If this function isn't
          global or forward, get Stptr's for each name on the namelist
          and hash them in.  Get TypeTPtrs for each arg and link them
          together on the functions type table entry's arg list.
          Check to make sure all the arg names are distinct.  Push
          the STptr for the function back on the stack.*/
  semanticrec *semttptr, *semnamelist, *semsymptr;
  boolean realfunct;
  symtblbucket *symptr;
  namelistrec *param;
  int portnum;
  errorrecord *errorrec;

  if (semtrace)
    printf("Begin ProcessParam\n");
  semttptr = popsemantic();
  semnamelist = popsemantic();
  semsymptr = popsemantic();
  if (semsymptr->UU.symptr->identtag == tfunction)
    realfunct = true;
  else
    realfunct = false;
  param = semnamelist->UU.namelist;
  portnum = semsymptr->UU.symptr->graphinfo->port_;
  while (param != NULL) {
    if (realfunct) {
      if (incurrentlevel(param->name, tparam) != NULL) {
        errorrec = newerrorptr(doubledefarg);
        errorrec->UU.errorstr = param->name;
        errorrec->linenumber = param->linenum;
        semerror(errorrec);
      }
      symptr = createbucket(tparam);
      symptr->typeptr = semttptr->UU.ttptr;
      setname(symptr, param->name);
      setdefloc(symptr, param->linenum, param->column);
      addtotable(symptr, currentlevel);
      symptr->graphinfo->port_ = portnum;
      symptr->graphinfo->node_ = semsymptr->UU.symptr->graphinfo->node_;
      symptr->graphinfo->typeptr = semttptr->UU.ttptr;
    }  /*then*/
    addfunctargtype(semsymptr->UU.symptr->typeptr, semttptr->UU.ttptr);
    if (param->next != NULL) {
      param = param->next;
      freenamelist(&param->prev);
    }  /*then*/
    else {
      freenamelist(&param);
      param = NULL;
    }  /*else*/
    portnum++;
  }  /*while*/
  semsymptr->UU.symptr->graphinfo->port_ = portnum;
  freesemantic(&semnamelist);
  freesemantic(&semttptr);
  pushsemantic(semsymptr);
}


static void addfunctrestype(functttptr, resttptr)
stentry *functttptr, *resttptr;
{
  /* Add the type ResTTptr to the result type list of function type
     functTTptr.*/
  stentry *tupptr, *curtupptr;

  newttptr(&tupptr, ifttuple);
  tupptr->UU.U2.stelemtype = resttptr;
  curtupptr = functttptr->UU.U3.stres;
  if (curtupptr == NULL) {
    functttptr->UU.U3.stres = tupptr;
    return;
  }
  while (curtupptr->UU.U2.stnext != NULL)
    curtupptr = curtupptr->UU.U2.stnext;
  curtupptr->UU.U2.stnext = tupptr;

  /*else*/
}  /*AddFunctResType*/


static void doresultlist(typelist, symptr)
typelistrec *typelist;
symtblbucket *symptr;
{
  /* Build the result list for the function.*/
  typelistrec *curtypelist;
  stentry *functttptr;

  curtypelist = typelist;
  functttptr = symptr->typeptr;
  while (curtypelist != NULL) {
    addfunctrestype(functttptr, curtypelist->typeptr);
    if (curtypelist->next != NULL) {
      curtypelist = curtypelist->next;
      freetypelist(&curtypelist->prev);
    }  /*then*/
    else {
      freetypelist(&curtypelist);
      curtypelist = NULL;
    }  /*else*/
  }  /*while*/
}  /*DoResultList*/


boolean checklastlevel(name, itype, bucket)
stryng name;
identtype itype;
symtblbucket **bucket;
{
  /* Search level one back from current for a function of type Itype and
     name name.*/
  boolean found;
  int hashvalue;

  found = false;
  stringlowercase(&name);
  hashvalue = hash(stringchar(&name, 1), stringchar(&name, name.len));
  *bucket = currentlevel->lastlevel->hashtable[hashvalue];
  while (*bucket != NULL && !found) {
    if (equalstrings(&(*bucket)->name, &name)) {
      switch (itype) {

      case tforward:
        if ((*bucket)->identtag == tforward)
          found = true;
        break;

      case tfunction:
        if ((*bucket)->identtag == tfunction)
          found = true;
        break;
      default:
         ;
      }/*case*/
    }
    if (!found)
      *bucket = (*bucket)->nextbucket;
  }  /*while*/
  return found;
}  /*CheckLastLevel*/


static void freelist(list)
stentry *list;
{
  stentry *nexttypeptr, *freetypeptr;

  freetypeptr = list;
  if (freetypeptr == NULL) {
    return;
  }  /*then*/
  nexttypeptr = freetypeptr->UU.U2.stnext;
  while (nexttypeptr != NULL) {
    freettptr(&freetypeptr);
    freetypeptr = nexttypeptr;
    nexttypeptr = freetypeptr->UU.U2.stnext;
  }  /*while*/
  freettptr(&freetypeptr);
}  /*FreeList*/


static void freefuncttype(functtypeptr)
stentry *functtypeptr;
{  /*FreeTypeList*/
  freelist(functtypeptr->UU.U3.starg);
  freelist(functtypeptr->UU.U3.stres);
  freettptr(&functtypeptr);
}  /*FreeTypeList*/


static void endfunctionheader()
{
  /*action 29 EndFunctionHeader*/
  /*stackpops - tgtypelist
                         tgsymptr
                  pushes - tgsymptr*/
  /*description
          The symptr is for a function.  The typelist contains the types
          that the function returns.  Link the types on the list to the
          functions reslist in the type table.  Check for a function with
          the came name one level back.  If one exist declare an error.
          Check for a forward function one level back.  If one exists,
          check that it's type and the type of the one we are processing
          are the same.  If not, declare an error, else change the forward
          function to a real function.  Check that no other function has
          been defined in this scope with this name.  The manual says
          this is illegal, although most people believe it should be
          ok.  Smach the function into the type table and save it's
          symbol table entry on the stack.*/
  semanticrec *semtypelist, *semsymptr;
  stryng functname;
  treestackobj *levelfoundat;
  symtblbucket *bucketfoundin;
  stentry *smashedtypeptr, *functtypeptr, *forwardtypeptr;
  int linenum, colnum;
  node *fnode;
  errorrecord *errorrec;

  if (semtrace)
    printf("Begin EndFunctionHeader\n");
  semtypelist = popsemantic();
  semsymptr = popsemantic();
  doresultlist(semtypelist->UU.typelist, semsymptr->UU.symptr);
  functname = semsymptr->UU.symptr->name;
  if (checklastlevel(functname, tfunction, &bucketfoundin)) {
    errorrec = newerrorptr(fndoubdef);
    errorrec->UU.errorstr = functname;
    errorrec->linenumber = getdefline(semsymptr->UU.symptr, 1);
    semerror(errorrec);
  }
  functtypeptr = semsymptr->UU.symptr->typeptr;
  if (checklastlevel(functname, tforward, &bucketfoundin))
      /*There is a forward*/
      {  /*function with this name*/
    forwardtypeptr = bucketfoundin->typeptr;
    smashedtypeptr = addtotypetable(functtypeptr);
    if (smashedtypeptr != forwardtypeptr) {
      errorrec = newerrorptr(forwardtype);
      errorrec->UU.errorstr = functname;   /*Forward funct type not the */
      errorrec->linenumber = getdefline(semsymptr->UU.symptr, 1);
      semerror(errorrec);   /*same as this one, change it.*/
      semsymptr->UU.symptr->typeptr = smashedtypeptr;
      fnode = semsymptr->UU.symptr->graphinfo->node_;
      fnode->UU.U1.ndtype = smashedtypeptr;
    }  /*then*/
    else {  /*else fix the forward to a normal function*/
      linenum = getdefline(semsymptr->UU.symptr, 1);
      colnum = getdefcolumn(semsymptr->UU.symptr, 2);
      setdefloc(bucketfoundin, linenum, colnum);
      bucketfoundin->identtag = tfunction;
      bucketfoundin->graphinfo = semsymptr->UU.symptr->graphinfo;
      fnode = semsymptr->UU.symptr->graphinfo->node_;
      fnode->UU.U1.ndtype = smashedtypeptr;
      semsymptr->UU.symptr = bucketfoundin;
      freefuncttype(functtypeptr);
    }  /*else*/
  }  /*then*/
  else {
    /*not declared as forward, check for another
                                   function with this name.*/
    findname(functname, tfunction, &levelfoundat, &bucketfoundin);
    if (bucketfoundin != NULL) {
      if (bucketfoundin->identtag == tfunction) {  /* versus TGlobal*/
        errorrec = newerrorptr(innerfndoubdef);
        errorrec->UU.errorstr = functname;
        errorrec->linenumber = getdefline(semsymptr->UU.symptr, 1);
        semerror(errorrec);
      }
    }
    smashedtypeptr = addtotypetable(functtypeptr);
    if (smashedtypeptr != functtypeptr) {
      semsymptr->UU.symptr->typeptr = smashedtypeptr;
      fnode = semsymptr->UU.symptr->graphinfo->node_;
      fnode->UU.U1.ndtype = smashedtypeptr;
      freefuncttype(functtypeptr);
    }
    addtotable(semsymptr->UU.symptr, currentlevel->lastlevel);
  }  /*else*/
  freesemantic(&semtypelist);
  pushsemantic(semsymptr);
}


static void endforwardglobheader()
{
  /*action 7 EndForwardGlobHeader*/
  /*stackpops - tgtypelist
                         tgsymptr
                  pushes - nothing*/
  /*description
          Finish building the function type by building the results list.
          Check for other functions in the current level with this name.
          Declare an error if one exists.  Hash the function name and
          smash its typeptr into the typetable.*/
  semanticrec *semtypelist, *semsymptr;
  stryng functname;
  errorrecord *errorrec;
  stentry *typeptr, *smashedtypeptr;
  node *fnode;

  if (semtrace)
    printf("begin EndForwardGlobHeader \n");
  semtypelist = popsemantic();
  semsymptr = popsemantic();
  doresultlist(semtypelist->UU.typelist, semsymptr->UU.symptr);
  functname = semsymptr->UU.symptr->name;
  if (incurrentlevel(functname, tfunction) != NULL) {
    errorrec = newerrorptr(fndoubdef);
    errorrec->UU.errorstr = functname;
    errorrec->linenumber = getdefline(semsymptr->UU.symptr, 1);
    semerror(errorrec);
  }
  addtotable(semsymptr->UU.symptr, currentlevel);
  typeptr = semsymptr->UU.symptr->typeptr;
  smashedtypeptr = addtotypetable(typeptr);
  if (smashedtypeptr != typeptr) {
    semsymptr->UU.symptr->typeptr = smashedtypeptr;
    if (semsymptr->UU.symptr->identtag == tglobal) {
      fnode = semsymptr->UU.symptr->graphinfo->node_;
      fnode->UU.U1.ndtype = smashedtypeptr;
    }  /*then*/
    freefuncttype(typeptr);
  }  /*then*/
  freesemantic(&semsymptr);
  freesemantic(&semtypelist);
}


static void endfunctionlist()
{
  /*action 30 EndFunctionList*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Search the current level in the symbol table and look for forward
          functions that have not had a local function defined for them.  They
          will still have IdentTag = TForward.  For each one found declare
          an error.*/
  int hashvalue;
  symtblbucket *bucket;
  errorrecord *errorrec;

  if (semtrace)
    printf("begin EndFunctionList\n");
  for (hashvalue = 0; hashvalue <= maxhashtable; hashvalue++) {
    bucket = currentlevel->hashtable[hashvalue];
    while (bucket != NULL) {
      if (bucket->identtag == tforward) {
        errorrec = newerrorptr(forwardnotresolved);
        errorrec->UU.errorstr = bucket->name;
        errorrec->linenumber = getdefline(bucket, 1);
        semerror(errorrec);
      }  /*then*/
      bucket = bucket->nextbucket;
    }  /*while*/
  }  /*for*/
}


static void endfunction()
{
  /*action 31 EndFunction*/
  /*stackpops - tgexplist
                         tgsymptr
                  pushes - nothing*/
  /*description
          Check that the expression list matches the returns type for
          the function.  This means checking the types and the arity
          of the expression.  Connect the outputs of the expression to
          N0 of the function, they go on the functions I-List.  Call
          EndLevel, which will do a xref if it was requested and free
          up the lex level structures.*/
  semanticrec *semexplist, *semsymptr;
  explistnode *exp;
  stentry *typeptr;
  errorrecord *errorrec;
  int rescnt;
  inforecord *functgraphinfo;

  if (semtrace)
    printf("Begin EndFunction\n");
  semexplist = popsemantic();
  semsymptr = popsemantic();
  functgraphinfo = semsymptr->UU.symptr->graphinfo;
  rescnt = 1;
  exp = semexplist->UU.explist;
  typeptr = semsymptr->UU.symptr->typeptr->UU.U3.stres;
  do {
    if (exp->graphinfo->typeptr != typeptr->UU.U2.stelemtype) {
      errorrec = newerrorptr(typefunctres);
      errorrec->UU.U19.functname = semsymptr->UU.symptr->name;
      errorrec->UU.U19.resnum = rescnt;
      if (getdefline(semsymptr->UU.symptr, 2) < 1)
        errorrec->linenumber = getdefline(semsymptr->UU.symptr, 1);
      else
        errorrec->linenumber = getdefline(semsymptr->UU.symptr, 2);
      semerror(errorrec);
    }
    functgraphinfo->port_ = rescnt;
    addedge(exp->graphinfo, functgraphinfo);
    exp = exp->next;
    typeptr = typeptr->UU.U2.stnext;
    rescnt++;
  } while (exp != NULL && typeptr != NULL);
  if (exp != NULL || typeptr != NULL) {
    errorrec = newerrorptr(numfunctres);
    errorrec->UU.U19.functname = semsymptr->UU.symptr->name;
    if (getdefline(semsymptr->UU.symptr, 2) < 1)
      errorrec->linenumber = getdefline(semsymptr->UU.symptr, 1);
    else
      errorrec->linenumber = getdefline(semsymptr->UU.symptr, 2);
    if (exp == NULL)   /*too many result expressions */
      errorrec->UU.U19.resnum = -1;   /*not enough result expressions*/
    else
      errorrec->UU.U19.resnum = 1;
    semerror(errorrec);
  }  /*then*/
  endlevel();
}


static void dofunctcall()
{
  /*action 108 DoFunctionCall*/
  /*stackpops - tgexplist
                         tgnamelist
                  pushes - tgexplist*/
  /*description
          Get a call node.  Find the name in the symbol table as a function
          or global.  If it isn't there, declare an error.  Connect the <NAME>
          on the list to the 1st input port of the call node.  Step thru
          the expression list and the arg list for the function (in the
          type table).  Check that the type of the exp matches the type of
          the arg.  Connect the exp to the next input port of the call node.
          Make sure there are the correct number of args.  If not, declare an
          error.  Build an expression list for the results of the expression
          and push it on the stack.*/
  semanticrec *semexplist, *semnamelist;
  stryng functname;
  treestackobj *level;
  int argcnt, rescnt;
  errorrecord *errorrec;
  inforecord *callgraphinfo, *paramgraphinfo;
  explistnode *exp;
  stentry *typeptr;
  symtblbucket *symptr;
  node *nd;

  semexplist = popsemantic();
  semnamelist = popsemantic();
  functname = semnamelist->UU.namelist->name;
  findname(functname, tfunction, &level, &symptr);
  if (symptr == NULL) {
    errorrec = newerrorptr(undeffunct);
    errorrec->UU.errorstr = functname;
    errorrec->linenumber = semnamelist->UU.namelist->linenum;
    semerror(errorrec);
    /*the function that is to be called is undefined.  Make up an explist
      that holds a literal "error" of type wild.*/
    semexplist->UU.explist = newexplistptr();
    string10(&semexplist->UU.explist->graphinfo->litvalue, "error     ");
    semexplist->UU.explist->graphinfo->typeptr = getbasictype(ifbwild);
    symptr = createbucket(tfunction);
    setname(symptr, functname);
    setdefloc(symptr, semnamelist->UU.namelist->linenum,
              semnamelist->UU.namelist->column);
    typeptr = getbasictype(ifbwild);
    symptr->typeptr = typeptr;
    symptr->graphinfo = semexplist->UU.explist->graphinfo;
    addtotable(symptr, currentlevel);
    pushsemantic(semexplist);
    freesemantic(&semnamelist);
    return;
  }
  if (symptr->identtag == tpredefined) {
    dopredefined(symptr, semexplist, semnamelist->UU.namelist->linenum);
    return;
  }
  if (symptr->graphinfo->node_ == NULL && symptr->identtag != tforward)
      /* this funct is undef, but was */
      {  /* called before. */
    addref(symptr, semnamelist->UU.namelist->linenum,
           semnamelist->UU.namelist->column);
    semexplist->UU.explist = newexplistptr();
    semexplist->UU.explist->graphinfo = symptr->graphinfo;
    pushsemantic(semexplist);
    freesemantic(&semnamelist);
    return;
  }  /*then*/
  addref(symptr, semnamelist->UU.namelist->linenum,
         semnamelist->UU.namelist->column);
  nd = newnodeptr(ndatomic, currentlevel);
  nd->ndcode = ifncall;
  nd->ndsrcline = semnamelist->UU.namelist->linenum;
  linkparent(nd, currentlevel);
  paramgraphinfo = newinfoptr();   /*make a literal for funct name*/
  paramgraphinfo->litvalue = symptr->graphinfo->litvalue;
  paramgraphinfo->typeptr = symptr->typeptr;
  callgraphinfo = newinfoptr();
  callgraphinfo->node_ = nd;
  callgraphinfo->port_ = 1;
  addedge(paramgraphinfo, callgraphinfo);
  exp = semexplist->UU.explist;
  typeptr = symptr->typeptr->UU.U3.starg;
  argcnt = 1;
  while (exp != NULL && typeptr != NULL) {
    argcnt++;
    if (exp->graphinfo->typeptr != typeptr->UU.U2.stelemtype) {
      errorrec = newerrorptr(typefunctarg);
      errorrec->UU.U29.functionname = functname;
      errorrec->UU.U29.argnum = argcnt - 1;
      errorrec->linenumber = semnamelist->UU.namelist->linenum;
      semerror(errorrec);
    }  /*then*/
    callgraphinfo->port_ = argcnt;
    addedge(exp->graphinfo, callgraphinfo);
    exp = exp->next;
    typeptr = typeptr->UU.U2.stnext;
  }  /*while*/
  if (exp != NULL || typeptr != NULL) {
    errorrec = newerrorptr(numfunctarg);
    errorrec->UU.U29.functionname = functname;
    errorrec->linenumber = semnamelist->UU.namelist->linenum;
    if (exp == NULL)   /*Too many args*/
      errorrec->UU.U29.argnum = -1;   /*not enough args*/
    else
      errorrec->UU.U29.argnum = 1;
    semerror(errorrec);
  }  /*then*/
  /* push an expression list to represent the results  */
  rescnt = 1;
  typeptr = symptr->typeptr->UU.U3.stres;
  semexplist->UU.explist = newexplistptr();
  semexplist->UU.explist->graphinfo->node_ = nd;
  semexplist->UU.explist->graphinfo->port_ = rescnt;
  semexplist->UU.explist->graphinfo->typeptr = typeptr->UU.U2.stelemtype;
  exp = semexplist->UU.explist;
  typeptr = typeptr->UU.U2.stnext;
  while (typeptr != NULL) {
    rescnt++;
    exp->next = newexplistptr();
    exp->next->graphinfo->node_ = nd;
    exp->next->graphinfo->port_ = rescnt;
    exp->next->graphinfo->typeptr = typeptr->UU.U2.stelemtype;
    typeptr = typeptr->UU.U2.stnext;
    exp = exp->next;
  }  /*while*/
  pushsemantic(semexplist);
  freesemantic(&semnamelist);

  /*else*/
}


static void endprogram()
{
  /*action 141  EndProgram*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Check that all functions listed in the  statement have
          been declared at the outer most level.  This means that the
          DefineList should be empty.  Declare and error for each name
          on the list.*/
  errorrecord *errorrec;

  while (definelist != NULL) {
    errorrec = newerrorptr(deflistnotempty);
    errorrec->UU.errorstr = definelist->name;
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    definelist = definelist->next;
  }  /*while*/
}


static void startif(iftype)
lexleveltype iftype;
{
  /*action 79 StartIf*/
  /*stackpops - tgexplist
                  pushes - tgSubGraphNum*/
  /*description
          Check that the explist on the stack has arity one and type
          boolean.  Start an IF compound node and a subgraph for the
          then part.  Put an entry on the association list for the
          then part.  Connect the expression to port 1 of the compound
          node.  Save a 1 on the stack to signify that the IF has one
          subgraph so far.*/
  errorrecord *errorrec;
  semanticrec *semexplist;
  inforecord *graphinfo, *compnodegi;
  semanticrec *semsubgraphnum;
  /* node *subgraph; */

  if (semtrace)
    printf("begin StartIf\n");
  semexplist = popsemantic();
  compnodegi = newinfoptr();
  compnodegi->node_ = buildcompound_(iftype);
  compnodegi->port_ = 1;
  if (semexplist->UU.explist->next != NULL) {
    errorrec = newerrorptr(predarity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  if (semexplist->UU.explist->graphinfo->typeptr != getbasictype(ifbboolean)) {
    errorrec = newerrorptr(prednotbool);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
    graphinfo = newinfoptr();
    graphinfo->typeptr = getbasictype(ifbboolean);
    string10(&graphinfo->litvalue, "error     ");
    addedge(graphinfo, compnodegi);
  } else
    addedge(semexplist->UU.explist->graphinfo, compnodegi);
  addtoassolist(compnodegi->node_, 1);
  /* subgraph = */ (void)buildsubgraph(currentlevel->UU.U8.ifnode);
  freesemantic(&semexplist);
  newsemantic(&semsubgraphnum, tgsubgraphnum);
  semsubgraphnum->UU.subgraphnum = 1;
  pushsemantic(semsubgraphnum);
}


static void startifsubgraph()
{
  /*action 81 StartIfSubGraph*/
  /*stackpops - tgSubGraphNum
                  pushes - tgSubGraphNum*/
  /*description
          Call BuildSubGraph and add an entry to the association list
          for the next subgraph.  Search the symbol table for entries
          whose graphinfo node or oldfrom node is the old SG.  Change
          it to the new SG.  Increment the SubGraphNum and save it on
          the stack.*/
  semanticrec *semsubgraphnum;
  node *newsubgraph, *oldsubgraph;
  int hashindex;
  symtblbucket *chain;

  if (semtrace)
    printf("Begin StartIfSubgraph \n");
  semsubgraphnum = popsemantic();
  oldsubgraph = currentlevel->currentsubn0;
  newsubgraph = buildsubgraph(currentlevel->UU.U8.ifnode);
  hashindex = 0;
  while (hashindex <= maxhashtable) {
    chain = currentlevel->hashtable[hashindex];
    while (chain != NULL) {
      if (oldsubgraph == chain->graphinfo->node_)
        chain->graphinfo->node_ = newsubgraph;
      if (chain->identtag == tvariable) {
        if (oldsubgraph == chain->UU.U4.oldfrom->node_)
          chain->UU.U4.oldfrom->node_ = newsubgraph;
      }
      chain = chain->nextbucket;
    }  /*while*/
    hashindex++;
  }  /*while*/
  semsubgraphnum->UU.subgraphnum++;
  addtoassolist(currentlevel->UU.U8.ifnode, semsubgraphnum->UU.subgraphnum);
  pushsemantic(semsubgraphnum);
}


static void endiftagsubgraph(predflag)
boolean predflag;
{
  /*stackpops - tgexplist
                  pushes - nothing*/
  semanticrec *semexplist;
  typelistrec *typelist, *tp1, *tp2;
  int portnum;
  explistnode *explist;
  inforecord *subgraphgi;
  errorrecord *errorrec;

  semexplist = popsemantic();
  typelist = NULL;
  portnum = 1;
  explist = semexplist->UU.explist;
  subgraphgi = newinfoptr();
  subgraphgi->node_ = currentlevel->currentsubn0;
  while (explist != NULL) {
    subgraphgi->port_ = portnum;
    addedge(explist->graphinfo, subgraphgi);
    portnum++;
    linktype(explist->graphinfo->typeptr, &typelist);
    explist = explist->next;
  }  /*while*/
  portnum = 1;
  switch (currentlevel->lleveltag) {

  case nestedifcomp:
  case ifcomp:
    if (predflag) {
      if (semexplist->UU.explist->next != NULL) {
        errorrec = newerrorptr(predarity);
        errorrec->linenumber = linenumber;
        semerror(errorrec);
      }
      if (semexplist->UU.explist->graphinfo->typeptr !=
          getbasictype(ifbboolean)) {
        errorrec = newerrorptr(prednotbool);
        errorrec->linenumber = linenumber;
        semerror(errorrec);
      }
    }  /*then*/
    else if (currentlevel->UU.U8.iarmreturnstype == NULL)
      currentlevel->UU.U8.iarmreturnstype = typelist;
    else {
      tp1 = typelist;
      tp2 = currentlevel->UU.U8.iarmreturnstype;
      while (tp1 != NULL && tp2 != NULL) {
        if (tp1->typeptr != tp2->typeptr) {
          errorrec = newerrorptr(ifreturnstypes);
          errorrec->linenumber = linenumber;
          errorrec->UU.expnum = portnum;
          semerror(errorrec);
        }
        portnum++;
        tp1 = tp1->next;
        tp2 = tp2->next;
      }  /*while*/
      if (tp1 != tp2) {
        errorrec = newerrorptr(numifreturns);
        errorrec->linenumber = linenumber;
        if (tp1 == NULL)
          errorrec->UU.expnum = -1;
        else
          errorrec->UU.expnum = 1;
        semerror(errorrec);
      }  /*then*/
    }
    break;

  case tagcase:
    if (currentlevel->UU.U4.tarmreturnstype == NULL)
      currentlevel->UU.U4.tarmreturnstype = typelist;
    else {
      tp1 = typelist;
      tp2 = currentlevel->UU.U4.tarmreturnstype;
      while (tp1 != NULL && tp2 != NULL) {
        if (tp1->typeptr != tp2->typeptr) {
          errorrec = newerrorptr(tagreturnstypes);
          errorrec->linenumber = linenumber;
          errorrec->UU.expnum = portnum;
          semerror(errorrec);
        }
        portnum++;
        tp1 = tp1->next;
        tp2 = tp2->next;
      }  /*while*/
      if (tp1 != tp2) {
        errorrec = newerrorptr(numtagreturns);
        errorrec->linenumber = linenumber;
        if (tp1 == NULL)
          errorrec->UU.expnum = -1;
        else
          errorrec->UU.expnum = 1;
        semerror(errorrec);
      }  /*then*/
    }  /*else*/
    break;
  default:
     ;
  }/* case */

  /*else*/
}  /*EndIfTagSubGraph*/


static void endifsubgraph()
{
  /*action 82 EndIFSubGraph*/
  /*stackpops - nothing
                  pushes - nothing*/
  /*description
          Just call EndIfTagSubGraph with the predflag set to false.*/
  if (semtrace)
    printf("begin EndIFSubGraph \n");
  endiftagsubgraph(false);
}


/*procedure EndPredSubGraph;
(*action 82 EndPredSubGraph*)
(*stackpops - nothing
                pushes - nothing*)
(*description
        Just call EndIfTagSubGraph with the predflag set to true.*)
begin
  if SemTrace then
    writeln('begin EndPredSubGraph ');
  EndIfTagSubGraph(true);
end;
*/
static void endif()
{
  /*action 85  EndIf*/
  /*stackpops - tgSubGraphNum
                  pushes - tgexplist  (for IF outputs)*/
  /*description
          Pop the SubGraphNum off the stack and call EndCompound.*/
  semanticrec *semrec;

  if (semtrace)
    printf("begin EndIf \n");
  /* end all the nested ones */
  while (currentlevel->lleveltag != ifcomp) {
    semrec = popsemantic();
    freesemantic(&semrec);
    endcompound();
    endiftagsubgraph(false);
  }  /*while*/
  semrec = popsemantic();
  freesemantic(&semrec);
  endcompound();
}


static void findandpushname()
{
  /*action 137 FindAndPushName*/
  /*stack                pops - TGNameList
                         pushes - TGExpList   */
  /*description
          Look for the name is the symbol table. If it is not found then
          create a new symbol table entry of type wild.  Check that the
          name has been defined (Def loc 1 is not empty for a non loop var
          or def loc 2 is not empty for a loop var).  If the loop flag is
          LInit, set it to LConst.  This means the name was used with out
          old in the body before it was redefined, which forces it to be
          a loop constant.  Call pull name to bring the value into this
          scope and add a reference to its reference list.  Push the graph
          info of the symbol table entry.*/
  semanticrec *namel, *esem;
  treestackobj *level;
  symtblbucket *sym;
  stentry *wtype;
  errorrecord *errorrec;
  explistnode *expl;
  inforecord *outinfo;

  if (semtrace)
    printf("InFindAndPushName\n");
  namel = popsemantic();
  findname(namel->UU.namelist->name, tvariable, &level, &sym);
  if (sym == NULL) {
    errorrec = newerrorptr(vnameundef);
    errorrec->UU.errorstr = namel->UU.namelist->name;
    errorrec->linenumber = namel->UU.namelist->linenum;
    semerror(errorrec);
    sym = getsymtabentry(namel->UU.namelist->name, tvariable);
    wtype = getbasictype(ifbwild);
    sym->typeptr = wtype;
    sym->graphinfo->typeptr = wtype;
    setdefloc(sym, namel->UU.namelist->linenum, namel->UU.namelist->column);
    sym->graphinfo->name = namel->UU.namelist->name;
    string10(&sym->graphinfo->litvalue, "error     ");
    stripspaces(&sym->graphinfo->name);
    sym->graphinfo->typeptr = wtype;
    addtotable(sym, currentlevel);
    outinfo = newinfoptr();
    outinfo->node_ = sym->graphinfo->node_;
    outinfo->port_ = sym->graphinfo->port_;
    outinfo->typeptr = sym->graphinfo->typeptr;
    outinfo->name = sym->graphinfo->name;
    outinfo->litvalue = sym->graphinfo->litvalue;
    outinfo->onlist = sym->graphinfo->onlist;
  }  /* if */
  else {
    if (getdefline(sym, 1) == -1) {
      if (getloopflag(sym) == lvar)
        errorrec = newerrorptr(lvarnotdef);
      else
        errorrec = newerrorptr(decbutnotdef);
      errorrec->UU.errorstr = sym->name;
      errorrec->linenumber = namel->UU.namelist->linenum;
      semerror(errorrec);
      outinfo = newinfoptr();
      string10(&outinfo->litvalue, "error     ");
      outinfo->name = sym->name;
      outinfo->typeptr = sym->typeptr;
    }  /* if */
    else if (sym->identtag == tvariable) {
      if ((getloopflag(sym) == lvar) & (getdefline(sym, 2) == -1)) {
        errorrec = newerrorptr(lvarusebredef);
        errorrec->UU.errorstr = sym->name;
        errorrec->linenumber = namel->UU.namelist->linenum;
        semerror(errorrec);
        outinfo = newinfoptr();
        string10(&outinfo->litvalue, "error     ");
        outinfo->name = sym->name;
        outinfo->typeptr = sym->typeptr;
      }  /* else if */
      else {
        if (getloopflag(sym) == linit)
          *sym->UU.U4.loopflag = lconst;
        sym = pullname(sym, level, namel->UU.namelist->linenum);
        addref(sym, namel->UU.namelist->linenum, namel->UU.namelist->column);
        outinfo = newinfoptr();
        outinfo->node_ = sym->graphinfo->node_;
        outinfo->port_ = sym->graphinfo->port_;
        outinfo->typeptr = sym->graphinfo->typeptr;
        outinfo->name = sym->graphinfo->name;
        outinfo->litvalue = sym->graphinfo->litvalue;
        outinfo->onlist = sym->graphinfo->onlist;
      }  /* else */
    } else {
      sym = pullname(sym, level, namel->UU.namelist->linenum);
      addref(sym, namel->UU.namelist->linenum, namel->UU.namelist->column);
      outinfo = newinfoptr();
      outinfo->node_ = sym->graphinfo->node_;
      outinfo->port_ = sym->graphinfo->port_;
      outinfo->typeptr = sym->graphinfo->typeptr;
      outinfo->name = sym->graphinfo->name;
      outinfo->litvalue = sym->graphinfo->litvalue;
      outinfo->onlist = sym->graphinfo->onlist;
    }
  }  /* else */
  expl = newexplistptr();
  expl->graphinfo = outinfo;
  newsemantic(&esem, tgexplist);
  esem->UU.explist = expl;
  pushsemantic(esem);

  /* else if */
  /* else */
}


static void pushnilcons()
{
  /*action 129 PushNilCons*/
  /*stack        pops - nothing
                 pushes - TGExpList*/
  /*description
           Create an expression of type null and name inputtoken. Push
          this expression.*/
  explistnode *exp;
  semanticrec *sem;

  if (semtrace)
    printf("PushNilCons\n");
  exp = newexplistptr();
  exp->graphinfo->typeptr = getbasictype(ifbnull);
  exp->graphinfo->litvalue = inputtoken;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}  /* PushNilCons */


static void pushtruecons()
{
  /*action 130 PushTrueCons*/
  /*stack        pops - nothing
                 pushes - TGExpList*/
  /*description
           Create an expression of type boolean and name inputtoken.
           Push this expression.*/
  explistnode *exp;
  semanticrec *sem;

  if (semtrace)
    printf("PushTrueCons\n");
  exp = newexplistptr();
  exp->graphinfo->typeptr = getbasictype(ifbboolean);
  exp->graphinfo->litvalue = inputtoken;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}  /* PushTrueCons */


static void pushfalsecons()
{
  /*action 131 PushFalseCons*/
  /*stack        pops - nothing
                 pushes - TGExpList*/
  /*description
           Create an expression of type boolean and name inputtoken.
           Push this expression.*/
  explistnode *exp;
  semanticrec *sem;

  if (semtrace)
    printf("PushFalseCons\n");
  exp = newexplistptr();
  exp->graphinfo->typeptr = getbasictype(ifbboolean);
  exp->graphinfo->litvalue = inputtoken;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}  /* PushFalseCons */


static void pushintcons()
{
  /*action 132 PushIntCons*/
  /*stack        pops - nothing
                 pushes - TGExpList*/
  /*description
           Create an expression of type integer and name inputtoken.
           Push this expression.*/
  explistnode *exp;
  semanticrec *sem;

  if (semtrace)
    printf("PushIntCons\n");
  exp = newexplistptr();
  exp->graphinfo->typeptr = getbasictype(ifbinteger);
  exp->graphinfo->litvalue = inputtoken;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}  /* PushIntCons */


static void pushrealcons()
{
  /*action 133 PushRealCons*/
  /*stack        pops - nothing
                 pushes - TGExpList*/
  /*description
           Create an expression of type real and name inputtoken.
           Push this expression.*/
  explistnode *exp;
  semanticrec *sem;

  if (semtrace)
    printf("PushRealCons\n");
  exp = newexplistptr();
  exp->graphinfo->typeptr = getbasictype(ifbreal);
  exp->graphinfo->litvalue = inputtoken;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}  /* PushRealCons */


static void pushdoubcons()
{
  /*action 142 PushDoubCons*/
  /*stack        pops - nothing
                 pushes - TGExpList*/
  /*description
           Create an expression of type double_real and name inputtoken.
           Push this expression.*/
  explistnode *exp;
  semanticrec *sem;

  if (semtrace)
    printf("PushDoubCons\n");
  exp = newexplistptr();
  exp->graphinfo->typeptr = getbasictype(ifbdouble);
  exp->graphinfo->litvalue = inputtoken;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}  /* PushDoubCons */


static void pushcharcons()
{
  /*action 134 PushCharCons*/
  /*stack        pops - nothing
                 pushes - TGExpList*/
  /*description
          Create an expression of type character and name inputtoken.
          Push this expression.*/
  explistnode *exp;
  semanticrec *sem;

  if (semtrace)
    printf("PushCharCons\n");
  exp = newexplistptr();
  exp->graphinfo->typeptr = getbasictype(ifbcharacter);
  if (stringchar(&inputtoken, 2) == '"')
    insertchar(&inputtoken, '\\', 2);
  exp->graphinfo->litvalue = inputtoken;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}  /* PushCharCons */


static void pushstringcons()
{
  /*action 135 PushStringCons*/
  /*stack        pops - nothing
                 pushes - TGExpList*/
  /*description
          Create an expression of type array of character and name
          inputtoken. Push this expression.*/
  explistnode *exp;
  semanticrec *sem;
  stentry *parray;

  if (semtrace)
    printf("PushCharCons\n");
  exp = newexplistptr();
  newttptr(&parray, iftarray);
  parray->UU.stbasetype = getbasictype(ifbcharacter);
  exp->graphinfo->typeptr = addtotypetable(parray);
  exp->graphinfo->litvalue = inputtoken;
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}  /* PushStringCons */


static void pusherrorcons()
{
  /*action 136 PushErrorCons*/
  /*stack        pops - TGTTPtr
                 pushes - TGExpList*/
  /*description
          Create an expression with type of type table pointer and name
          inputtoken. Push this expression.*/
  explistnode *exp;
  semanticrec *sem, *semtype;

  if (semtrace)
    printf("PushErrorCons\n");
  semtype = popsemantic();
  exp = newexplistptr();
  exp->graphinfo->typeptr = addtotypetable(semtype->UU.ttptr);
  string10(&exp->graphinfo->litvalue, "error     ");
  newsemantic(&sem, tgexplist);
  sem->UU.explist = exp;
  pushsemantic(sem);
}  /* PushErrorCons */


static void buildchar()
{
  /*action 114 BuildChar*/
  /*stack        pops - TGExpList
                 pushes - TGExpList*/
  /*description
          Check that expression is of type integer.  Build a character
          type casting node. Connect the expression to port one of this
          node. Push the output graph info of the character node.*/
  semanticrec *sem;
  errorrecord *errorrec;
  boolean terr;
  node *charnode;
  inforecord *graph_, *info;

  if (semtrace)
    printf("BuildChar\n");
  sem = popsemantic();
  if (sem->UU.explist->next != NULL) {
    errorrec = newerrorptr(chararity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  terr = false;
  graph_ = sem->UU.explist->graphinfo;
  if (graph_->typeptr == NULL)
    graph_->typeptr = getbasictype(ifbwild);
  if (graph_->typeptr->stsort != iftbasic)
    terr = true;
  else {
    if (graph_->typeptr->UU.stbasic != ifbinteger)
      terr = true;
  }
  if (terr) {
    errorrec = newerrorptr(charitype);
    errorrec->UU.typeptr = graph_->typeptr;
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  charnode = newnodeptr(ndatomic, currentlevel);
  charnode->ndcode = ifnchar;
  charnode->ndsrcline = linenumber;
  linkparent(charnode, currentlevel);
  info = newinfoptr();
  info->node_ = charnode;
  info->port_ = 1;
  addedge(graph_, info);
  info->typeptr = getbasictype(ifbcharacter);
  sem->UU.explist->graphinfo = info;
  sem->UU.explist->next = NULL;
  pushsemantic(sem);
}  /* BuildChar */


static void builddouble()
{
  /*action 116 BuildDouble*/
  /*stack        pops - TGExpList
                 pushes - TGExpList*/
  /*description
          Check that expression is of type integer or real.  Build a
          double type casting node. Connect the expression to port one of
          this node. Push the output graph info of the double node.*/
  semanticrec *sem;
  errorrecord *errorrec;
  boolean terr;
  node *doublenode;
  inforecord *graph_, *info;

  if (semtrace)
    printf("BuildDouble\n");
  sem = popsemantic();
  if (sem->UU.explist->next != NULL) {
    errorrec = newerrorptr(doublearity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  terr = false;
  graph_ = sem->UU.explist->graphinfo;
  if (graph_->typeptr == NULL)
    graph_->typeptr = getbasictype(ifbwild);
  if (graph_->typeptr->stsort != iftbasic)
    terr = true;
  else {
    if (graph_->typeptr->UU.stbasic != ifbinteger &&
        graph_->typeptr->UU.stbasic != ifbreal)
      terr = true;
  }
  if (terr) {
    errorrec = newerrorptr(doubleitype);
    errorrec->UU.typeptr = graph_->typeptr;
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  doublenode = newnodeptr(ndatomic, currentlevel);
  doublenode->ndcode = ifndouble;
  doublenode->ndsrcline = linenumber;
  linkparent(doublenode, currentlevel);
  info = newinfoptr();
  info->node_ = doublenode;
  info->port_ = 1;
  addedge(graph_, info);
  info->typeptr = getbasictype(ifbdouble);
  sem->UU.explist->graphinfo = info;
  sem->UU.explist->next = NULL;
  pushsemantic(sem);
}  /* BuildDouble */


static void buildint()
{
  /*action 118 BuildInt*/
  /*stack        pops - TGExpList
                 pushes - TGExpList*/
  /*description
          Check that expression is of type double, character or real.
          Build a integer type casting node. Connect the expression to
          port one of this node. Push the output graph info of the
          integer node.*/
  semanticrec *sem;
  errorrecord *errorrec;
  boolean terr;
  node *intnode;
  inforecord *graph_, *info;

  if (semtrace)
    printf("BuildInt\n");
  sem = popsemantic();
  if (sem->UU.explist->next != NULL) {
    errorrec = newerrorptr(intarity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  terr = false;
  graph_ = sem->UU.explist->graphinfo;
  if (graph_->typeptr == NULL)
    graph_->typeptr = getbasictype(ifbwild);
  if (graph_->typeptr->stsort != iftbasic)
    terr = true;
  else {
    if (graph_->typeptr->UU.stbasic != ifbreal &&
        graph_->typeptr->UU.stbasic != ifbdouble &&
        graph_->typeptr->UU.stbasic != ifbcharacter)
      terr = true;
  }
  if (terr) {
    errorrec = newerrorptr(intitype);
    errorrec->UU.typeptr = graph_->typeptr;
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  intnode = newnodeptr(ndatomic, currentlevel);
  intnode->ndcode = ifnint;
  intnode->ndsrcline = linenumber;
  linkparent(intnode, currentlevel);
  info = newinfoptr();
  info->node_ = intnode;
  info->port_ = 1;
  addedge(graph_, info);
  info->typeptr = getbasictype(ifbinteger);
  sem->UU.explist->graphinfo = info;
  sem->UU.explist->next = NULL;
  pushsemantic(sem);
}  /* BuildInt */


static void buildreal()
{
  /*action 120 BuildReal*/
  /*stack        pops - TGExpList
                 pushes - TGExpList*/
  /*description
          Check that expression is of type integer or real.
          Build a real type casting node. Connect the expression to
          port one of this node. Push the output graph info of the
          real node.*/
  semanticrec *sem;
  errorrecord *errorrec;
  boolean terr;
  node *realnode;
  inforecord *graph_, *info;

  if (semtrace)
    printf("BuildReal\n");
  sem = popsemantic();
  if (sem->UU.explist->next != NULL) {
    errorrec = newerrorptr(realarity);
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  terr = false;
  graph_ = sem->UU.explist->graphinfo;
  if (graph_->typeptr == NULL)
    graph_->typeptr = getbasictype(ifbwild);
  if (graph_->typeptr->stsort != iftbasic)
    terr = true;
  else {
    if (graph_->typeptr->UU.stbasic != ifbinteger &&
        graph_->typeptr->UU.stbasic != ifbdouble)
      terr = true;
  }
  if (terr) {
    errorrec = newerrorptr(realitype);
    errorrec->UU.typeptr = graph_->typeptr;
    errorrec->linenumber = linenumber;
    semerror(errorrec);
  }
  realnode = newnodeptr(ndatomic, currentlevel);
  realnode->ndcode = ifnsingle;
  realnode->ndsrcline = linenumber;
  linkparent(realnode, currentlevel);
  info = newinfoptr();
  info->node_ = realnode;
  info->port_ = 1;
  addedge(graph_, info);
  info->typeptr = getbasictype(ifbreal);
  sem->UU.explist->graphinfo = info;
  sem->UU.explist->next = NULL;
  pushsemantic(sem);
}  /* BuildReal */


static void createsub(tagcasenode, tagvalue)
node *tagcasenode;
tagflag tagvalue;
{
  node *subn0;
  inforecord *lit, *nod;

  subn0 = buildsubgraph(tagcasenode);
  lit = newinfoptr();
  lit->typeptr = getbasictype(ifbboolean);
  if (tagvalue == truetag)
    string10(&lit->litvalue, "true      ");
  else if (tagvalue == falsetag)
    string10(&lit->litvalue, "false     ");
  else
    string10(&lit->litvalue, "error     ");
  nod = newinfoptr();
  nod->node_ = subn0;
  nod->port_ = 1;
  addedge(lit, nod);
}  /* CreateSub */

static void changeto2(assolist)
assoclist *assolist;
{
  while (assolist != NULL) {
    assolist->graphnum = 2;
    assolist = assolist->next;
  }  /* while */
}  /* ChangeTo2 */


static void createisunion(line, col)
int line, col;
{
  /*action 121 CreateUsUnion*/
  /*stack        pops - TGExpList
                        TGNameList
                 pushes - TGExpList*/
  /*description
          Create a tagcae node the three subgraphs false, true and error.
          Look for the name as a tag of the union. While searching the
          tag list make entries into the association list such that every
          tag whose name does not match the name asseciates with the false
          subgraph and the tag with the name that matches with the true
          subgraph.  If the name is not found in the tag list then change
          the association list to associate to the error subgraph in all
          cases. Push the union expression back onto the stack.*/
  semanticrec *expl, *namel;
  explistnode *exp;
  namelistrec *name;
  errorrecord *errorrec;
  node *tagcasenode;
  boolean found, badtype;
  stentry *tags;
  inforecord *info;
  stryng nname, tname;
  treestackobj *level;

  if (semtrace)
    printf("CreateIsUnion\n");
  expl = popsemantic();
  namel = popsemantic();
  exp = expl->UU.explist;
  name = namel->UU.namelist;
  if (exp->next != NULL) {
    exp->next = NULL;
    errorrec = newerrorptr(arityonisu);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if */
  badtype = false;
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort != iftunion) {
    badtype = true;
    errorrec = newerrorptr(isutype);
    errorrec->UU.typeptr = exp->graphinfo->typeptr;
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if */
  tagcasenode = buildcompound_(tagcase);
  createsub(tagcasenode, falsetag);
  createsub(tagcasenode, truetag);
  createsub(tagcasenode, errortag);
  if (!badtype) {
    tags = exp->graphinfo->typeptr->UU.stbasetype;
    found = false;
    while (tags != NULL) {
      tname = tags->stliteral;
      nname = name->name;
      stringlowercase(&tname);
      stringlowercase(&nname);
      if (equalstrings(&nname, &tname)) {
        addtoassolist(tagcasenode, 1);
        found = true;
      }  /* if */
      else
        addtoassolist(tagcasenode, 0);
      tags = tags->UU.U2.stnext;
    }  /* while */
    if (!found)
      changeto2(tagcasenode->UU.U2.ndassoc);
  }  /* if */
  else
    addtoassolist(tagcasenode, 2);
  info = newinfoptr();
  info->node_ = tagcasenode;
  info->port_ = 1;
  addedge(exp->graphinfo, info);
  info->typeptr = getbasictype(ifbboolean);
  expl->UU.explist->graphinfo = info;
  level = currentlevel;
  currentlevel = currentlevel->lastlevel;
  currentlevel->nextlevel = NULL;
  freetreestack(level);
  pushsemantic(expl);
}  /* CreateIsUnion */


static void checkold(inputtoken, line, column)
stryng inputtoken;
int line, column;
{
  /*action 122 CheckOld*/
  /*stack        pops - nothing
                 pushes - TGExpList*/
  /*description
          Find inputtoken in the symbol table. If it doesn't exist then
          declare and error and put it in the symbol table with type wild.
          If it is a LInit, then make it an LVar.  Copy the graphinfo into
          the OldFrom info.  I fit is not an LInit or Lvar then error,
          can not use old with this name.  Push the graph info in the
          symbol table onto the stack.*/
  semanticrec *esem;
  treestackobj *level;
  symtblbucket *sym;
  stentry *wtype;
  errorrecord *errorrec;
  explistnode *expl;
  loopvarflags vartype;

  if (semtrace)
    printf("CheckOld\n");
  findname(inputtoken, tvariable, &level, &sym);
  expl = newexplistptr();
  if (sym == NULL) {
    errorrec = newerrorptr(vnameundef);
    errorrec->UU.errorstr = inputtoken;
    errorrec->linenumber = line;
    errorrec->column = column;
    semerror(errorrec);
    sym = getsymtabentry(inputtoken, tvariable);
    wtype = getbasictype(ifbwild);
    sym->typeptr = wtype;
    sym->graphinfo->typeptr = wtype;
    setdefloc(sym, line, column);
    addtotable(sym, currentlevel);
    expl->graphinfo = sym->graphinfo;
  }  /* if */
  else {
    addref(sym, line, column);
    if (getdefline(sym, 1) == -1) {
      if (getloopflag(sym) == lvar)
        errorrec = newerrorptr(lvarnotdef);
      else
        errorrec = newerrorptr(decbutnotdef);
      errorrec->UU.errorstr = sym->name;
      errorrec->linenumber = line;
      semerror(errorrec);
      expl->graphinfo = newinfoptr();
      string10(&expl->graphinfo->litvalue, "error     ");
      expl->graphinfo->name = sym->name;
      expl->graphinfo->typeptr = sym->typeptr;
    }  /* if undefined */
    else {
      vartype = getloopflag(sym);
      if (vartype == linit) {
        *sym->UU.U4.loopflag = lvar;
        sym->UU.U4.oldfrom = sym->graphinfo;
        insertchar(&sym->UU.U4.oldfrom->name, '-', 1);
        insertchar(&sym->UU.U4.oldfrom->name, 'd', 1);
        insertchar(&sym->UU.U4.oldfrom->name, 'l', 1);
        insertchar(&sym->UU.U4.oldfrom->name, 'o', 1);
        sym->graphinfo = newinfoptr();
        sym->graphinfo->node_ = NULL;
        sym->graphinfo->typeptr = NULL;
        sym->graphinfo->onlist = NULL;
        sym = pullname(sym, level, line);
        expl->graphinfo = sym->UU.U4.oldfrom;
      }  /* else if */
      else if (vartype == lvar) {
        sym = pullname(sym, level, line);
        expl->graphinfo = sym->UU.U4.oldfrom;
      } else if (vartype == lconst) {
        errorrec = newerrorptr(loopcvmix);
        errorrec->UU.errorstr = sym->name;
        errorrec->linenumber = line;
        errorrec->column = column;
        sym = pullname(sym, level, line);
        expl->graphinfo = sym->graphinfo;
      } else {
        errorrec = newerrorptr(vnamenotloopvar);
        errorrec->UU.errorstr = inputtoken;
        errorrec->linenumber = line;
        errorrec->column = column;
        semerror(errorrec);
        sym = pullname(sym, level, line);
        expl->graphinfo = sym->graphinfo;
      }
    }  /* else */
  }  /* else */
  newsemantic(&esem, tgexplist);
  esem->UU.explist = expl;
  pushsemantic(esem);

  /* else if */
  /* else if */
  /* else */
}  /* CheckOld */


static void pushuplus(line, column)
int line, column;
{
  /*action 123 PushUPlus*/
  /*stack        pops - nothing
                 pushes - TGPrecLevel*/
  /*description
          Push a unary plus operation onto the stack.*/
  semanticrec *sem;

  if (semtrace)
    printf("PushUPlus\n");
  newsemantic(&sem, tgpreclevel);
  sem->UU.U5.preclevel = boostfac + 8;
  sem->UU.U5.operation = uplus;
  sem->UU.U5.line = line;
  sem->UU.U5.column = column;
  pushsemantic(sem);
}  /* PushUPLus */


static void pushuminus(line, column)
int line, column;
{
  /*action 124 PushUMinus*/
  /*stack        pops - nothing
                 pushes - TGPrecLevel */
  /*description
           Push a unary minus operation onto the stack.*/
  semanticrec *sem;

  if (semtrace)
    printf("PushUMinus\n");
  newsemantic(&sem, tgpreclevel);
  sem->UU.U5.preclevel = boostfac + 8;
  sem->UU.U5.operation = uminus;
  sem->UU.U5.line = line;
  sem->UU.U5.column = column;
  pushsemantic(sem);
}  /* PushUMinus */


static void pushunot(line, column)
int line, column;
{
  /*action 125 PushUNot*/
  /*stack        pops - nothing
                 pushes - TGPrecLevel*/
  /*description
          Push a unary not operation onto the stack.*/
  semanticrec *sem;

  if (semtrace)
    printf("PushUNot\n");
  newsemantic(&sem, tgpreclevel);
  sem->UU.U5.preclevel = boostfac + 3;
  sem->UU.U5.operation = unot;
  sem->UU.U5.line = line;
  sem->UU.U5.column = column;
  pushsemantic(sem);
}  /* PushUNot */


static void createiserror(line, column)
int line, column;
{
  /*action 127 CreateIsError*/
  /*stack        pops - TGExpList
                 pushes - TGExpList*/
  /* description
          Create an iserror node. Link the literal 'error' to it's first
          input port and expression to it's second.  Push the output graph
          info of the iserror node onto the stack.*/
  semanticrec *expl;
  node *iserrornode;
  inforecord *lit, *nod;
  errorrecord *errorrec;

  if (semtrace)
    printf("CreateIsError\n");
  expl = popsemantic();
  if (expl->UU.explist->next != NULL) {
    errorrec = newerrorptr(arityonerror);
    errorrec->linenumber = line;
    errorrec->column = column;
    semerror(errorrec);
  }
  iserrornode = newnodeptr(ndatomic, currentlevel);
  iserrornode->ndcode = ifniserror;
  iserrornode->ndsrcline = line;
  linkparent(iserrornode, currentlevel);
  lit = newinfoptr();
  lit->typeptr = expl->UU.explist->graphinfo->typeptr;
  string10(&lit->litvalue, "error     ");
  nod = newinfoptr();
  nod->node_ = iserrornode;
  nod->port_ = 1;
  addedge(lit, nod);
  nod->port_ = 2;
  addedge(expl->UU.explist->graphinfo, nod);
  nod->port_ = 1;
  nod->typeptr = getbasictype(ifbboolean);
  expl->UU.explist->graphinfo = nod;
  expl->UU.explist->next = NULL;
  pushsemantic(expl);
}  /* CreateIsError */


static void fixforfunct()
{
  /*action 42 FixForFunct*/
  /*stack        pops - TGNameList
                 pushes - TGSymPtr
                          TGNameList*/
  /*description
           Place a null namelist under the current name list.  this
          leaves the semantic stack in the correct form for a function
          call inside a tagcase header.*/
  semanticrec *namelist, *symptr;

  if (semtrace)
    printf(" In FixForFunct\n");
  namelist = popsemantic();
  newsemantic(&symptr, tgsymptr);
  pushsemantic(symptr);
  pushsemantic(namelist);
}  /* FixForFunct */


stentry *errorstruct()
{
  semanticrec *nsem, *tsem, *errstr;

  pushunion(noaddtottable);
  newsemantic(&nsem, tgnamelist);
  newnamelist(&nsem->UU.namelist);
  string10(&nsem->UU.namelist->name, "error     ");
  stripspaces(&nsem->UU.namelist->name);
  pushsemantic(nsem);
  newsemantic(&tsem, tgttptr);
  tsem->UU.ttptr = getbasictype(ifbwild);
  pushsemantic(tsem);
  buildtag(noaddtottable);
  errstr = popsemantic();
  return (addtotypetable(errstr->UU.ttptr));
}  /* ErrorStruct */


static void fixfortag(line, col)
int line, col;
{
  /*action 115 FixForTag*/
  /*stack        pops - TGNameList
                 pushes - TGExpList*/
  /* description
           Looks for name in symbol table and pushes it's graph info onto
           the stack.  If the name is not in the symbol table then an
           error union is built.*/
  semanticrec *namel, *expl;
  namelistrec *name;
  treestackobj *level;
  symtblbucket *sym;
  errorrecord *errorrec;

  namel = popsemantic();
  name = namel->UU.namelist;
  newsemantic(&expl, tgexplist);
  expl->UU.explist = newexplistptr();
  findname(name->name, tvariable, &level, &sym);
  if (sym == NULL) {
    errorrec = newerrorptr(undefntag);
    errorrec->UU.errorstr = name->name;
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
    string10(&expl->UU.explist->graphinfo->litvalue, "error     ");
    string10(&expl->UU.explist->graphinfo->name, "error     ");
    stripspaces(&expl->UU.explist->graphinfo->name);
    expl->UU.explist->graphinfo->typeptr = errorstruct();
  }  /* if */
  else {
    sym = pullname(sym, level, line);
    expl->UU.explist->graphinfo = sym->graphinfo;
  }  /* else */
  pushsemantic(expl);
}  /* FixForTag */


static void processtaghead(line, col)
int line, col;
{
  /*action 43 ProcessTaghead*/
  /*stack        pops - TGExpList
                        TGNameList
                 pushes - TGSubGraphNum
                          TGTCStackList
                          TGSymPtr*/
  /*description
          Check that expression is of arity one and type union.
          Build a tagcase node, connect the expression to port one of the
          tagcase node. Create a new subgraph number semantic record.
          Push the ExpList and the subgraph number.*/
  semanticrec *expl, *subnum, *semnamelist, *semsymptr, *semtclist;
  explistnode *exp;
  errorrecord *errorrec;
  inforecord *toinfo;
  node *tagnode;
  symtblbucket *symptr;
  tcstacklistrec *tclist, *tclistend;
  stentry *typeptr;

  if (semtrace)
    printf(" In ProcessTagHead\n");
  expl = popsemantic();
  semnamelist = popsemantic();
  newsemantic(&semtclist, tgtcstacklist);
  semtclist->UU.tcstacklist = NULL;
  exp = expl->UU.explist;
  if (exp->next != NULL) {
    exp->next = NULL;
    errorrec = newerrorptr(arityontag);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if */
  if (exp->graphinfo->typeptr == NULL)
    exp->graphinfo->typeptr = getbasictype(ifbwild);
  if (exp->graphinfo->typeptr->stsort != iftunion) {
    errorrec = newerrorptr(typenutc);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
    exp->graphinfo = newinfoptr();
    string10(&exp->graphinfo->litvalue, "error     ");
    exp->graphinfo->typeptr = errorstruct();
  }  /* if */
  else {
    typeptr = exp->graphinfo->typeptr->UU.stbasetype;
    while (typeptr != NULL) {
      tclist = newtcstacklist();
      tclist->typeptr = typeptr;
      if (semtclist->UU.tcstacklist == NULL)
        semtclist->UU.tcstacklist = tclist;
      else
        tclistend->next = tclist;
      tclistend = tclist;
      typeptr = typeptr->UU.U2.stnext;
    }  /*while*/
  }  /*else*/
  tagnode = buildcompound_(tagcase);
  toinfo = newinfoptr();
  toinfo->node_ = tagnode;
  toinfo->port_ = 1;
  addedge(exp->graphinfo, toinfo);
  newsemantic(&subnum, tgsubgraphnum);
  subnum->UU.subgraphnum = 0;
  newsemantic(&semsymptr, tgsymptr);
  if (semnamelist->UU.namelist != NULL) {
    symptr = getsymtabentry(semnamelist->UU.namelist->name, tvariable);
    symptr->graphinfo->port_ = 1;   /*comes into all SGs on port 1*/
    setdefloc(symptr, semnamelist->UU.namelist->linenum, -1);
    addtotable(symptr, currentlevel);
    newsemantic(&semsymptr, tgsymptr);
    semsymptr->UU.symptr = symptr;
  }
  pushsemantic(semsymptr);
  pushsemantic(semtclist);
  pushsemantic(subnum);
  freesemantic(&expl);
}  /* ProcessTagHead */


static void createtagsubgraph()
{
  /*action 44 CreateTagSubgraph*/
  /*stack        pops - TGSubGrahpNum
                 pushes - TGSubGraphNum*/
  /*description
          Build a tagcase subgraph. Search the symbol table for values which
          have the old SG as their graphinfo node or oldfrom node.  Change
          these to be the new SG node.  Increment the subgraph number.
          Push the subgraph number.*/
  semanticrec *subgrn;
  node *newn0, *oldn0;
  int hashindex;
  symtblbucket *chain;

  if (semtrace)
    printf(" In CreateTagSubgraph\n");
  subgrn = popsemantic();
  subgrn->UU.subgraphnum++;
  oldn0 = currentlevel->currentsubn0;
  newn0 = buildsubgraph(currentlevel->UU.U4.tagcasenode);
  if (subgrn->UU.subgraphnum > 1) {
    hashindex = 0;
    while (hashindex <= maxhashtable) {
      chain = currentlevel->hashtable[hashindex];
      while (chain != NULL) {
        if (oldn0 == chain->graphinfo->node_)
          chain->graphinfo->node_ = newn0;
        if (chain->identtag == tvariable) {
          if (oldn0 == chain->UU.U4.oldfrom->node_)
            chain->UU.U4.oldfrom->node_ = newn0;
        }
        chain = chain->nextbucket;
      }
      hashindex++;
    }  /*while*/
  }  /*then*/
  pushsemantic(subgrn);
}  /* CreateTagSubgraph */


tcstacklistrec *findtag(name, struct_)
stryng name;
tcstacklistrec *struct_;
{
  boolean found;
  stryng name2;

  if (struct_ == NULL) {
    return struct_;
  }  /*then*/
  stringlowercase(&name);
  found = false;
  while (!found) {
    name2 = struct_->typeptr->stliteral;
    stringlowercase(&name2);
    if (equalstrings(&name, &name2))
      found = true;
    else
      struct_ = struct_->next;
    if (struct_ == NULL)
      found = true;
  }  /* while */
  return struct_;
}  /* FindTag */


static void checktagnames(line, col)
int line, col;
{
  /*action 45 CheckTagNames*/
  /*stack        pops - TGNameList
                        TGSubGraphNum
                        TGTCStackList
                        TGsymptr
                 pushes - TGSubGraphNum
                         TGTCStackList
                         TGsymptr */
  /*description
         Check that each name on the first name list is a tag of the
         union on the explist, is of the same type, and has not already
         been listed in this tagcase.  Mark each name with the subgraph
         number.  If the second namelist is not nil then add it to the
         symbol table with the same type as the names. Push the second
         name list, the union expression, and the subgraph number.*/
  semanticrec *namel, *subgrn, *semtclist, *tsymptr;
  stentry *ttype;
  namelistrec *names;
  symtblbucket *sym;
  errorrecord *errorrec;
  tcstacklistrec *tclist;
  tcstacklistrec *save_tclist;

  if (semtrace)
    printf(" In CheckTagNames\n");
  namel = popsemantic();
  subgrn = popsemantic();
  semtclist = popsemantic();
  tsymptr = popsemantic();
  names = namel->UU.namelist;
  tclist = semtclist->UU.tcstacklist;
  ttype = NULL;
  save_tclist = tclist; /* BUGFIX for lists of tags 6/9/03 */
  while (names != NULL) {
    tclist = findtag(names->name, save_tclist);
    if (tclist == NULL) {
      errorrec = newerrorptr(nameundeftc);
      errorrec->UU.errorstr = names->name;
      errorrec->linenumber = line;
      errorrec->column = col;
      ttype = getbasictype(ifbwild);   /*Set to wild type for undef name */
      semerror(errorrec);
    }  /* if */
    else if (tclist->sgnum != 0) {
      errorrec = newerrorptr(ddtname);
      errorrec->UU.errorstr = names->name;
      errorrec->linenumber = line;
      errorrec->column = col;
      semerror(errorrec);
    } else {
      if (ttype == NULL)
        ttype = tclist->typeptr;
      if (ttype->UU.U2.stelemtype != tclist->typeptr->UU.U2.stelemtype) {
        errorrec = newerrorptr(typesnsametc);
        errorrec->linenumber = line;
        errorrec->column = col;
        semerror(errorrec);
      }  /* if */
      else
        tclist->sgnum = subgrn->UU.subgraphnum;
    }
    names = names->next;
  }  /* while */
  if (tsymptr->UU.symptr != NULL) {
    sym = tsymptr->UU.symptr;
    sym->typeptr = ttype->UU.U2.stelemtype;
    sym->graphinfo->typeptr = ttype->UU.U2.stelemtype;
    sym->graphinfo->node_ = currentlevel->currentsubn0;
  }  /* if */
  pushsemantic(tsymptr);
  pushsemantic(semtclist);
  pushsemantic(subgrn);

  /* else if */
  /* else */
}  /* CheckTagNames */


static void assocexprs()
{
  /*action 46 AssocExprs*/
  /*stack        pops - nothing
                pushes - Nothing*/
  /*description
         Closes off a tagcase subgraph associating the output
         expressions with the tagcase node.*/
  if (semtrace)
    printf(" In AssocExprs\n");
  endiftagsubgraph(false);
}  /* AssocExprs */


static void endtagcase()
{
  /*action 47 EndTagcase*/
  /*stack        pops - TGSubGraphNum
                        TGTCStackList
                        TGSymPtr
                pushes - Nothing*/
  /*description
         Create the association list for the union in the explist.
         Make sure every tag was mentioned in the tagcase.*/
  /* semanticrec *subgrn, *semtclist, *tsymptr; */
  semanticrec *semtclist;
  tcstacklistrec *struct_;
  node *tnode;
  errorrecord *errorrec;

  if (semtrace)
    printf(" In EndTagcase\n");
  /* subgrn = */ (void)popsemantic();
  semtclist = popsemantic();
  /* tsymptr = */ (void)popsemantic();
  struct_ = semtclist->UU.tcstacklist;
  tnode = currentlevel->UU.U4.tagcasenode;
  while (struct_ != NULL) {
    if (struct_->sgnum == 0) {
      errorrec = newerrorptr(notalltc);
      errorrec->UU.errorstr = struct_->typeptr->stliteral;
      errorrec->linenumber = linenumber;
      semerror(errorrec);
    }  /* if */
    else
      addtoassolist(tnode, struct_->sgnum - 1);
    struct_ = struct_->next;
  }  /* while */
  endcompound();
}  /* EndTagcase */


static void otherwisetag(line, col)
int line, col;
{
  /*action 48 OtherwiseTag*/
  /*stack        pops - TGSubGraphNum
                        TGTCStackList
                 pushes - TGSubGraphNum
                          TGTCStackList */
  /*description
         Mark all unmarked tags with current subgraph number. If none
         are found then declare an error. Push explist, subgraph number*/
  semanticrec *subgrn, *semtclist;
  tcstacklistrec *struct_;
  int subnum;
  boolean found;
  errorrecord *errorrec;

  if (semtrace)
    printf(" In OtherwiseTag\n");
  subgrn = popsemantic();
  semtclist = popsemantic();
  struct_ = semtclist->UU.tcstacklist;
  subnum = subgrn->UU.subgraphnum;
  found = false;
  while (struct_ != NULL) {
    if (struct_->sgnum == 0) {
      found = true;
      struct_->sgnum = subnum;
    }  /* if */
    struct_ = struct_->next;
  }
  if (!found) {
    errorrec = newerrorptr(othernone);
    errorrec->linenumber = line;
    errorrec->column = col;
    semerror(errorrec);
  }  /* if */
  pushsemantic(semtclist);
  pushsemantic(subgrn);
}  /* OtherwiseTag */


Char *typesemanticdata_NAMES[] = {
  "tgnamelist", "tgtypelist", "tgttptr", "tgsymptr", "tgexplist",
  "tgpreclevel", "tgsymlist", "tgnodeptr", "tgsubgraphnum", "tgoldflag",
  "tgreduceflag", "tgrednodetype", "tgtestflag", "tgtcstacklist"
} ;


Char *opertype_NAMES[] = {
  "noop", "orop", "andop", "mult", "divd", "plus", "minus", "concat", "lt",
  "le", "gt", "ge", "equal", "notequal", "uplus", "uminus", "unot"
} ;


Char *reduceflag_NAMES[] = {
  "rfnone", "rfsum", "rfproduct", "rfgreatest", "rfleast", "rfcatenate"
} ;


static void setstep()
{
  printf("Please enter step count: ");
  scanf("%d%*[^\n]", &stepcount);
  getchar();
  currentstep = stepcount;
}

static void showbrkpts()
{
  int i, j;

  printf("The Breakpoints are:\n");
  j = 0;
  for (i = 1; i <= maxsemanticnumber; i++) {   /****************/
    if (P_inset(i, breakpointset)) {
      printf("%5d", i);
      j += 5;
      if (j > 75) {
        putchar('\n');
        j = 0;
      }  /* if */
    }  /* if */
  }
  if (j != 0)
    putchar('\n');
}  /* ShowBrkPts */

static void removebrkpts()
{
  unchar rembrkpt;   /**************/
  int TEMP;
  /* long SET[maxsemanticnumber / 32 + 2]; */

  showbrkpts();
  printf("Enter the breakpoints to be removed:\n");
  while (!P_eoln(stdin)) {
    scanf("%d", &TEMP);
    rembrkpt = TEMP;
    P_remset(breakpointset, rembrkpt);
  }  /* while */
  scanf("%*[^\n]");
  getchar();
  showbrkpts();
}  /* RemoveBrkPts */

static void addbrkpts()
{
  unchar newbrkpt;   /************/
  int TEMP;
  /* long SET[maxsemanticnumber / 32 + 2]; */

  showbrkpts();
  printf("Enter the breakpoints to be added:\n");
  while (!P_eoln(stdin)) {
    scanf("%d", &TEMP);
    newbrkpt = TEMP;
    P_addset(breakpointset, newbrkpt);
  }  /* while */
  scanf("%*[^\n]");
  getchar();
  showbrkpts();
}  /* AddBrkPts */

static void printnames(namelist)
namelistrec *namelist;
{
  if (namelist == NULL)
    printf("namelist is nil\n");
  else {
    while (namelist != NULL) {
      writestring(stdout, &namelist->name);
      printf(" , ");
      namelist = namelist->next;
    }  /* while */
  }
  putchar('\n');
}  /* PrintNames */

static void printtypes_(typelist)
typelistrec *typelist;
{
  if (typelist == NULL) {
    printf("typelist is nil\n");
    return;
  }
  while (typelist != NULL) {
    if (typelist->typeptr != NULL) {
      outtype(stdout, typelist->typeptr, false);
      putchar('\n');
      typelist = typelist->next;
    } else
      printf(" nil type ptr \n");
  }  /* while */
}  /* PrintTypes */

static void printgraphinfo(info)
inforecord *info;
{
  if (info->node_ != NULL)
    printf(" ^.NDId  %5d ", info->node_->ndid);
  else
    printf("node is nil ");
  printf("Port %5d ", info->port_);
  if (info->typeptr != NULL)
    outtype(stdout, info->typeptr, true);
  else
    printf("type ptr is nil ");
  printf("   ");
  writestring(stdout, &info->name);
  putchar(' ');
  if (info->onlist != NULL)
    printf("Onlist is not nil ");
  else
    printf("OnList is nil ");
  printf("LitValue ");
  writestring(stdout, &info->litvalue);
  putchar('\n');
}  /* PrintGraphInfo */

static void printsymlist(symlist)
symlistnode *symlist;
{
  while (symlist != NULL) {
    printbucket(symlist->sym);
    putchar('\n');
    symlist = symlist->next;
  }  /* while */
}  /* PrintSymList */

static void printexplist(explist)
explistnode *explist;
{
  while (explist != NULL) {
    printgraphinfo(explist->graphinfo);
    putchar('\n');
    explist = explist->next;
  }  /* while */
}  /* PrintExpList */

static void printtclist(tclist)
tcstacklistrec *tclist;
{
  while (tclist != NULL) {
    writestring(stdout, &tclist->tagname);
    printf("  SGNum = %3d  ", tclist->sgnum);
    outtype(stdout, tclist->typeptr, true);
    putchar('\n');
    tclist = tclist->next;
  }
}

static void printstack()
{
  int i;
  semanticrec *semstack;

  printf("Please enter the number of stack items to be printed:\n");
  scanf("%d%*[^\n]", &i);
  getchar();
  semstack = topsemstk;
  while (semstack != NULL && i != 0) {
    printf("** Object is of type : %s\n",
           typesemanticdata_NAMES[(long)semstack->tag]);
    switch (semstack->tag) {

    case tgnamelist:
      printnames(semstack->UU.namelist);
      break;

    case tgtypelist:
      printtypes_(semstack->UU.typelist);
      break;

    case tgttptr:
      if (semstack->UU.ttptr != NULL) {
        outtype(stdout, semstack->UU.ttptr, false);
        putchar('\n');
      } else
        printf("semstack^.ttptr is nil\n");
      break;

    case tgsymptr:
      if (semstack->UU.symptr != NULL) {
        printf("%s  ", identtype_NAMES[(long)semstack->UU.symptr->identtag]);
        writestring(stdout, &semstack->UU.symptr->name);
        putchar('\n');
      } else
        printf("symptr is nil\n");
      break;

    case tgexplist:
      if (semstack->UU.explist == NULL)
        printf("semstack^.explist is nil\n");
      else
        printexplist(semstack->UU.explist);
      break;

    case tgsymlist:
      if (semstack->UU.symlist == NULL)
        printf("semstack^.SymList is nil\n");
      else
        printsymlist(semstack->UU.symlist);
      break;

    case tgpreclevel:
      printf("prec level %12d", semstack->UU.U5.preclevel);
      printf("operation = %s\n",
             opertype_NAMES[(long)semstack->UU.U5.operation]);
      break;

    case tgnodeptr:
      if (semstack->UU.nodeptr == NULL)
        printf(" semstack^.nodeptr is nil\n");
      else {
        printf("Node id is %12d", semstack->UU.nodeptr->ndid);
        printf("Node code is %12d\n", semstack->UU.nodeptr->ndcode);
      }
      break;

    case tgsubgraphnum:
      printf(" Num of subgraphs = %4d\n", semstack->UU.subgraphnum);
      break;

    case tgoldflag:
      printf("Old Flag = %s\n", semstack->UU.oldflag ? " TRUE" : "FALSE");
      break;

    case tgreduceflag:
      printf("Reduce Flag = %s\n",
             reduceflag_NAMES[(long)semstack->UU.redflag]);
      break;

    case tgrednodetype:
      printf("Reduce Type = %12d\n", semstack->UU.rednodetype);
      break;

    case tgtcstacklist:
      if (semstack->UU.tcstacklist == NULL)
        printf("TC List is nil\n");
      else
        printtclist(semstack->UU.tcstacklist);
      break;
    default:
       ;
    }/*  case */
    semstack = semstack->next;
    i--;
  }  /* while */
  if (i != 0)
    printf("Not that many items on stack\n");
}  /* PrintStack */


boolean debugger(action, token)
int action, token;
{
  boolean Result;
  int i;
  boolean run;
  Char ch;
  treestackobj *temp;
  /* node *node_; */

  if (token != -1) {
    printf("action number is : %12d", action);
    switch (action) {

    case lbinitsem:
      printf(" initsem\n");
      break;

    case lbstartfunction:
      printf(" startfunction(inputtoken)\n");
      break;

    case lbaddtonamelist:
      printf(" addtonamelist(inputtoken)\n");
      break;

    case lbstartnamelist:
      printf(" startnamelist\n");
      break;

    case lbstarttypelist:
      printf(" starttypelist\n");
      break;

    case lbaddtotypelist:
      printf(" addtotypelist\n");
      break;

    case lbendglobalheader:
      printf(" EndGlobalHeader\n");
      break;

    case lbendforwardglobheader:
      printf(" EndForwardGlobHeader\n");
      break;

    case lbsmashintotable:
      printf(" SmashIntoTable\n");
      break;

    case lbpushbasic:
      printf(" PushBasic(token)\n");
      break;

    case lbpushtypename:
      printf(" PushTypeName(inputtoken)\n");
      break;

    case lbpusharray:
      printf(" PushArray\n");
      break;

    case lbpushdefarray:
      printf(" PushDefArray\n");
      break;

    case lbpushstream:
      printf(" PushStream\n");
      break;

    case lbpushdefstream:
      printf(" PushDefStream\n");
      break;

    case lbpushrecord:
      printf(" PushRecord\n");
      break;

    case lbpushdefrecord:
      printf(" PushDefRecord\n");
      break;

    case lbpushdefunion:
      printf(" PushUnion\n");
      break;

    case lbpushunion:
      printf(" PushDefUnion\n");
      break;

    case lbpushnulltype:
      printf(" PushNullType\n");
      break;

    case lbfinishtypelinks:
      printf(" FinishTypeLinks\n");
      break;

    case lbchecktypename:
      printf(" CheckTypeName(inputtoken)\n");
      break;

    case lblinkbase:
      printf(" LinkBase\n");
      break;

    case lbbuildfield:
      printf(" BuildField\n");
      break;

    case lbbuilddeffield:
      printf(" BuildDefField\n");
      break;

    case lbbuildtag:
      printf(" BuildTag\n");
      break;

    case lbbuilddeftag:
      printf(" BuildDefTag\n");
      break;

    case lbenddefinelist:
      printf(" EndDefineList\n");
      break;

    case lbaddtodefinelist:
      printf(" AddToDefineList(inputtoken)\n");
      break;

    case lbstartforwardfunct:
      printf(" StartForwardFunct\n");
      break;

    case lbstartglobalfunct:
      printf(" StartGlobalFunct\n");
      break;

    case lbprocessparam:
      printf(" ProcessParam\n");
      break;

    case lbendfunctionheader:
      printf(" EndFunctionHeader\n");
      break;

    case lbendfunctionlist:
      printf(" EndFunctionList\n");
      break;

    case lbendfunction:
      printf(" EndFunction\n");
      break;

    case lbstartsymlist:
      printf(" StartSymList\n");
      break;

    case lbcheckatypes:
      printf(" CheckATypes\n");
      break;

    case lbcheckarity:
      printf(" CheckArity\n");
      break;

    case lbassoctypes:
      printf(" AssocTypes\n");
      break;

    case lbincreasegenerator:
      printf(" IncreaseGenerator\n");
      break;

    case lbcheckcross:
      printf(" CheckCross\n");
      break;

    case lbexplicitcross:
      printf(" ExplicitCross\n");
      break;

    case lbstartbody:
      printf(" StartBody\n");
      break;

    case lbendabody:
      printf(" EndABody\n");
      break;

    case lbendbbody:
      printf(" EndBBody\n");
      break;

    case lbmakeforall:
      printf(" MakeForall\n");
      break;

    case lbfixforfunct:
      printf(" FixForFunct\n");
      break;

    case lbfixfortag:
      printf(" FixForTag\n");
      break;

    case lbprocesstaghead:
      printf(" ProcessTagHead\n");
      break;

    case lbchecktagnames:
      printf(" CheckTagNames\n");
      break;

    case lbassocexprs:
      printf(" AssocExprs\n");
      break;

    case lbendtagcase:
      printf(" EndTagcase\n");
      break;

    case lbotherwisetag:
      printf(" OtherwiseTag\n");
      break;

    case lbcreatetagsubgraph:
      printf(" CreateTagSubgraph\n");
      break;

    case lbstartforinit:
      printf(" StartForinit\n");
      break;

    case lbendinitpart:
      printf(" EndInitPart\n");
      break;

    case lbpushwhile:
      printf(" PushWhile\n");
      break;

    case lbpushuntil:
      printf(" PushUntil\n");
      break;

    case lbstartatest:
      printf(" StartATest\n");
      break;

    case lbendtest:
      printf(" EndTest\n");
      break;

    case lbloopbassoclist:
      printf(" LoopBAssocList\n");
      break;

    case lbloopaassoclist:
      printf(" LoopBAssocList\n");
      break;

    case lbpushold:
      printf(" PushOld\n");
      break;

    case lbpushnoold:
      printf(" PushNoOld\n");
      break;

    case lbdoredright:
      printf(" DoRedRight\n");
      break;

    case lbdoredleft:
      printf(" DoRedLeft\n");
      break;

    case lbdoredtree:
      printf(" DoRedTree\n");
      break;

    case lbdoreduce:
      printf(" DoReduce\n");
      break;

    case lbdosum:
      printf(" DoSum\n");
      break;

    case lbdoproduct:
      printf(" DoProduct\n");
      break;

    case lbdogreatest:
      printf(" DoGreatest\n");
      break;

    case lbdoleast:
      printf(" DoLeast\n");
      break;

    case lbdocatenate:
      printf(" DoCatenate\n");
      break;

    case lbnoredop:
      printf(" NoRedOp\n");
      break;

    case lbdounlessexp:
      printf(" DoUnlessExp\n");
      break;

    case lbdowhenexp:
      printf(" DoWhenExp\n");
      break;

    case lbnomaskingexp:
      printf(" NoMaskingExp\n");
      break;

    case lbdovalueof:
      printf(" DoValueOf\n");
      break;

    case lbdoarrayof:
      printf(" DoArrayOf\n");
      break;

    case lbdostreamof:
      printf(" DoStreamOf\n");
      break;

    case lbstartreturns:
      printf(" StartReturns\n");
      break;

    case lbstartainitbody:
      printf(" StartAInitBody\n");
      break;

    case lbendbody:
      printf(" EndBody\n");
      break;

    case lbendforinit:
      printf(" EndForinit\n");
      break;

    case lbstartif:
      printf(" StartIf\n");
      break;

    case lbstartifsubgraph:
      printf(" StartIfSubgraph\n");
      break;

    case lbendifsubgraph:
      printf(" EndIfSubgraph\n");
      break;

    case lbendpredsubgraph:
      printf(" EndPredSubGraph\n");
      break;

    case lbendif:
      printf(" EndIf\n");
      break;

    case lbbeforeexp:
      printf(" BeforeExp\n");
      break;

    case lbincboostfac:
      printf(" IncBoostFac\n");
      break;

    case lbdecboostfac:
      printf(" DecBoostFac\n");
      break;

    case lbreduceexp:
      printf(" ReduceExp\n");
      break;

    case lbpoppreclevel:
      printf(" PopPrecLevel\n");
      break;

    case lbafterexp:
      printf(" AfterExp\n");
      break;

    case lbdofieldlist:
      printf(" DoFieldList\n");
      break;

    case lbpushnilttptr:
      printf(" PushNILTTPtr\n");
      break;

    case lbstartrbuild:
      printf(" StartRBuild\n");
      break;

    case lbbuildfieldlist:
      printf(" BuildFieldList\n");
      break;

    case lbendrbuild:
      printf(" EndRBuild\n");
      break;

    case lbstartabuild:
      printf(" StartABuild\n");
      break;

    case lbstartsbuild:
      printf(" StartSBuild\n");
      break;

    case lbdolowerbound:
      printf(" DoLowerBound\n");
      break;

    case lbendabuild:
      printf(" EndABuild\n");
      break;

    case lbendsbuild:
      printf(" EndSBuild\n");
      break;

    case lbpushniltag:
      printf(" PushNILTag\n");
      break;

    case lbendubuild:
      printf(" EndUBuild\n");
      break;

    case lbpushemptyexplist:
      printf(" PushEmptyExpList\n");
      break;

    case lbdofunctcall:
      printf(" DoFunctCall\n");
      break;

    case lbdoarrayindex:
      printf(" DoArrayIndex\n");
      break;

    case lbdoarrayreplace:
      printf(" DoArrayReplace\n");
      break;

    case lbbuildreplace:
      printf(" BuildReplace\n");
      break;

    case lbdobinaryop:
      printf(" DoBinaryOp(token)\n");
      break;

    case lbpushnilcons:
      printf(" PushNilCons\n");
      break;

    case lbpushtruecons:
      printf(" PushTrueCons\n");
      break;

    case lbpushfalsecons:
      printf(" PushFalseCons\n");
      break;

    case lbpushintcons:
      printf(" PushIntCons\n");
      break;

    case lbpushrealcons:
      printf(" PushRealCons\n");
      break;

    case lbpushcharcons:
      printf(" PushCharCons\n");
      break;

    case lbpushstringcons:
      printf(" PushStringCons\n");
      break;

    case lbpusherrorcons:
      printf(" PushErrorCons\n");
      break;

    case lbfindandpushname:
      printf(" FindAndPushName\n");
      break;

    case lbbuildchar:
      printf(" BuildChar\n");
      break;

    case lbbuilddouble:
      printf(" BuildDouble\n");
      break;

    case lbbuildint:
      printf(" BuildInt\n");
      break;

    case lbbuildreal:
      printf(" BuildReal\n");
      break;

    case lbcreateisunion:
      printf(" CreateIsUnion\n");
      break;

    case lbcheckold:
      printf(" CheckOld\n");
      break;

    case lbpushuplus:
      printf(" PushUPlus\n");
      break;

    case lbpushuminus:
      printf(" PushUMinus\n");
      break;

    case lbpushunot:
      printf(" PushUNot\n");
      break;

    case lbcreateiserror:
      printf(" CreateIsError\n");
      break;

    case lbpopsymlist:
      printf(" PopSymList\n");
      break;

    case lbopenllevel:
      printf(" OpenLLevel\n");
      break;

    case lbendlevel:
      printf(" EndLevel\n");
      break;

    case lbendforall:
      printf(" EndForAll\n");
      break;

    case lbendprogram:
      printf(" EndProgram\n");
      break;

    case lbpushdoubcons:
      printf(" PushDoubCons\n");
      break;

    case lbstartbtest:
      printf(" StartBTest\n");
      break;

    case lbstartbinitbody:
      printf(" StartBInitBody\n");
      break;

    case lbaftersimpexp:
      printf(" AfterSimpExp\n");
      break;

    case lbendtypedefs:
      printf(" EndTypeDefs\n");
      break;

    case lbstarttypedefs:
      printf(" StarTypeDefs\n");
      break;

    case lbpreparefordot:
      printf(" PrepareForDot\n");
      break;
    default:
       ;
    }/* case */
    printf("Token is: %6d  ", token);
    writestring(stdout, &inputtoken);
    putchar('\n');
  }  /* if */
  else {
    currentstep = 0;
    stepcount = 0;
    P_expset(breakpointset, 0L);
  }
  run = false;
  Result = true;
  while (!run) {
    if (currentstep == 0)
      currentstep = stepcount;
    printf("  Please type: \n");
    printf(" 0 : to add break points.      1 : to remove break points.\n");
    printf(" 2 : turn on parse trace       3 : to set step count.\n");
    printf(" 4 : continue running          5 : symbol table, Current\n");
    printf(" 6 : symbol table,Root.        7 : semantic stack.\n");
    printf(" 8 : turn sem trace on.        9 : turn trace off.\n");
    printf("10 : enter graphwalker        11 : try to run dump.\n");
    printf("12 : Quit.\n");
    scanf("%d%*[^\n]", &i);
    getchar();
    switch (i) {

    case 0:
      addbrkpts();
      break;

    case 1:
      removebrkpts();
      break;

    case 2:
      debug = true;
      cortrace = true;
      break;

    case 3:
      setstep();
      break;

    case 4:
      run = true;
      break;

    case 5:
      if (currentlevel != NULL)
        crossref(stdout, currentlevel);
      else
        printf("Symbol table not initialized yet\n");
      ch = getchar();
      if (ch == '\n')
        ch = ' ';
      break;

    case 6:
      if (currentlevel != NULL) {
        temp = currentlevel;
        while (temp->lleveltag != root)
          temp = temp->lastlevel;
        crossref(stdout, temp);
      }  /* if */
      else
        printf("Symbol table not initialized yet\n");
      ch = getchar();
      if (ch == '\n')
        ch = ' ';
      break;

    case 7:
      printstack();
      ch = getchar();
      if (ch == '\n')
        ch = ' ';
      break;

    case 8:
      semtrace = true;
      break;

    case 9:
      semtrace = false;
      cortrace = false;
      debug = false;
      break;

    case 10:
      /* node_ = */ (void)graphwalk(module);
      break;

    case 11:
      dumpmodule();
      break;

    case 12:
      run = true;
      Result = false;
      break;
    default:
       ;
    }/* case */
  }  /* while */
  return Result;
}  /* Debugger */


boolean announceaction(action, token, line, col, inputtoken)
int action, token, line, col;
stryng inputtoken;
{
  /*--------------------------------------------------------------------
    call the semantic routine
    put a case action of
             ...
    here to call your personal routines.
   --------------------------------------------------------------------*/
  boolean Result;

  Result = true;
  currentstep--;
  if (P_inset(action, breakpointset) || currentstep == 0)
    Result = debugger(action, token);
  switch (action) {

  case lbinitsem:
    initsem();
    break;

  case lbstartfunction:
    startfunction(inputtoken, action, line, col);
    break;

  case lbstartglobalfunct:
    startfunction(inputtoken, action, line, col);
    break;

  case lbaddtonamelist:
    addtonamelist(inputtoken, line, col);
    break;

  case lbstartnamelist:
    startnamelist();
    break;

  case lbstarttypelist:
    starttypelist();
    break;

  case lbaddtotypelist:
    addtotypelist();
    break;

  case lbendforwardglobheader:
    endforwardglobheader();
    break;

  case lbsmashintotable:
    smashintotable();
    break;

  case lbpushbasic:
    pushbasic(token);
    break;

  case lbpushtypename:
    pushtypename(inputtoken, line, col);
    break;

  case lbpusharray:
    pusharray(noaddtottable);
    break;

  case lbpushdefarray:
    pusharray(addtottable);
    break;

  case lbpushstream:
    pushstream(noaddtottable);
    break;

  case lbpushdefstream:
    pushstream(addtottable);
    break;

  case lbpushrecord:
    pushrecord(noaddtottable);
    break;

  case lbpushdefrecord:
    pushrecord(addtottable);
    break;

  case lbpushunion:
    pushunion(noaddtottable);
    break;

  case lbpushdefunion:
    pushunion(addtottable);
    break;

  case lbpushnulltype:
    pushnulltype();
    break;

  case lbfinishtypelinks:
    finishtypelinks();
    break;

  case lbchecktypename:
    checktypename(inputtoken, line, col);
    break;

  case lblinkbase:
    linkbase();
    break;

  case lbbuildfield:
    buildfield(noaddtottable);
    break;

  case lbbuilddeffield:
    buildfield(addtottable);
    break;

  case lbbuildtag:
    buildtag(noaddtottable);
    break;

  case lbbuilddeftag:
    buildtag(addtottable);
    break;

  case lbenddefinelist:
    enddefinelist();
    break;

  case lbaddtodefinelist:
    addtodefinelist(inputtoken);
    break;

  case lbstartforwardfunct:
    startforwardfunct(inputtoken, line, col);
    break;

  case lbprocessparam:
    processparam();
    break;

  case lbendfunctionheader:
    endfunctionheader();
    break;

  case lbendfunctionlist:
    endfunctionlist();
    break;

  case lbendfunction:
    endfunction();
    break;

  case lbstartsymlist:
    startsymlist();
    break;

  case lbcheckatypes:
    checkatypes(line, col);
    break;

  case lbcheckarity:
    checkarity();
    break;

  case lbassoctypes:
    assoctypes();
    break;

  case lbincreasegenerator:
    increasegenerator(line, col);
    break;

  case lbcheckcross:
    checkcross();
    break;

  case lbexplicitcross:
    explicitcross(line, col);
    break;

  case lbstartbody:
    startbody();
    break;

  case lbendabody:
    endabody(line, col);
    break;

  case lbendbbody:
    endbbody(line, col);
    break;

  case lbmakeforall:
    makeforall(line, col);
    break;

  case lbfixforfunct:
    fixforfunct();
    break;

  case lbfixfortag:
    fixfortag(line, col);
    break;

  case lbprocesstaghead:
    processtaghead(line, col);
    break;

  case lbchecktagnames:
    checktagnames(line, col);
    break;

  case lbassocexprs:
    assocexprs();
    break;

  case lbendtagcase:
    endtagcase();
    break;

  case lbotherwisetag:
    otherwisetag(line, col);
    break;

  case lbcreatetagsubgraph:
    createtagsubgraph();
    break;

  case lbstartforinit:
    startforinit();
    break;

  case lbendinitpart:
    endinitpart();
    break;

  case lbpushwhile:
    pushwhile();
    break;

  case lbpushuntil:
    pushuntil();
    break;

  case lbstartatest:
    startatest();
    break;

  case lbendtest:
    endtest();
    break;

  case lbloopbassoclist:
    loopbassoclist();
    break;

  case lbloopaassoclist:
    loopaassoclist();
    break;

  case lbpushold:
    pushold();
    break;

  case lbpushnoold:
    pushnoold();
    break;

  case lbdoredright:
    doreduce(action);
    break;

  case lbdoredleft:
    doreduce(action);
    break;

  case lbdoredtree:
    doreduce(action);
    break;

  case lbdoreduce:
    doreduce(action);
    break;

  case lbdosum:
    dosum();
    break;

  case lbdoproduct:
    doproduct();
    break;

  case lbdogreatest:
    dogreatest();
    break;

  case lbdoleast:
    doleast();
    break;

  case lbdocatenate:
    docatenate();
    break;

  case lbnoredop:
    noredop();
    break;

  case lbdounlessexp:
    dounlessexp();
    break;

  case lbdowhenexp:
    dowhenexp();
    break;

  case lbnomaskingexp:
    nomaskingexp();
    break;

  case lbdovalueof:
    dovalueof();
    break;

  case lbdoarrayof:
    doarrayof(action);
    break;

  case lbdostreamof:
    doarrayof(action);
    break;

  case lbstartreturns:
    startreturns();
    break;

  case lbstartainitbody:
    startainitbody();
    break;

  case lbendbody:
    endbody();
    break;

  case lbendforinit:
    endforinit();
    break;

  case lbstartif:
    startif(ifcomp);
    break;

  case lbstartnestedif:
    startif(nestedifcomp);
    break;

  case lbstartifsubgraph:
    startifsubgraph();
    break;

  case lbendifsubgraph:
    endifsubgraph();
    break;

  case lbendpredsubgraph:   /*EndPredSubGraph*/
    printf("INTERNAL ERROR\n");
    break;

  case lbendif:
    endif();
    break;

  case lbbeforeexp:
    beforeexp();
    break;

  case lbincboostfac:
    incboostfac();
    break;

  case lbdecboostfac:
    decboostfac();
    break;

  case lbreduceexp:
    reduceexp();
    break;

  case lbpoppreclevel:
    poppreclevel();
    break;

  case lbafterexp:
    afterexp();
    break;

  case lbdofieldlist:
    dofieldlist(line, col);
    break;

  case lbpushnilttptr:
    pushnilttptr();
    break;

  case lbstartrbuild:
    pushrecord(noaddtottable);
    startrbuild();
    break;

  case lbbuildfieldlist:
    buildfieldlist(line, col);
    break;

  case lbendrbuild:
    endrbuild(line, col);
    break;

  case lbstartabuild:
    startabuild();
    break;

  case lbstartsbuild:
    pushstream(noaddtottable);
    startsbuild();
    break;

  case lbdolowerbound:
    dolowerbound();
    break;

  case lbendabuild:
    endabuild();
    break;

  case lbendsbuild:
    endsbuild(line, col);
    break;

  case lbpushniltag:
    pushniltag();
    break;

  case lbendubuild:
    endubuild(line, col);
    break;

  case lbpushemptyexplist:
    pushemptyexplist();
    break;

  case lbdofunctcall:
    dofunctcall();
    break;

  case lbdoarrayindex:
    doarrayindex();
    break;

  case lbdoarrayreplace:
    doarrayreplace();
    break;

  case lbbuildreplace:
    buildreplace(line, col);
    break;

  case lbdobinaryop:
    dobinaryop(token, line, col);
    break;

  case lbpushnilcons:
    pushnilcons();
    break;

  case lbpushtruecons:
    pushtruecons();
    break;

  case lbpushfalsecons:
    pushfalsecons();
    break;

  case lbpushintcons:
    pushintcons();
    break;

  case lbpushrealcons:
    pushrealcons();
    break;

  case lbpushcharcons:
    pushcharcons();
    break;

  case lbpushstringcons:
    pushstringcons();
    break;

  case lbpusherrorcons:
    pusherrorcons();
    break;

  case lbfindandpushname:
    findandpushname();
    break;

  case lbbuildchar:
    buildchar();
    break;

  case lbbuilddouble:
    builddouble();
    break;

  case lbbuildint:
    buildint();
    break;

  case lbbuildreal:
    buildreal();
    break;

  case lbcreateisunion:
    createisunion(line, col);
    break;

  case lbcheckold:
    checkold(inputtoken, line, col);
    break;

  case lbpushuplus:
    pushuplus(line, col);
    break;

  case lbpushuminus:
    pushuminus(line, col);
    break;

  case lbpushunot:
    pushunot(line, col);
    break;

  case lbcreateiserror:
    createiserror(line, col);
    break;

  case lbpopsymlist:
    popsymlist();
    break;

  case lbopenllevel:
    createlevel(let);
    break;

  case lbendlevel:
    endlevel();
    break;

  case lbendforall:
    endforall();
    break;

  case lbendprogram:
    endprogram();
    break;

  case lbpushdoubcons:
    pushdoubcons();
    break;

  case lbstartbtest:
    startbtest();
    break;

  case lbstartbinitbody:
    startbinitbody();
    break;

  case lbaftersimpexp:
    aftersimpexp();
    break;

  case lbendtypedefs:
    endtypedefs();
    break;

  case lbstarttypedefs:
    starttypedefs();
    break;

  case lbpreparefordot:
    preparefordot();
    break;
  default:
     ;
  }/* case */
  return Result;
}  /* callsemantics*/


/**************************************************************************/
/* FILE   **************          file2.c          ************************/
/**************************************************************************/
/* Author: Skedz?                                                         */
/* Update: Dave Cann                                                      */
/* Update: Pat Miller -- ANSI compliance                                  */
/* Copyright (C) University of California Regents                         */
/**************************************************************************/
static void readcosts()
{
  /*-----------------------------------------------------------------
    read the correction costs for the terminals
   ------------------------------------------------------------------*/
  char term;
  int c, d;
  char FORLIM;
  insertstringrec *WITH;

  FORLIM = numterms;
  for (term = 1; term <= FORLIM; term++) {
    WITH = &costtable[term + 2];
    fread(&c, sizeof(int), 1, etableout);
    fread(&d, sizeof(int), 1, etableout);
    deletecosts[(int)term] = d;
    WITH->cost = c;
    insertptr++;
    WITH->first = insertptr;
    WITH->last = insertptr;
    insertspace[insertptr] = term;
  }
}  /* readcosts */


static void reads()
{
  /*-----------------------------------------------------------------
    read in the S table
  ------------------------------------------------------------------*/
  SHORT sym;
  int length, i, c;
  SHORT FORLIM;
  insertstringrec *WITH;

  FORLIM = numsymbols + 2;
  for (sym = numterms + 3; sym <= FORLIM; sym++) {   /* for */
    WITH = &costtable[sym];
    fread(&c, sizeof(int), 1, etableout);
    fread(&length, sizeof(int), 1, etableout);
    WITH->cost = c;
    if (insertptr + length > maxinsertspace) {
      printf(" increase size of insertspace\n");
      myabort();
    }
    WITH->first = insertptr + 1;
    for (i = 1; i <= length; i++) {
      insertptr++;
      fread(&c, sizeof(int), 1, etableout);
      insertspace[insertptr] = c;
    }
    WITH->last = insertptr;
  }
}  /* readS */


static void checkinsertsize(l)
int l;
{
  /*-------------------------------------------------------------------
    check to see if a string of length l will fit into insertspace
  --------------------------------------------------------------------*/
  if (insertptr + l > maxinsertspace) {
    printf(" constant exceeded, increase MaxInsertSpace\n");
    myabort();
  }
}  /* checkinsertsize */


static void get1prefix()
{
  /*-------------------------------------------------------------------
      read in all the prefix entries for this terminal symbol
       this will have to be changed slightly for direct access,
        put into prefixtable instead of full prefixtable
  --------------------------------------------------------------------*/
  int sym, insym, inscost, length, i;
  insertstringrec *WITH;

  fread(&sym, sizeof(int), 1, etableout);
  fread(&inscost, sizeof(int), 1, etableout);
  fread(&length, sizeof(int), 1, etableout);
  while (sym != 0) {
    checkinsertsize(length);
    WITH = &prefixtable[sym + 2];   /* with */
    WITH->first = insertptr + 1;
    WITH->cost = inscost;
    for (i = 1; i <= length; i++) {
      fread(&insym, sizeof(int), 1, etableout);
      if ((unsigned)insym > numsymbols)
        printf(" !! insym ?? %12d\n", insym);
      insertptr++;
      insertspace[insertptr] = insym;
    }  /* for */
    WITH->last = insertptr;
    fread(&sym, sizeof(int), 1, etableout);
    fread(&inscost, sizeof(int), 1, etableout);
    fread(&length, sizeof(int), 1, etableout);
  }  /* while */
}  /* get1prefix */


static void skipcosts()
{
  /*-----------------------------------------------------------------
    same as readcosts, but ignore the info
  ------------------------------------------------------------------*/
  char term;
  int c, deletecost;
  char FORLIM;

  FORLIM = numterms;
  for (term = 1; term <= FORLIM; term++) {
    fread(&c, sizeof(int), 1, etableout);
    fread(&deletecost, sizeof(int), 1, etableout);
  }
}  /* skipcosts */


static void skips()
{
  /*-----------------------------------------------------------------
     same as readS, but ignore the info
  ------------------------------------------------------------------*/
  SHORT sym;
  int i, c, length;
  SHORT FORLIM;

  FORLIM = numsymbols;
  for (sym = numterms + 1; sym <= FORLIM; sym++) {
    fread(&c, sizeof(int), 1, etableout);
    fread(&length, sizeof(int), 1, etableout);
    for (i = 1; i <= length; i++)
      fread(&c, sizeof(int), 1, etableout);
  }  /* for */
}  /* skipS */


static void skip1prefix()
{
  /*------------------------------------------------------------------
         same as get1prefix, but ignore the info
       this will have to be changed slightly for direct access,
        put into prefixtable instead of full prefixtable
  -------------------------------------------------------------------*/
  int sym, insym, inscost, length, i;

  fread(&sym, sizeof(int), 1, etableout);
  fread(&inscost, sizeof(int), 1, etableout);
  fread(&length, sizeof(int), 1, etableout);
  while (sym != 0) {
    for (i = 1; i <= length; i++) {
      fread(&insym, sizeof(int), 1, etableout);
      if ((unsigned)insym > numsymbols)
        printf(" !! insym ?? %12d\n", insym);
    }  /* for */
    fread(&sym, sizeof(int), 1, etableout);
    fread(&inscost, sizeof(int), 1, etableout);
    fread(&length, sizeof(int), 1, etableout);
  }  /* while */
}  /* skip1prefix */


static void seeke(term, directoryname)
char term;
stryng directoryname;
{
  /*------------------------------------------------------------------
       position the file pointer to the proper place to
       read the prefixes for term
  --------------------------------------------------------------------*/
  int sym, t, cost, length;
  boolean successfulopen;
  stryng etablename, etablesuffix;

  string10(&etablesuffix, "/etabl.bin");
  stripspaces(&etablesuffix);
  etablename = directoryname;
  if (etablename.len < maxstringchars)
    insertstring(&etablename, &etablesuffix, etablename.len + 1);
  successfulopen = openintread(&etableout, &etablename);
  /*    reset(etableout);  sks*/
  if (!successfulopen) {
    printf("Cannot find error correction tables in ");
    writestring(stdout, &etablename);
    printf(".\n");
    myabort();
  }
  fread(&t, sizeof(int), 1, etableout);
  fread(&sym, sizeof(int), 1, etableout);
  fread(&myinfinity, sizeof(int), 1, etableout);
  if (sym != numsymbols)
    printf(" symbols don't match parse tables %12d%12d\n", sym, numsymbols);
  if (t != numterms)
    printf(" terms don't match parse tables %12d%12d\n", t, numterms);
  skipcosts();
  skips();
  fread(&sym, sizeof(int), 1, etableout);
  fread(&cost, sizeof(int), 1, etableout);
  fread(&length, sizeof(int), 1, etableout);
  if (sym != 0 || cost != 1 || length != 0) {
    printf(" error in reading prefix tables\n");
    myabort();
  }  /* if */
  for (sym = 1; sym < term; sym++)
    skip1prefix();
}  /* seekE */


static void getprefixinfo(term, directoryname)
char term;
stryng directoryname;
{
  /*------------------------------------------------------------------
    get the prefixtable entries for term;
    similar to getstateinfo
  -------------------------------------------------------------------*/
  SHORT sym, FORLIM;
  insertstringrec *WITH;

  FORLIM = numsymbols + 2;
  for (sym = 3; sym <= FORLIM; sym++) {
    WITH = &prefixtable[sym];
    WITH->cost = myinfinity;
    WITH->first = 2;
    WITH->last = 1;
  }
  WITH = &prefixtable[term + 2];
  WITH->cost = 0;
  if (cortrace) {
    printf(" get info for ");
    printsym(term);
    putchar('\n');
  }
  insertptr = savinsertptr;
  /*this code uses random file access*/
  /*this code simulates random file access*/
  seeke(term, directoryname);
  get1prefix();
  curerrsym = term;
  prefixtable[term + 2].cost = 0;
}  /* getprefixinfo */


static void readerrtables(directoryname)
stryng *directoryname;
{
  /*----------------------------------------------------------------
    read in all the error table info
  -=---------------------------------------------------------------*/
  int sym, term;
  boolean successfulopen;
  stryng etablename, etablesuffix;

  if (!errortables)
    return;
  string10(&etablesuffix, "/etabl.bin");
  stripspaces(&etablesuffix);
  etablename = *directoryname;
  if (etablename.len < maxstringchars)
    insertstring(&etablename, &etablesuffix, etablename.len + 1);
  successfulopen = openintread(&etableout, &etablename);
  /*     reset(etableout);  sks */
  if (!successfulopen) {
    printf("Cannot find error correction tables in ");
    writestring(stdout, &etablename);
    printf(".\n");
    myabort();
  }
  fread(&term, sizeof(int), 1, etableout);
  fread(&sym, sizeof(int), 1, etableout);
  fread(&myinfinity, sizeof(int), 1, etableout);
  if (sym != numsymbols)
    printf(" symbols don't match parse tables %12d%12d\n", sym, numsymbols);
  if (term != numterms)
    printf(" terms don't match parse tables %12d%12d\n", term, numterms);
  readcosts();
  reads();
  savinsertptr = insertptr;
}  /* readerrtables */


static void copye(source, dest)
SHORT source;
stagerec *dest;
{
  /*-------------------------------------------------------------------
     copy source to dest, converting type of string
  --------------------------------------------------------------------*/
  SHORT i;
  insertstringrec *WITH;
  SHORT FORLIM;

  WITH = &prefixtable[source + 2];
  if (dest->length - WITH->first + WITH->last + 1 > maximuminsert) {
    printf(" insertion found is too long\n");
    myabort();
  }
  FORLIM = WITH->last;
  for (i = WITH->first; i <= FORLIM; i++) {
    dest->length++;
    dest->string[dest->length] = insertspace[i];
  }
  dest->cost += WITH->cost;
}  /* copyE */


static void copys(source, dest)
SHORT source;
stagerec *dest;
{
  /*-------------------------------------------------------------------
     copy source to dest, converting type of string
  --------------------------------------------------------------------*/
  SHORT i;
  insertstringrec *WITH1;
  SHORT FORLIM;

  WITH1 = &costtable[source + 2];
  if (dest->length - WITH1->first + WITH1->last + 1 > maximuminsert) {
    printf(" insertion found is too long\n");
    myabort();
  }
  FORLIM = WITH1->last;
  /*writeln('copystring ',first:3,' ',last:3,' ',cost:3);*/
  for (i = WITH1->first; i <= FORLIM; i++) {
    dest->length++;
    dest->string[dest->length] = insertspace[i];
  }
  dest->cost += WITH1->cost;
}  /* copyS */


static void printinsertion(ins)
stagerec ins;
{
  /*---------------------------------------------------------------
    print out the insertion string ins.
   ----------------------------------------------------------------*/
  char i;

  for (i = 1; i <= ins.length; i++) {
    printsym(ins.string[(int)i]);
    putchar(' ');
  }
  printf(" {%ld}", (long)ins.cost);
}  /*printinsertion*/


static void expandinsertion(minpos, insert)
SHORT minpos;
stagerec *insert;
{
  /*----------------------------------------------------------------
    expand out the insertion determined by the position in
    the stack and the error symbol
  -----------------------------------------------------------------*/
  SHORT pos;
  int sym;

  if (debug)
    printf("start expandinsertion\n");
  insert->cost = 0;
  insert->length = 0;
  for (pos = stackptr; pos > minpos; pos--) {
    sym = parsestack[pos];
    if (sym > 0)
      copys(sym, insert);
  }
  sym = parsestack[minpos];
  copye(sym, insert);
  if (debug)
    printf("end expandinsertion\n");
}  /* expandinsertion */


static void llinsert(errsym, insertion, directoryname)
char errsym;
stagerec *insertion;
stryng *directoryname;
{
  /*---------------------------------------------------------------
    compute the least-cost insertion to make errsym legal given the
        current parse stack.
   ----------------------------------------------------------------*/
  int stackloc, runningcost, mincost, thiscost;
  SHORT minpos;
  int sym;

  if (debug)
    printf("start LLInsert\n");
  if (curerrsym != errsym)
    getprefixinfo(errsym, *directoryname);
  stackloc = stackptr;
  runningcost = 0;
  mincost = myinfinity;
  do {
    sym = parsestack[stackloc];
    if (sym > 0) {
      thiscost = runningcost + prefixtable[sym + 2].cost;
      if (thiscost < mincost) {
        mincost = thiscost;
        minpos = stackloc;
      }
      runningcost += costtable[sym + 2].cost;
    }
    stackloc--;
  } while (runningcost < mincost && stackloc >= 0);
  if (mincost < myinfinity)
    expandinsertion(minpos, insertion);
  else
    insertion->cost = myinfinity;
  if (debug)
    printf("end LLInsert\n");
}  /* LLInsert */


static void inoverflow()
{
  /*---------------------------------------------------------------
    input buffer is full.
    give up
  ----------------------------------------------------------------*/
  if (debug)
    printf("end inoverflow\n");
  flushlines();
  printf(" ***%d*** line too long for correction\n", linenumber);
  myabort();
  if (debug)
    printf("end inoverflow\n");
}  /* inoverflow */


static void llcorrector(token, directoryname)
SHORT *token;
stryng *directoryname;
{
  /*-------------------------------------------------------------------
    find the least cost correction to get us out of this error situation
   --------------------------------------------------------------------*/
  stagerec insertion;
  SHORT nextsym;
  int delcost, mincost, delcount, deletepoint;
  stagerec savinsert;

  if (debug)
    printf("start LLcorrector\n");
  errorcount++;
  llinsert(*token, &savinsert, directoryname);
  if (cortrace) {
    printf(" first correction found costs %3ld\n", (long)savinsert.cost);
    printf(" insertion is: ");
    column = 15;
    printinsertion(savinsert);
    putchar('\n');
  }
  delcost = deletecosts[*token];
  mincost = savinsert.cost;
  deletepoint = 0;
  delcount = 0;
  nextsym = *token;

  while (delcost < mincost)
  {  /* consider deletions until accumulated cost is too high */
    numdeltried++;
    if (cortrace) {
      printf(" try deleting ");
      printsym(nextsym);
      putchar('\n');
    }
    peek(&nextsym);

    if (nextsym == commenttoken || nextsym == incltoken) {
      continue;
    }  /*then*/
    delcount++;
    llinsert(nextsym, &insertion, directoryname);
        /*find insert necessary if deletion made*/
    if (delcost + insertion.cost < mincost)
    {  /* a better correction is found remember it */
      deletepoint = delcount;
      savinsert = insertion;
      mincost = delcost + insertion.cost;
      if (cortrace) {
        printf(" better correction found:\n");
        printinsertion(savinsert);
        printf(" total cost is %2d\n\n", mincost);
      }
    }
    delcost += deletecosts[nextsym];
  }
  if (mincost >= myinfinity) {
    printf(" no correction is possible \n");
    myabort();
  }
  if (cortrace) {
    printf(" final correction: delete %d symbols, and insert\n", deletepoint);
    printf("   ");
    printinsertion(savinsert);
    putchar('\n');
  }
  if (deletepoint > 0)
    deletetokens(deletepoint);
  inserttokens(savinsert);
  tokinserted += savinsert.length;
  tokdeleted += deletepoint;
  if (debug)
    printf("end LLcorrector\n");
}  /* LLcorrector */


static void myabort()
{
  printf("************************ A B O R T *************************\n\n");

  /* if ( source != NULL ) {
    fclose(source);
    sprintf(dummystring, "rm %s", dummyfilename);
    system(dummystring);
    } */

  _Escape(-1);
}



static void initptab()
{
  /*------------------------------------------------------------------
    initialize the table to all nils
   -------------------------------------------------------------------*/
  SHORT sym;

  if (debug)
    printf("start initPtab\n");
  for (sym = 3; sym <= maxsym + 2; sym++)
    table[sym] = NULL;
  if (debug)
    printf("end initPtab\n");
}  /* initPtab */


SHORT findlltab(sym, term)
SHORT sym;
char term;
{
  /*-----------------------------------------------------------------
      lookup  the parse action for sym, term
  ------------------------------------------------------------------*/
  SHORT Result;
  ptabrec *p;

  if (debug)
    printf("start findLLtab\n");
  p = table[sym + 2];
  Result = 0;
  while (p != NULL) {
    if (SEXT(p->term, 10) != term) {
      p = p->next;
      continue;
    }
    /* code to compat with ntfmq */
    if (p->pact > 2000)
      Result = p->pact - 2000;
    else if (p->pact > 1000)
      Result = p->pact - 1000;
    else
      Result = p->pact;
    p = NULL;
  }
  if (debug)
    printf("end findLLtab\n");
  return Result;
}  /* findLLtab */


/*this procedure is not suited for use with text/binary option
  but is left here just in case you want to put in such a feature */
static void printstring(string)
stryng string;
{
  /*----------------------------------------------------------------
    print out a string.
   -----------------------------------------------------------------*/
  SHORT i, j;
  Char STR2[256];
  SHORT FORLIM;

  if (column + string.len > maxlinelength - 3) {
    printf("\n      ");
    column = 5;
  }
  FORLIM = string.len;
  for (i = 1; i <= FORLIM; i++) {
    j = i;
    sprintf(STR2, "%c", stringchar(&string, j));
    if (strcmp(STR2, blank) < 0)
      printf("\\%d", stringchar(&string, j));
    else
      fputc(stringchar(&string, j), stdout);
  }
  column += string.len;
}  /* printstring */


static void printsym(sym)
int sym;
{
  /*-----------------------------------------------------------------
    print out symbol number sym
   ------------------------------------------------------------------*/
  if (sym < 0)
    printf("#%d", -sym);
  else
    printstring(p.resword[sym + 2]);
}  /* printsym */


/*======================================================================
    routines to read and print source lines for LLParse
     Source input is read a line at a time into a buffer.
     In order to allow unlimited lookahead in case of an error,
     the buffers are allocated by 'new', and pointers are passed.
     The main entry point in normal use is 'readchar' which returns
     the next character in the buffer, moving to the next line when
     necessary.
     'Unreadchar' is the opposite of readchar, and puts a character back,
     allowing lookahead in the scanner. unreadchar cannot back up
     across lines.
     In normal use, characters are read from the buffer pointed to by
     'linebuf'.  During lookahead for error correction, new buffers are
     allocated.  Linebuf moves ahead with the new buffers, while 'oldline'
     points to the first buffer in the list.
     In order to effect corrections, two procedure are called:
     displaydeletions and DisplayInsertion. Each moves the linebuf
     pointer so that the next character read by 'readchar(linebuf)' will be
     the first character AFTER the changes. (displaydeletions calls 'scan'
     to accomplish this)
======================================================================*/
static void printline(buffer)
inputbuffer *buffer;
{
  /* (buffer: InBufPtr);forward */
  /*-------------------------------------------------------------------
       print out source line with corrections
  ------------------------------------------------------------------*/
  unchar i, FORLIM;

  if (buffer->lineno < 0)   /* if */
    return;

  if ( listing )                       /* CANN 2/92 */
    if ( buffer->buf[1] == '%' )       /* CANN 2/92 */
      if ( buffer->buf[2] == '$' ) {   /* CANN 2/92 */
        fprintf( listfile, "\n ------------ [" );
        FORLIM = buffer->inputfile.len;
        for (i = 0; i < FORLIM; i++)
          putc(buffer->inputfile.str[i],listfile);
        fprintf( listfile, "]\n\n" );
        return;                        /* CANN 2/92 */
        }                              /* CANN 2/92 */

  if (buffer->modified) {
    if (echoed) {
      printf("------ corrected to:\n");
      echoed = false;
    }
    printf(" **%3d* ", buffer->lineno);
    if (listing)
      fprintf(listfile, " **%3d* ", buffer->lineno);
  } else if (buffer->lineno > 0 && listing)
    fprintf(listfile, " %5d: ", buffer->lineno);
  else if (listing)
    fprintf(listfile, "        ");
  if (buffer->modified) {
    FORLIM = buffer->length;
    for (i = 1; i <= FORLIM; i++)
      putchar(buffer->buf[i]);
    putchar('\n');
  }
  if (listing) {
    FORLIM = buffer->length;
    for (i = 1; i <= FORLIM; i++)
      putc(buffer->buf[i], listfile);
    putc('\n', listfile);
  }
  if (cortrace) {
    printf("%6c", ' ');
    FORLIM = buffer->pointer;
    for (i = 1; i <= FORLIM; i++)
      putchar('-');
    printf("^\n");
  }
  if (!buffer->modified)
    return;
  printf(" error  ");
  if (listing)
    fprintf(listfile, " error  ");
  if (buffer->underline != NULL) {
    FORLIM = buffer->length;
    for (i = 1; i <= FORLIM; i++)
      putchar(buffer->underline[i]);
    putchar('\n');
    if (listing) {
      FORLIM = buffer->length;
      for (i = 1; i <= FORLIM; i++)
        putc(buffer->underline[i], listfile);
      putc('\n', listfile);
    }
    MyFree(buffer->underline); /* CANN */
    buffer->underline = NULL;
    return;
  }
  if (buffer->modified)
    putchar('\n');
  if (listing)
    putc('\n', listfile);
}  /* printline */


static void modify(buffer)
inputbuffer *buffer;
{
  /*-------------------------------------------------------------
    set the modified' flag for the buffer.
     If desired, echo the unchanged line first
   --------------------------------------------------------------*/
  if (debug)
    printf("start modify\n");
  if (!buffer->modified) {
    if (echooldline) {
      if (!echoed)
        printf(" ** syntax error **\n");
      printline(buffer);
      echoed = true;
    }
    buffer->modified = true;
  }
  if (debug)
    printf("end modify\n");
}  /* modify */


static void flushlines()
{
  /*-----------------------------------------------------------------
      after the program has been accepted,
       print any corrected lines that remain.
  ------------------------------------------------------------------*/
  if (debug)
    printf("start flushlines\n");
  while (linebuf != NULL) {
    if (linebuf->modified)
      printline(linebuf);
    linebuf = linebuf->next;
  }
  if (debug)
    printf("end flushlines\n");
}  /* flushline */


static void readline(buffer)
inputbuffer *buffer;
{
  /*--------------------------------------------------------------------
  actually read the line into buffer
  ---------------------------------------------------------------------*/
  Char ch;
  int i, pointer;
  stryng pragname, uninclstring, linenumstr, txt;

  done = false;
  while (!done) {
    if (P_eof(source)) {
      done = true;
      break;
    }
    if (!P_eoln(source)) {
      done = true;
      break;
    }
    linenumber++;
    if (listing)
      fprintf(listfile, " %5d: \n", linenumber);
    fscanf(source, "%*[^\n]");
    getc(source);
  }  /*while*/
  buffer->length = 1;
  buffer->pointer = 1;
  linenumber++;
  buffer->lineno = linenumber;
  buffer->modified = false;
  buffer->underline = NULL;
  buffer->next = NULL;
  if (P_eof(source)) {   /* with */
    if (debug)
      printf("end of file found\n");
    endfile = true;
    buffer->buf[buffer->pointer] = ' ';
    buffer->lastline = true;
    return;
  }
  buffer->lastline = false;
  do {
    ch = getc(source);
    if (ch == '\n')
      ch = ' ';
    buffer->buf[buffer->length] = ch;
    if (buffer->length == maxlinelength) {
      printf(" ***%d*** line too long\n", linenumber);
      myabort();
    }
    buffer->length++;
  } while (!P_eoln(source));

  fscanf(source, "%*[^\n]");
  getc(source);

  if ( buffer->buf[1] == '%' ) {
      txt.len = 0;
      for ( i = 1; i < buffer->length; i++ )
        concatchar(&txt, buffer->buf[i] );
      string20(&uninclstring, "%$UNINCLUDE         ");
      stripspaces(&uninclstring);
      substring(&pragname, &txt, 1, 11);
      if (equalstrings(&pragname, &uninclstring)) {
        mymemcpy(newfname.str, blankstring, sizeof(stryngar));
        newfname.len = 0;
        pointer = 13;
        while (stringchar(&txt, pointer) != ',') {
          concatchar(&newfname, stringchar(&txt, pointer));
          pointer++;
          }
        pointer++;
        mymemcpy(linenumstr.str, blankstring, sizeof(stryngar));
        linenumstr.len = 0;
        while (stringchar(&txt, pointer) != ')') {
          concatchar(&linenumstr, stringchar(&txt, pointer));
          pointer++;
          }
        pointer = 1;
        newlinenum = stringnumber(&linenumstr, &pointer, 10);

        linenumber = newlinenum;
        buffer->lineno = linenumber;
        buffer->length = 3;
        buffer->buf[2] = '$'; /* SO NOT PRINTED BY printline */
        buffer->inputfile = curinputfile = newfname;

        /* printstring(newfname); */
        /* printf( "DEBUG READLINE linenumber=%d newlinenum=%d\n", linenumber, newlinenum ); */
        }
    }
  /* XXX PROCESS %$UNINCLUDE(file,line) XXX */

  buffer->buf[buffer->length] = ' ';

  /* else  */
}  /* readline */


static void getline(buffer)
inputbuffer **buffer;
{
  /*(var buffer: InBufPtr); forward*/
  /*-----------------------------------------------------------------
    read one line of input or move to next line if one is buffered
     print previous line, if appropriate
   ------------------------------------------------------------------*/
  inputbuffer *temp;

  if (!peeking && (listing || (*buffer)->modified))
    printline(*buffer);
  if ((*buffer)->next != NULL) {
    if (peeking)
      *buffer = (*buffer)->next;
    else {
      temp = *buffer;
      *buffer = (*buffer)->next;
      MyFree(temp); /* HERE HERE HERE CANN */
    }
    (*buffer)->pointer = 1;
    return;
  }
  if (peeking) {
    (*buffer)->next = (inputbuffer *)Malloc(sizeof(inputbuffer));
    (*buffer)->next->next = NULL;
    *buffer = (*buffer)->next;
    (*buffer)->underline = NULL;
  }
  readline(*buffer);

  /* else */
}  /* getline */


static void readchar(ch, buffer)
Char *ch;
inputbuffer **buffer;
{
  /*---------------------------------------------------------------
    read in one character from the buffer.
    get the next line if necessary
   ----------------------------------------------------------------*/
  inputbuffer *WITH;

  if ((*buffer)->pointer > (*buffer)->length) {   /* at the end of line */
    if ((*buffer)->lastline)
      endfile = true;
    else
      getline(buffer);
  }
  WITH = *buffer;   /* with */
  *ch = WITH->buf[WITH->pointer];
  WITH->pointer++;
}  /* readchar */


static void unreadchar(ch, buff)
Char ch;
inputbuffer *buff;
{
  /*----------------------------------------------------------------
    put a character back into the buffer
   -----------------------------------------------------------------*/
  if (debug)
    printf("start unreadchar\n");
  buff->pointer--;
  if (buff->buf[buff->pointer] != ch) {   /* with */
    printf(" incorrect unreadchar \"%c\" %d\n", ch, buff->pointer);
    printf(" char was \"%c\"\n", buff->buf[buff->pointer]);
    printline(buff);
    myabort();
  }
  if (debug)
    printf("end unreadchar\n");
}  /* unreadchar */


static void insertcharbuf(ch, loc, buffer)
Char ch;
unchar loc;
inputbuffer *buffer;
{
  /*-------------------------------------------------------------------
      stick ch into the line held in buffer, at location loc
  --------------------------------------------------------------------*/
  unchar i;

  if (debug)
    printf("start insertcharbuf\n");
  if (buffer->length == maxlinelength)
    inoverflow();
  buffer->length++;
  for (i = buffer->length; i > loc; i--)
    buffer->buf[i] = buffer->buf[i - 1];
  buffer->buf[loc] = ch;
  if (debug)
    printf("end insertcharbuf\n");
}  /* insertcharbuf */


static void displaydeletions(pighowmany)
int pighowmany;
{
  /*----------------------------------------------------------------
    show that pighowmany tokens have been deleted
    (calls scan)
    be careful to leave the pointer pointing to the right place
    which is the next character after the change.
    ----------------------------------------------------------------*/
  int i;
  SHORT sym;
  inputbuffer *savbuf;

  if (debug)
    printf("start displaydeletions\n");
  modify(oldline);
  insertcharbuf('{', tokenstart - 1, oldline);   /* put in a bracket */
  oldline->pointer++;
  savbuf = oldline;
  oldline->pointer = tokenstart;
  for (i = 1; i <= pighowmany; i++) {  /* move past pighowmany tokens */
    modify(oldline);
    scan(&sym, &tokenlineno, &oldline);
  }
  modify(oldline);
  insertcharbuf('}', oldline->pointer, oldline);   /*put in a bracket*/
  insertcharbuf(' ', oldline->pointer + 1, oldline);   /* and a blank */
  oldline->pointer += 2;
  tokenstart = oldline->pointer;
  peeking = false;
  while (oldline != savbuf)   /* print the skipped lines */
    getline(&savbuf);
  linebuf = oldline;   /* next char will be first AFTER deletions */
  linebuf->pointer = tokenstart;
  if (debug)
    printf("end displaydeletions\n");
}  /* displaydeletions */


static void displayinsertion(token)
SHORT token;
{
  /*-------------------------------------------------------------
    show that token has been inserted
    put it before 'tokenstart'
    leave the pointer pointing after the change.
    -------------------------------------------------------------*/
  /* TWO TYPE CHANGES FOR LARGER LINE BUFFERS 1/92 CANN */
  /* unchar */ unsigned int oldindex;   /* index into old part of line */
  /* unchar */ unsigned int newindex;   /* index into new part of line */
  SHORT strindex;   /* index into the character rep for token */
  inputbuffer *WITH;
  unchar FORLIM;

  writestring(stdout,&infile[0]->parvalue);
  printf(":%d: Syntax Error corrected with auto-token insertion\n",linenumber);
  if (debug)
    printf("start displayinsertions\n");
  WITH = oldline;   /* with */
  modify(oldline);
  if (WITH->underline == NULL) {  /* create the underline line */
    WITH->underline = (Char *)Malloc(sizeof(linebuffer));
    for (oldindex = 1; oldindex <= maxlinelength; oldindex++) {
      if (oldindex <= WITH->length) {
        if (WITH->buf[oldindex] == tabord)
          WITH->underline[oldindex] = (Char)tabord;
        else
          WITH->underline[oldindex] = ' ';
      } else
        WITH->underline[oldindex] = ' ';
    }
  }
  if (WITH->length + p.resword[token + 2].len + 1 > maxlinelength)
    inoverflow();
  newindex = p.resword[token + 2].len + WITH->length + 1;
  FORLIM = tokenstart - 1;
  for (oldindex = WITH->length; oldindex >= FORLIM; oldindex--)
  {  /* make room in the line */
    WITH->buf[newindex] = WITH->buf[oldindex];
    newindex--;
  }
  WITH->length += p.resword[token + 2].len + 1;
  strindex = 1;
  FORLIM = tokenstart + p.resword[token + 2].len;
  for (newindex = tokenstart - 1; newindex < FORLIM; newindex++)
  {  /* insert the characters */
    WITH->buf[newindex] = stringchar(&p.resword[token + 2], strindex);
        /*stringspace[strindex];*/
    WITH->underline[newindex] = '*';
    strindex++;
  }
  WITH->pointer = tokenstart + p.resword[token + 2].len;
  tokenstart = WITH->pointer + 1;
  /*next char is first after insertions */
  WITH->buf[WITH->pointer - 1] = ' ';
  WITH->underline[WITH->pointer - 1] = ' ';
  linebuf = oldline;
  if (debug)
    printf("end displayinsertion\n");
}  /* DisplayInsertion */


/*===================SCANNER======================================*/
/*================================================================*/
/*----------------------------------------------------------------*/
static void scanerror()
{
  /*----------------------------------------------------------------*/
  if (listing) {
    fprintf(listfile, "ILLEGAL CHARACTER \" ");
    writestring(listfile, &inputtoken);
    fprintf(listfile, "\" found in input, was ignored! Line %d\n", linenumber);
  }
  printf("ILLEGAL CHARACTER \"");
  writestring(stdout, &inputtoken);
  printf("\" found in input, was ignored! Line %d\n", linenumber);
}


/*------------------------------------------------------------------*/
SHORT searchsymboltable(low, high, s, default_)
int low, high;
stryng *s;
SHORT default_;
{
  /*------------------------------------------------------------------*/
  int guess;
  boolean notfound;

  /* Searchsymboltable */
  notfound = true;
  while (low <= high && notfound) {   /* while */
    guess = (low + high) / 2;
    if (P_getbits_UB(debugflags, '1', 0, 3))
      printf("Guess = %d\n", guess);
    switch (stringcompare(s, &(p.resword[guess + 2]), true)) {

    case compareless:
      high = guess - 1;
      break;

    case compareequal:
      notfound = false;
      break;

    case comparegreater:
      low = guess + 1;
      break;
    }/* case */
  }
  if (notfound)
    return default_;
  else
    return guess;
}


/* p2c: mono.bin.noblank.p, line 22102: 
 * Note: Changed "* /" to "% /" in comment [140] */


/*----------------------------------------------------------*/
static SHORT lookupterm(term, default_, LINK)
stryng *term;
SHORT default_;
struct LOC_scan *LINK;
{
  /*----------------------------------------------------------*/
  SHORT result;

  result = searchsymboltable(firstkeyword, lastkeyword, term, default_);
  if (P_getbits_UB(debugflags, '1', 0, 3))
    printf("LookupTerm returned %d\n", result);
  return result;
}  /*LookupTerm*/

/*-------------------------------------------------------------------*/
static void ctrlchtooctal(c, s, LINK)
Char c;
stryng *s;
struct LOC_scan *LINK;
{
  /*---------------------------------------------------------------*/
  int i, d, m;

  if ((unchar)c < 32 &&
      ((1L << c) & ((1L << backspace_) | (1L << tabord_) | (1L << newline) |
                    (1L << formfeed))) != 0) {
    switch (c) {

    case backspace_:
      string10(s, "\\b        ");
      break;

    case tabord_:
      string10(s, "\\t        ");
      break;

    case newline:
      string10(s, "\\n        ");
      break;

    case formfeed:
      string10(s, "\\f        ");
      break;
    }/* case */
    return;
  }
  d = c;
  string10(s, "\\         ");
  for (i = 4; i >= 2; i--) {
    m = d & 7;
    d /= 8;
    insertchar(s, m + '0', i);
  }  /* for */

  /* else */
}  /* CtrlChToOctal */

/*---------------------------------------------------------------------*/
static int branchonfirstchar(LINK)
struct LOC_scan *LINK;
{
  /*---------------------------------------------------------------------*/
  int Result;

  /* BranchOnFirstChar */
  if (P_getbits_UB(debugflags, '1', 0, 3))
    printf("entering BranchOnFirstChar, ord(ch) = %12d\n", LINK->ch);
  /*REA      if (ch in P.CmdChars) then
          begin
            Done := true;
            BranchOnFirstChar := 23
          endREA*/
  if (LINK->ch == blankord || LINK->ch == newline || LINK->ch == tabord ||
      LINK->ch == fford) {
    Result = 0;
    firsttime = true;
    deletestring(&inputtoken, inputtoken.len, inputtoken.len);
    return Result;
  }
  /*  if ((LINK->ch < ' ' || LINK->ch > '~') | P_inset(LINK->ch, badcharset))
      return 24;  Using the default in the switch below instead */
  switch (LINK->ch) {   /* case ch */

  case '+':
  case '-':
  case '*':
  case '/':
  case '&':
  case '(':
  case ')':
  case '[':
  case ']':
  case ',':
  case ';':
  case '.':
  case '=':
    LINK->done = true;
    Result = 1;
    break;

  case 'A':
  case 'B':
  case 'C':
  case 'D':
  case 'E':
  case 'F':
  case 'G':
  case 'H':
  case 'I':
  case 'J':
  case 'K':
  case 'L':
  case 'M':
  case 'N':
  case 'O':
  case 'P':
  case 'Q':
  case 'R':
  case 'S':
  case 'T':
  case 'U':
  case 'V':
  case 'W':
  case 'X':
  case 'Y':
  case 'Z':
  case 'a':
  case 'b':
  case 'c':
  case 'd':
  case 'e':
  case 'f':
  case 'g':
  case 'h':
  case 'i':
  case 'j':
  case 'k':
  case 'l':
  case 'm':
  case 'n':
  case 'o':
  case 'p':
  case 'q':
  case 'r':
  case 's':
  case 't':
  case 'u':
  case 'v':
  case 'w':
  case 'x':
  case 'y':
  case 'z':
    Result = 2;
    break;

  case '\'':
    Result = 25;
    break;

  case '"':
    Result = 30;
    break;

  case '#':
  case '%':
    Result = 5;
    break;

  case ':':
    Result = 6;
    break;

  case '<':
    Result = 8;
    break;

  case '>':
    Result = 12;
    break;

  case '~':
    Result = 14;
    break;

  case '|':
    Result = 16;
    break;

  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
    Result = 18;
    break;

  default:
    Result = 24;
  }

  return Result;
}

static void scannererr(err, LINK)
errtype err;
struct LOC_scan *LINK;
{
  switch (err) {

  case charerr:
    printf("SCANNER ERROR ==>  invalid character constant\n");
    break;
  }/*case*/
}

static void unappend(string, buffer, LINK)
stryng *string;
inputbuffer **buffer;
struct LOC_scan *LINK;
{
  /*---------------------------------------------------------------
         remove last char from string
  ----------------------------------------------------------------*/
  unreadchar(stringchar(string, string->len), *buffer);
  deletestring(string, string->len, string->len);
}  /* unappend */


/*-----------------------------------------------------------*/
static void scan(token, tokenlineno, buffer)
SHORT *token;
int *tokenlineno;
inputbuffer **buffer;
{  /* Scanner */
  /* (var token : SymIndex ; var buffer: InBufPtr );forward */
  /* written by sks 83/2/2          */
  /*  rev 1  by sks 83/8/8  fixup on < had wrong state*/
  /* modifies my rea 85/6   for use with fmq error correcting parser       */
  /* imports: varsBadCharSet, idcharset, digitset, AltFFlag, EscapeChar*/
  /*P.numsymbols, P.CmdChars             */
  /*  const IdToken, EscapeToken, RealToken, IntegerToken, CatToken*/
  /*StringToken, AssignToken, LeToken, EqToken, GrToken*/
  /* exports: inputtoken, globalchar, inttokenval*/
  /* results: "token" gets token number or EscapeToken*/
  /*   if the latter, first char of inputtoken is either*/
  /*     space, backspace or escape*/
  /*"inputtoken" character string of the token*/
  /*"globalchar" character that caused scanning error*/
  /*"inttokenval" assigned when token=IntegerToken*/
  /*-----------------------------------------------------------*/
  struct LOC_scan V;
  int state;
  long octalchset[9];
  /*------------------------------------------------------
       TRANSITION DIAGRAM FOR THE VAL SCANNER
  (0)---{+-%/()[].,:;}--->((1))
   |
   |  .-------------.
   |  V             |
   +---letter---> ((2))---idchar--'
   |
   |
   |
   +---single quote---> (25) ---{not \}-------------> (28) ---quote---> ((29))
   |        |                            ^                  ^
   |                      |                            `----------.       |
   |        `---{\}---> (26) ---quote or nonoctal---'       |
   |                                   ||
   |                                   `---octal---(27)---quote-----------'
   |                                                |^
   |  |`----------.
   |  `---octal---'
   |
   |                     .---{not \ and not "}---.
   |                     |.----------------------'
   |                     |V
   +---double quote---> (30) ---double quote--------------------------> ((33))
   |                    |^^^
   |                    ||`--------------nonoctal---.|
   |                    |`---{" or nonoctal}---.    ||
   |      |             .--------'    ||
   |      |             V             ||
   |                    `---{\}---> (31)            ||
   |                                 `---octal---> (32) ---double quote---'
   |  |^
   |  |`----------.
   |  `---octal---'
   |
   |       .-------------------.
   |       V   |
   +---{%}---> ((5)) ---not newline--'
   |
   +---{:}---> ((6)) ---{=}---> ((7))
   |
   +---{<}---> ((8)) ---{=}---> ((9))
   |       |
   |       `--->{nonblank}--->(10)------------------+--{>}--->((11))
   |   ||
   |   `<---{not newline}---'
   |
   +---{>}---> ((12)) ---{=}---> ((13))
   |
   +---{tilde}---> ((14)) ---{=}---> ((15))
   |
   |---{|}---> ((16)) ---{|}---> ((17))
   |
   |  .-digits-.
   |  V    |
   +---digits---> ((18)) ----+   .-digits-.
   |  |            V        |
   |  `--{.}---> ((19)) ----+
   |       |
   |       `--{eE}---> (20) ---{+-}---> (21)
   |    |                |
   |                                          |              digits
   |    |                |
   |---{blank backspace escape}---> ((23))    |                +-digits-.
   |    |                |        |
   |                                          |                V        |
   `---badchar---> ((24))                     `---digits---> ((22)) ----'
  -----------------------------------------------------------------*/
  /*----------------- S c a n n e r ---------------------------------*/
  stryng newch;
  int i, pointer;
  stryng pragname, uninclstring, linenumstr;

  if (debug)
    printf("start scan\n");
  P_addsetr(P_expset(octalchset, 0L), '0', '7');
  mymemcpy(inputtoken.str, blankstring, sizeof(stryngar));
  inputtoken.len = 0;
  state = 0;
  statehistory[0] = state;
  V.done = false;
  if (P_getbits_UB(debugflags, '1', 0, 3))
    printf("Called Scanner.\n");
  firsttime = true;   /* DO THIS A BETTER WAY */
  do {
    readchar(&V.ch, buffer);
    if (!peeking && firsttime) {
      *tokenlineno = (*buffer)->lineno;
      tokenstart = (*buffer)->pointer;
      firsttime = false;
    }
    if (endfile) {
      V.done = true;
      *token = eoftoken;   /* end of file */
    } else {
      concatchar(&inputtoken, V.ch);
      switch (state) {   /* case State */

      case 0:
        state = branchonfirstchar(&V);
        if (debug)
          printf("branch on first char = %12d\n", state);
        break;

      /* Should never reach here */
      case 1:
        printf("Scanner error (state 1 reached) -- not your fault\n");
        break;

      /* Building an id... */
      case 2:
        V.done = !P_inset(V.ch, p.idcharset);
        break;

      /* Building a comment */
      case 5:
        if ((*buffer)->pointer > (*buffer)->length) {  /* at eoln */
          deletestring(&inputtoken, inputtoken.len, inputtoken.len);
          V.done = true;
        }
        break;

      /* Colon or Assign? */
      case 6:
        V.done = true;
        if (V.ch == '=')
          state = 7;
        else
          unappend(&inputtoken, buffer, &V);
        break;

      /*   Got a <, look for =, space, NewLine, etc */
      case 8:
        V.done = true;
        if (V.ch == '=')
          state = 9;
        else
          unappend(&inputtoken, buffer, &V);
        break;

      /* Got a >, check for >=  */
      case 12:
        V.done = true;
        if (V.ch == '=')
          state = 13;
        else
          unappend(&inputtoken, buffer, &V);
        break;

      /*  Got a tilde, check for tilde=  */
      case 14:
        V.done = true;
        if (V.ch == '=')
          state = 15;
        else
          unappend(&inputtoken, buffer, &V);
        break;

      /*  Got a |, check for '||' */
      case 16:
        V.done = true;
        if (V.ch == '|')
          state = 17;
        else
          unappend(&inputtoken, buffer, &V);
        break;

      /* Build an integer */
      case 18:
        if (P_inset(V.ch, p.digits)) {
          /* nothing */
          state = 18;
        } else if (V.ch == '.')
          state = 19;
        else if (V.ch == 'E' || V.ch == 'e')
          state = 20;
        else if (V.ch == 'D' || V.ch == 'd')
          state = 35;
        else {
          V.done = true;
          unappend(&inputtoken, buffer, &V);
        }
        break;

      /* Get fraction */
      case 19:
        if (P_inset(V.ch, p.digits))
          state = 19;
        else if (V.ch == 'E' || V.ch == 'e')
          state = 20;
        else if (V.ch == 'D' || V.ch == 'd')
          state = 35;
        else {
          V.done = true;
          unappend(&inputtoken, buffer, &V);
        }
        break;

      /* Get exponent */
      case 20:
        if (V.ch == '+' || V.ch == '-')
          state = 21;
        else if (P_inset(V.ch, p.digits))
          state = 22;
        else {
          V.done = true;
          unappend(&inputtoken, buffer, &V);
        }
        break;

      /* Saw an exponent sign, better get a digit */
      case 21:
        if (P_inset(V.ch, p.digits))
          state = 22;
        else {
          V.done = true;
          unappend(&inputtoken, buffer, &V);
        }
        break;

      /* Get rest of exponent */
      case 22:
        if (!P_inset(V.ch, p.digits)) {
          V.done = true;
          unappend(&inputtoken, buffer, &V);
        }
        break;

      case 24:  /* found an illegal char declare error and ignore */
        scanerror();
        mymemcpy(inputtoken.str, blankstring, sizeof(stryngar));
        inputtoken.len = 0;
        state = 0;
        break;

      case 25:
        if (V.ch == '\\')
          state = 26;
        else {
          state = 28;
          if (V.ch < ' ') {
            deletestring(&inputtoken, inputtoken.len, inputtoken.len);
            printf("calling Ctrltoct  ch = %c  ordch = %4d\n", V.ch, V.ch);
            ctrlchtooctal(V.ch, &newch, &V);
            i = 1;
            while (stringchar(&newch, i) != ' ') {
              fputc(stringchar(&newch, i), stdout);
              concatchar(&inputtoken, stringchar(&newch, i));
              /*REAEchoChar (NewCh[I]);      REA*/
              i++;
            }  /* while */
            putchar('\n');
          }  /* if */
        }  /* else */
        break;

      case 26:
        if (P_inset(V.ch, octalchset))
          state = 27;
        else
          state = 28;
        break;

      case 27:
        if (P_inset(V.ch, octalchset))
          state = 27;
        else if (V.ch == '\'') {
          state = 29;
          V.done = true;
        } else if (V.ch == newline) {
          state = 34;
          V.done = true;
        } else {
          state = 27;
          V.done = true;
        }
        break;

      case 28:
        if (V.ch != '\'')
          state = 27;
        V.done = true;
        break;

      case 30:
        if (V.ch == '"') {
          state = 33;
          V.done = true;
        } else if (V.ch == '\\')
          state = 31;
        else if (V.ch >= ' ')
          state = 30;
        else {
          deletestring(&inputtoken, inputtoken.len, inputtoken.len);
          ctrlchtooctal(V.ch, &newch, &V);
          i = 1;
          while (stringchar(&newch, i) != ' ') {
            concatchar(&inputtoken, stringchar(&newch, i));
            /*REA    EchoChar (NewCh[I]);REA*/
            i++;
          }  /* while */
        }
        break;

      case 31:
        if (P_inset(V.ch, octalchset))
          state = 32;
        else
          state = 30;
        break;

      case 32:
        if (V.ch == '"') {
          state = 33;
          V.done = true;
        } else if (P_inset(V.ch, octalchset))
          state = 32;
        else
          state = 30;
        break;

      /* Get exponent */
      case 35:
        if (V.ch == '+' || V.ch == '-')
          state = 36;
        else if (P_inset(V.ch, p.digits))
          state = 37;
        else {
          V.done = true;
          unappend(&inputtoken, buffer, &V);
        }
        break;

      /* Saw an exponent sign, better get a digit */
      case 36:
        if (P_inset(V.ch, p.digits))
          state = 37;
        else {
          V.done = true;
          unappend(&inputtoken, buffer, &V);
        }
        break;

      /* Get rest of exponent */
      case 37:
        if (!P_inset(V.ch, p.digits)) {
          V.done = true;
          unappend(&inputtoken, buffer, &V);
        }
        break;
      }
      statehistory[(int)inputtoken.len] = state;
      /*REA  end;  REA*/
      if (P_getbits_UB(debugflags, '1', 0, 3))
        printf("State and length are %4d%4d\n", state, inputtoken.len);
    }  /*else*/
  } while (!V.done);
  /* Now we have found a token string; it's time to assign the token */
  /* value and do any fixup (correct improper numbers, non-terminals  */
  if (*token != eoftoken) {   /* with P */
    switch (state) {   /* case State */

    /* done -- should be escape or bad character */
    case 0:
      break;

    /* single-character tokens.  ch has char of interest */
    case 1:
      *token = singlechar[V.ch - ' '];
      break;

    case 2:
      unappend(&inputtoken, buffer, &V);
      *token = lookupterm(&inputtoken, idtoken, &V);
      break;

    case 5:
      *token = commenttoken;
      commentflag = true;
      string20(&uninclstring, "%$UNINCLUDE         ");
      stripspaces(&uninclstring);
      substring(&pragname, &inputtoken, 1, 11);
      if (equalstrings(&pragname, &uninclstring)) {
        *token = incltoken;
        mymemcpy(newfname.str, blankstring, sizeof(stryngar));
        newfname.len = 0;
        pointer = 13;
        while (stringchar(&inputtoken, pointer) != ',') {
          concatchar(&newfname, stringchar(&inputtoken, pointer));
          pointer++;
        }
        pointer++;
        mymemcpy(linenumstr.str, blankstring, sizeof(stryngar));
        linenumstr.len = 0;
        while (stringchar(&inputtoken, pointer) != ')') {
          concatchar(&linenumstr, stringchar(&inputtoken, pointer));
          pointer++;
        }
        pointer = 1;
        newlinenum = stringnumber(&linenumstr, &pointer, 10);
      }
      break;

    case 6:
      *token = singlechar[':' - ' '];
      break;

    case 7:
      *token = assigntoken;
      break;

    case 8:
      *token = lttoken;
      break;

    case 9:
      *token = letoken;
      break;

    case 10:
      *token = singlechar['<' - ' '];
      break;

    case 11:
      *token = singlechar['<' - ' '];
      break;

    case 12:
      *token = gttoken;
      break;

    case 13:
      *token = getoken;
      break;

    case 14:
      *token = singlechar['~' - ' '];
      break;

    case 15:
      *token = netoken;
      break;

    case 16:
      *token = singlechar['|' - ' '];
      break;

    case 17:
      *token = cattoken;
      break;

    case 18:
      *token = integertoken;
      rea = 1;
      /* CHANGE THIS NEEDS TO BE PASSED
                                            A VARIABLE    */
      inttokenval = stringnumber(&inputtoken, &rea, 10);
      break;

    case 19:
    case 22:
      *token = realtoken;
      break;

    case 20:
    case 21:
      concatchar(&inputtoken, '0');
      *token = realtoken;
      break;

    case 23:
      *token = escapetoken;
      break;

    /*    24: begin
              globalchar := ch;
              scanerror;
              token := EscapeToken
            end;
    */
    case 25:
    case 26:
      concatchar(&inputtoken, '\'');
      *token = chartoken;
      break;

    case 27:
      unappend(&inputtoken, buffer, &V);
      concatchar(&inputtoken, '\'');
      scannererr(charerr, &V);
      *token = chartoken;
      break;

    case 28:
      *token = chartoken;
      break;

    case 29:
      if (inputtoken.len != 6)
        scannererr(charerr, &V);
      *token = chartoken;
      break;

    case 34:
      deletestring(&inputtoken, inputtoken.len, inputtoken.len);
      concatchar(&inputtoken, '\'');
      scannererr(charerr, &V);
      *token = chartoken;
      break;

    case 30:
    case 31:
      concatchar(&inputtoken, '"');
      *token = stringtoken;
      break;

    case 32:
      deletestring(&inputtoken, inputtoken.len, inputtoken.len);
      concatchar(&inputtoken, '"');
      *token = stringtoken;
      break;

    case 33:
      *token = stringtoken;
      break;

    case 35:
    case 36:
      concatchar(&inputtoken, '0');
      *token = doubtoken;
      break;

    case 37:
      *token = doubtoken;
      break;
    }
    if (P_getbits_UB(debugflags, '1', 0, 3)) {
      printf("   token(%2d) : \"", *token);
      writestring(stdout, &inputtoken);
      printf("\"\n");
    }
    tokenposition = 0;
  }  /*then*/
  if (debug)
    printf("end scan\n");

  /* else */
}  /* Scanner */


/*===============================================================
     scanner routines for llparse
     The scanner provided is almost certainly inadequate for
     use in a real-life situation, and will have to be replaced.
     It should be possible to replace only procedure 'scan'.
     If this is done, scan should take the same parameters,
     and get its input from 'readchar'.  Since scan is called from
     the corrector (actually from peek) extra side-effects, such
     as symbol-table manipulations, should be avoided, at least
     during correction. The side-effects should be placed in 'gettok'
     which is only called by the parser.
     Most of the rest of this discussion applies when more procedures
     are being replaced.
     The scanner 'module' interfaces with the parser, the corrector
     and the 'module' which reads and prints lines, hereafter referred
     to as 'getline'.
     procedure 'initscanner' is called by the parser to allow any
     initialization to be done
     The parser gets symbols from the scanner by calling 'gettok',
     which returns the next symbol to be parsed.  For purposes of
     possible error correction, gettok keeps track of the starting
     position of the token just sent (oldline and tokenstart;)
     The corrector looks ahead at upcoming symbols through 'peek'.
     Peek does not change the value of the 'starting postion' kept by
     gettok.  Symbols peeked at must be available for normal use by
     gettok at a later time. To this end, they may be kept in a
     buffer, or they may be physically rescanned a second time.
     The current implementation uses the rescanning. If symbols are kept
     in a buffer, some provision must be made to keep semantic information
     (such as the characters in an identifier) around until the symbol
     is actually used by the parser.  Side-effects of the scanner,
     such as symbol-table manipulations, should be avoided during peeking.
     A global boolean, 'peeking', is used to indicate this. Peeking is
     set by peek, cleared by gettok, and may also be used in 'getline'.
     The corrector effects corrections by two procedures: 'deletetokens'
     and 'inserttokens'. Deletetokens has one argument, giving the number
     of (previously scanned) symbols to be deleted. This count begins
     at the point of error, the starting point kept by gettok.
     (notice that in the current implemention, this is handled by 'getline').
     Inserttokens has an argument of record type 'StageRec', which contains
     an array of symbols to be inserted. These symbols are to be inserted
     before the first non-deleted symbol in the input. If any symbols are
     to be deleted, deletetokens will be called before inserttokens.
     It is the responsibility of deletetokens and inserttokens to
     call the appropriate routines (in getline) to display the corrections
     made.
     After a correction has been made, all the inserted symbols plus
     at least one symbol in the input will be comsumed by the parser.
     If this is not the case, an internal error has occurred, most likely
     in the corrector. procedure checkerrorok checks this situation.
     The distinction between the scanner module and the getline module is
     fairly fuzzy.  In the current implementation, the scanner depends
     on getline to reposition the scanning pointer after corrections are made.
     In order to do this, getline calls 'scan' to skip past one token.
     End of file is reporsted through the global boolean 'endfile'.  No attempt
     to read will be made while endfile is true.  Since a correction may cause
     input to be rescanned, endfile must be cleared by the correction routines.
     When the end is again reached, endfile will be set again.
================================================================*/
static void initscanner()
{
  /*---------------------------------------------------------------
    do any initialization needed
   ----------------------------------------------------------------*/
  int tokennumber;

  if (debug)
    printf("start initscanner\n");
  P_addsetr(P_expset(p.digits, 0L), '0', '9');
  P_addsetr(P_expset(p.idcharset, 0L), 'A', 'Z');
  P_addsetr(p.idcharset, 'a', 'z');
  P_addsetr(p.idcharset, '0', '9');
  P_addset(p.idcharset, '_');
  /* initialize the SingleCharacter array by looking at the reserved*/
  /*  word list that are one character long*/
  for (tokennumber = numterms; tokennumber >= 1; tokennumber--) {   /* with */
    if (p.resword[tokennumber + 2].len == 1)
      singlechar[stringchar(&p.resword[tokennumber + 2], 1) - ' '] = tokennumber;
  }
  ordzero = '0';
  savetoken = eoftoken;
  newcommand = ' ';
  P_addset(P_expset(badcharset, 0L), '!');
  P_addset(badcharset, '#');
  P_addset(badcharset, '$');
  P_addset(badcharset, '^');
  P_addset(badcharset, '\\');
  P_addset(badcharset, '{');
  P_addset(badcharset, '}');
  P_addset(badcharset, '`');
  P_addset(badcharset, '_');
  P_addset(badcharset, '@');
  reuseindex = 0;
  readaheadbuf = NULL;
  commentflag = false;
  if (debug)
    printf("end initscanner\n");
}  /* initscanner */


static void peek(sym)
SHORT *sym;
{
  /*(var sym: SymIndex); forward */
  /*----------------------------------------------------------------
    get the next token
     leave old line pointer where it is,
     move new line pointer.
     set peeking
   -----------------------------------------------------------------*/
  if (debug)
    printf("start peek\n");
  peeking = true;
  scan(sym, &tokenlineno, &linebuf);
  if (debug)
    printf("end peek\n");
}  /* peek */


static void gettok(tok, tokenlineno)
SHORT *tok;
int *tokenlineno;
{
  /*-----------------------------------------------------------------
    return the next token:
             if buffer empty then
                  read new token and return it
                  leaves the token read on the buffer
             else pop one off of buffer
    positions the old line buffer same as current buffer
   -----------------------------------------------------------------*/
  /* rabrec *ptr; */
  stryng tempstr, tempstr2;
  int i, FORLIM;

  if (debug)
    printf("start gettok\n");
  peeking = false;
  if (readaheadbuf != NULL) {
    *tok = readaheadbuf->token;
    if (cortrace) {
      printf(" from buffer:");
      printsym(*tok);
      putchar('\n');
    }
    if (*tok == idtoken) {
      string10(&inputtoken, "<NAME>    ");
      stripspaces(&inputtoken);
    }
    /* ptr = readaheadbuf; */
    readaheadbuf = readaheadbuf->next;
    /* Free(ptr); */
  } else {
    scan(tok, tokenlineno, &linebuf);
    if (cortrace) {
      printf(" from scan:(%d) ", linebuf->lineno);
      printsym(*tok);
      putchar('\n');
    }
    if (*tok == incltoken) {
      linenumber = newlinenum;
      curinputfile = newfname;
      if (newlinenum == 0)
        string20(&tempstr, "%---- entering file ");
      else
        string20(&tempstr, "%---- resuming file ");
      insertstring(&tempstr, &curinputfile, 21);
      string10(&tempstr2, "----      ");
      stripspaces(&tempstr2);
      if (tempstr.len < maxstringchars)
        insertstring(&tempstr, &tempstr2, tempstr.len + 1);
      FORLIM = tempstr.len;
      for (i = 1; i <= FORLIM; i++)
        linebuf->buf[i] = stringchar(&tempstr, i);
      linebuf->length = tempstr.len + 1;
      linebuf->buf[linebuf->length] = ' ';
      linebuf->pointer = linebuf->length + 1;
      /* We have make the line longer and must place the pointer at
         the end of the line  */
      linebuf->lineno = 0;
    }
    oldline = linebuf;
  }
  oldtoken = *tok;
  if (toconsume >= 0)
    toconsume--;
  if (debug)
    printf("end gettok\n");
}  /* gettok */


static void deletetokens(pighowmany)
int pighowmany;
{
  /* (pighowmany: integer);forward*/
  /*----------------------------------------------------------
    remove pighowmany tokens from buffer,
    and update display image to show tokens deleted
    ----------------------------------------------------------*/
  if (debug)
    printf("start deletokens\n");
  endfile = false;
  toconsume = 1;
  displaydeletions(pighowmany);
  if (debug)
    printf("end deletetokens\n");
}  /* deletetokens */


static void inserttokens(fix)
stagerec fix;
{
  /* (fix: StageRec);forward*/
  /*---------------------------------------------------------------
    push tokens listed in fix into buffer.
   also displays the print image of the token
   ----------------------------------------------------------------*/
  rabrec *ptr, *qtr;
  int iindex;

  if (debug)
    printf("start inserttokens\n");
  toconsume = fix.length + 1;
  if (fix.length >= 1) {
    ptr = (rabrec *)Malloc(sizeof(rabrec));
    ptr->token = fix.string[1];
    ptr->next = readaheadbuf;
    displayinsertion(ptr->token);
    readaheadbuf = ptr;
    qtr = ptr;
    for (iindex = 2; iindex <= fix.length; iindex++) {
      ptr = (rabrec *)Malloc(sizeof(rabrec));
      ptr->token = fix.string[iindex];
      ptr->next = qtr->next;
      qtr->next = ptr;
      qtr = ptr;
      displayinsertion(ptr->token);
    }
  }  /* if */
  endfile = false;
  if (debug)
    printf("end inserttiken\n");
}  /* inserttoken */


static void checkerrorok()
{
  /*--------------------------------------------------------------
    check that an error is 'acceptable' in this situation.
    that is, all the corrections from the last error have been consumed.
   ---------------------------------------------------------------*/
  if (debug)
    printf("start checkerrorok\n");
  if (toconsume >= 0) {
    printf("******** CORRECTOR UNABLE TO PROCEED ****************\n");
    printf("*** parse error in inserted symbols ****\n");
    printf("****** %4d symbols left       *********\n", toconsume);
    myabort();
  }
  if (readaheadbuf != NULL) {
    printf("******** CORRECTOR UNABLE TO PROCEED ****************\n");
    printf("*** parse error in inserted symbols ****\n");
    myabort();
  }
  if (debug)
    printf("end checkerrorok\n");
}  /* checkerrorok */


static void readtables(directoryname)
stryng directoryname;
{
  /*------------------------------------------------------------
    read in the various tables.
   -------------------------------------------------------------*/
  SHORT sym;
  int termsym, paction;
  ptabrec *ptr;
  int prod, i, j, len, epcount;
  boolean successfulopen;
  stryng ptablename, ptablesuffix;
  int oneletter;   /* added by jyu to read the ptableout by chars */
  int FORLIM;
  prodrec *WITH;
  int FORLIM1;
  SHORT FORLIM2;
  stringrec *WITH1;

  if (debug)
    printf("start readtables\n");
  string10(&ptablesuffix, "/ptabl.bin");
  stripspaces(&ptablesuffix);
  ptablename = directoryname;
  if (ptablename.len < maxstringchars)
    insertstring(&ptablename, &ptablesuffix, ptablename.len + 1);
  successfulopen = openintread(&ptableout, &ptablename);
  /*    reset(ptableout);    sks*/
  if (!successfulopen) {
    printf("Cannot find parsing tables in ");
    writestring(stdout, &ptablename);
    printf(".\n");
    myabort();
  }
  fread(&numterms, sizeof(int), 1, ptableout);
  fread(&numsymbols, sizeof(int), 1, ptableout);
  fread(&numprods, sizeof(int), 1, ptableout);
  fread(&stringptr, sizeof(int), 1, ptableout);
  fread(&oneletter, sizeof(int), 1, ptableout);
  /* need to readln, because a newline
                                                                      might be considered a character - jyu*/

  errortables = (oneletter == 'T');

  if (numsymbols > maxsym) {
    printf(" maximum is %12ld\n", (long)maxsym);
    myabort();
  }
  if (numterms > maxterm) {
    printf(" number of terminals is too big: %d\n", numterms);
    myabort();
  }
  if (numprods > maxprod) {
    printf(" number of productions is too big: %d\n", numprods);
    myabort();
  }
  if (stringptr > maxstring) {
    printf(" symbol string too big: %d\n", stringptr);
    myabort();
  }
  FORLIM = numprods;
  for (prod = 1; prod <= FORLIM; prod++) {
    WITH = &productions[prod];
    fread(&len, sizeof(int), 1, ptableout);
    WITH->length = len;
    WITH->start = prodspceptr + 1;
    FORLIM1 = WITH->length;
    for (i = 1; i <= FORLIM1; i++) {
      fread(&j, sizeof(int), 1, ptableout);
      prodspceptr++;
      prodspace[prodspceptr] = j;
    }
  }
  initptab();
  fread(&termsym, sizeof(int), 1, ptableout);
  fread(&paction, sizeof(int), 1, ptableout);
  FORLIM2 = numsymbols;
  for (sym = numterms + 1; sym <= FORLIM2; sym++) {
    if (termsym != 0 || paction != sym) {
      printf(" error in reading parse table%12d%12d%12d\n",
             sym, termsym, paction);
      myabort();
    }
    fread(&termsym, sizeof(int), 1, ptableout);
    fread(&paction, sizeof(int), 1, ptableout);
    while (termsym != 0) {
      ptr = (ptabrec *)Malloc(sizeof(ptabrec));
      ptr->term = termsym;
      ptr->pact = paction;
      ptr->next = table[sym + 2];
      table[sym + 2] = ptr;
      fread(&termsym, sizeof(int), 1, ptableout);
      fread(&paction, sizeof(int), 1, ptableout);
    }
  }
  fread(&epcount, sizeof(int), 1, ptableout);
  FORLIM = numprods;
  for (prod = 1; prod <= FORLIM; prod++)
    epsprod[prod] = false;
  for (i = 1; i <= epcount; i++) {
    fread(&prod, sizeof(int), 1, ptableout);
    epsprod[prod] = true;
  }
  FORLIM2 = numsymbols + 2;
  for (sym = 3; sym <= FORLIM2; sym++) {
    WITH1 = &symkluge[sym];
    fread(&i, sizeof(int), 1, ptableout);
    fread(&j, sizeof(int), 1, ptableout);
    WITH1->start = i;
    WITH1->length = j;
  }
  FORLIM = stringptr;
  for (i = 1; i <= FORLIM; i++) {
    fread(&oneletter, sizeof(int), 1, ptableout);
    stringspace[i] = oneletter;
  }
  FORLIM = numsymbols + 2;
  for (i = 3; i <= FORLIM; i++) {
    FORLIM1 = symkluge[i].start + symkluge[i].length;
    for (j = symkluge[i].start; j < FORLIM1; j++)
      concatchar(&p.resword[i], stringspace[j]);
  }
  if (debug)
    printf("end readtables\n");
}  /* readtables */


static void push(prod)
SHORT prod;
{
  /*----------------------------------------------------------
    push action onto parse stack
   -----------------------------------------------------------*/
  int i;
  prodrec *WITH;
  int FORLIM;

  if (debug)
    printf("start push, prod = %3d\n", prod);
  WITH = &productions[prod];
  if (stackptr + WITH->length > maxstack) {
    printf(" parse stack overflow\n");
    myabort();
  } else {
    FORLIM = WITH->start + WITH->length;
    for (i = WITH->start; i < FORLIM; i++) {
      stackptr++;
      parsestack[stackptr] = prodspace[i];
      if (debug)
        printf("pushing %4d\n", prodspace[i]);
    }
  }
  if (debug)
    printf("end push\n");
}  /* push */


int tos()
{
  /*--------------------------------------------------------------
    return the value at the top of the parse stack
   ---------------------------------------------------------------*/
  return (parsestack[stackptr]);
}  /* tos */


static void pop()
{
  /*------------------------------------------------------------
    pop pighowmany items from the stack.
   -------------------------------------------------------------*/
  if (debug)
    printf("start pop\n");
  if (stackptr < 1) {
    printf(" parse stack underflow\n");
    myabort();
  } else
    stackptr--;
  if (debug)
    printf("end pop\n");
}  /* pop */


static void trace()
{
  /*--------------------------------------------------------------
    print out a parse trace
   ---------------------------------------------------------------*/
  SHORT i, FORLIM;

  if (debug)
    printf("start trace\n");
  printf(" Parse stack:");
  column = 10;
  FORLIM = stackptr;
  for (i = 1; i <= FORLIM; i++) {
    column++;
    putchar(' ');
    printsym(parsestack[i]);
  }
  putchar('\n');
  if (debug)
    printf("end trace\n");
}  /* trace */


boolean checkepsilonok(term)
char term;
{
  /*--------------------------------------------------------------
    check whether an epsilon production would be OK
  a la Fischer Tai Milton.
  ---------------------------------------------------------------*/
  boolean Result;
  SHORT ptr;
  int sym, pact;
  boolean nomore;

  if (debug)
    printf("start checkepsilonok\n");
  Result = true;
  ptr = stackptr;
  do {
    sym = parsestack[ptr];
    if (sym < 0) {
      ptr--;
      nomore = (ptr == 0);
    } else if (sym <= numterms) {
      if (sym == term)
        nomore = true;
      else {
        nomore = true;
        Result = false;
      }
    } else {
      pact = findlltab(sym, term);
      if (pact == 0) {
        nomore = true;
        Result = false;
      } else if (epsprod[pact]) {
        ptr--;
        nomore = (ptr == 0);
      } else
        nomore = true;
    }
  } while (!nomore);
  if (debug)
    printf("end checkepsilonok\n");
  return Result;
}  /* checkepsilonok */


static void parseerror(token, directoryname)
SHORT token;
stryng *directoryname;
{
  /*---------------------------------------------------------------
    Handle the syntax error.
    call LLcorrector to find the fix
   ----------------------------------------------------------------*/
  /*var  pos: integer;*/
  if (debug)
    printf("start parseerror\n");
  /*old version: puts a marker under each error*/
  /*
  if LISTING then begin
  write(blank:5);
  for pos := 1 to tokenstart do write('-');
  writeln('^');
  write(' ***** error line ');
  write(linebuf^.lineno:3);
  write(' on "');
  if oldtoken=numterms then
       write('end-of-file')
  else printstring(inputtoken);
  write('"');
  writeln;
  end; */
  checkerrorok();
  if (errortables) {
    if (cortrace) {
      printf("  parse stack :\n");
      trace();
    }

    llcorrector(&token, directoryname);

  } else {
     writestring(stdout,&infile[0]->parvalue);
     printf(":%d: ERROR - ",linenumber);
    printf(" ** %d ** syntax error on \"", linenumber);
    printstring(inputtoken);
    printf("\"\n");
    printf(" no correction tables \n");
    myabort();
  }
  if (debug)
    printf("end parseerror\n");
}  /*parseerror*/


static void printstats()
{
  /*---------------------------------------------------------------
    print assorted statistics about whats going on
  ----------------------------------------------------------------*/
  printf(" %4d lines in program\n", linenumber - 1);
  printf(" %4d errors ( calls to corrector)\n", errorcount);
  printf(" %4d tokens inserted; %4d tokens deleted.\n",
         tokinserted, tokdeleted);
  printf(" %4d semantic errors\n", semerrcnt);
  if (listing) {
    fprintf(listfile, " %4d lines in program\n", linenumber - 1);
    fprintf(listfile, " %4d errors ( calls to corrector)\n", errorcount);
    fprintf(listfile, " %4d tokens inserted; %4d tokens deleted.\n",
            tokinserted, tokdeleted);
    fprintf(listfile, " %4d semantic errors\n", semerrcnt);
  }
  if (!gorydetail) {
    return;
  }  /* if gory detail */
  if (errorcount != 0)
    printf(" %4d deletions were considered, %3.2f per correction.\n",
           numdeltried, (double)numdeltried / errorcount);
  putchar(' ');
}  /* PrintStats */


static void init()
{
  /*-=-----------------------------------------------------------
    initialize anything and everything except scanner, need to read tables first
   --------------------------------------------------------------*/
  inputbuffer *WITH;

  if (debug)
    printf("start init\n");
  stringptr = 0;
  errorcount = 0;
  numdeltried = 0;
  linenumber = 0;
  tokinserted = 0;
  tokdeleted = 0;
  curerrsym = 0;

  linebuf = (inputbuffer *)Malloc(sizeof(inputbuffer));

  WITH = linebuf;
  WITH->length = 0;
  WITH->pointer = 1;
  WITH->lineno = 0;
  WITH->modified = false;
  WITH->underline = NULL;
  WITH->next = NULL;
  oldline = linebuf;
  if (debug)
    printf("end init\n");
}  /* init */


static void parse(directoryname)
stryng *directoryname;
{
  /* ---------------------------------------------------------
   parse
  -----------------------------------------------------------*/
  int paction, sym;
  SHORT token;
  boolean more;

  debug = false;
  cortrace = false;
  debugcg = false;
  /* init parser and scanner, read in tables */
  init();
  readtables(*directoryname);
  readerrtables(directoryname);
  initscanner();
  printf("version %s%s\n", version, compiled);
  /* begin parsing */
  stackptr = 0;
  push(numprods);
  if (tracing)
    trace();
  more = true;
  if (debugparam->parvalue.len > 0)
    more = debugger(-1, -1);
  gettok(&token, &tokenlineno);
  while (more) {
    if (commentflag) {
      commentflag = false;
      gettok(&token, &tokenlineno);
      continue;
    }  /* then */
    if (debug)
      printf("comment flag not set\n");
    sym = tos();
    if (sym < 0) {
      more = announceaction(-sym, token, linenumber, tokenstart, inputtoken);
      pop();
      continue;
    }
    if (sym <= numterms) {
      if (sym == token) {
        pop();
        if (token == eoftoken)
          more = false;
        else
          gettok(&token, &tokenlineno);
      } else {
        if (debug)
          printf("parse error 1, sym,token = %3d%3d\n", sym, token);
        parseerror(token, directoryname);
        gettok(&token, &tokenlineno);
      }
    } else {  /*B*/
      paction = findlltab(sym, token);
      if (paction == 0) {
        if (debug)
          printf("parse error 2, sym,token = %3d%3d\n", sym, token);
        parseerror(token, directoryname);
        gettok(&token, &tokenlineno);
      } else if (iedp && epsprod[paction]) {
        if (checkepsilonok(token)) {
          pop();
          push(paction);
        } else {
          if (debug)
            printf("parse error 3\n");
          parseerror(token, directoryname);
          gettok(&token, &tokenlineno);
        }
      } else {
        pop();
        push(paction);
      }
    }  /*B*/
    if (tracing)
      trace();
  }  /* while */
  flushlines();
  if (debugparam->parvalue.len > 0)
    more = debugger(-1, -1);
  printf("\n accepted\n");
  if (listing)
    fprintf(listfile, "\n accepted\n");
  printstats();

  /*A*/
  /*A*/
}  /* parse */


static void readline_(linenum, linebuf, infile, LINK)
int linenum;
inputbuffer *linebuf;
FILE *infile;
struct LOC_pass1 *LINK;
{
  Char ch;
  int length;

  length = 0;
  do {
    length++;
    ch = getc(infile);
    if (ch == '\n')
      ch = ' ';
    linebuf->buf[length] = ch;
    if (length == maxlinelength - 1) {
      printf("***%d*** line too long, %d characters is maximum\n", linenum, maxlinelength);
      myabort();
    }
  } while (!P_eoln(infile));
  fscanf(infile, "%*[^\n]");
  getc(infile);
  linebuf->length = length;
}

static boolean recursiveincl(fname, LINK)
stryng fname;
struct LOC_pass1 *LINK;
{
  namelistrec *listptr;
  boolean found;
  stryng lowername;

  listptr = includelist;
  found = false;
  stringlowercase(&fname);
  while (listptr != NULL) {
    lowername = listptr->name;
    stringlowercase(&lowername);
    if (equalstrings(&lowername, &fname)) {
      found = true;
      listptr = NULL;
    } else
      listptr = listptr->next;
  }  /*while*/
  return found;
}

static void pushinclstack(fname, linenum, LINK)
stryng fname;
int linenum;
struct LOC_pass1 *LINK;
{
  namelistrec *listptr;

  newnamelist(&listptr);
  listptr->name = fname;
  listptr->linenum = linenum;
  if (includelist == NULL)
    includelist = listptr;
  else {
    listptr->next = includelist;
    includelist = listptr;
  }
}

static void popinclstack(LINK)
struct LOC_pass1 *LINK;
{
  includelist = includelist->next;
}

static void dumpline(linebuf, LINK)
inputbuffer *linebuf;
struct LOC_pass1 *LINK;
{
  int pointer;

  pointer = 1;
  while (pointer <= linebuf->length) {
    putc(linebuf->buf[pointer], LINK->outfile);
    pointer++;
  }
  putc('\n', LINK->outfile);
}

static char *EnTrY[MAX_NAMES];
static char *FoRtRaN[MAX_NAMES];
static char *CcC[MAX_NAMES];

int ENum = 0;
int FNum = 0;
int CNum = 0;

static char *CANN_StringCopy(length,buf)
int   length;
char *buf;
{
  register char *s;
  register char *r;
  register int   i;

  r = Malloc( length+1 * sizeof(char) );
  s = r;

  for ( i = 0; i < length; i++ )
    s[i] = buf[i];

  s[length] = '\0';
  return( r );
}

static int CANN_PreparePragmaName( s )
char *s;
{
  register int   e;
  register char *p;

  for ( e = 0, p = s; *p != '\0'; p++, e++ ) {
    if ( *p == '=' )
      return( e );

    if ( (*p >= 'a') && (*p <= 'z') )
      *p = (*p - 'a') + 'A';
    }

  return( -1 );
}

static int CANN_IsEntryPragma(b)
char *b;
{
  register int e;

  e = CANN_PreparePragmaName( b );

  if ( *b == 'E' )
    if ( *(b+1) == 'N' )
      if ( *(b+2) == 'T' )
        if ( *(b+3) == 'R' )
          if ( *(b+4) == 'Y' )
            if ( *(b+5) == '=' )
              return( e );

  return( -1 );
}

static int CANN_IsFortranPragma(b)
char *b;
{
  register int e;

  e = CANN_PreparePragmaName( b );

  if ( *b == 'F' )
    if ( *(b+1) == 'O' )
      if ( *(b+2) == 'R' )
        if ( *(b+3) == 'T' )
          if ( *(b+4) == 'R' )
            if ( *(b+5) == 'A' )
              if ( *(b+6) == 'N' )
                if ( *(b+7) == '=' )
                  return( e );

  return( -1 );
}

static int CANN_IsCPragma(b)
char *b;
{
  register int e;

  e = CANN_PreparePragmaName( b );

  if ( *b == 'C' )
    if ( *(b+1) == '=' )
      return( e );

  return( -1 );
}

static void CANN_ProcessPragmaFields(e,b,dbase,num)
int   e;
char *b;
char **dbase;
int  *num;
{
  register char *r;
  register char *p;
  register char *f;

  p = r = &(b[e+1]);

  while ( *p != '\0' ) {
    if ( *p == ',' )
      *p = '\0';

    p++;
    }

  f = p+1;
  p = r;

  while ( p != f ) {
    if ( *num >= MAX_NAMES ) {
      fprintf( stderr, "CANN_ProcessPragmaFields: dbase overflow!\n" );
      CANN_exit(1);
      }

    *dbase = p;
    dbase++;
    (*num)++;

    while ( *p != '\0' ) 
      p++;

    p++;
    }
}

static int CANN_DissectSpecialPragmas(pointer,length,buf)
int   pointer;
int   length;
char *buf;
{
  register char *b;
  register char *s;
  register int   e;

  b = &buf[pointer];
  s = CANN_StringCopy(length-2,b);

  if ( (e = CANN_IsEntryPragma( s )) > 0 )
    CANN_ProcessPragmaFields( e, s, &EnTrY[ENum], &ENum );
  else if ( (e = CANN_IsFortranPragma( s )) > 0 )
    CANN_ProcessPragmaFields( e, s, &FoRtRaN[FNum], &FNum );
  else if ( (e = CANN_IsCPragma( s )) > 0 )
    CANN_ProcessPragmaFields( e, s, &CcC[CNum], &CNum );
  else {
    /* free( s ); */ /* PROFILE */
    return( 0 );
    }

  return( 1 );
}

char *CANN_StripWhites( s )
char *s;
{
  register char *b;

  while ( *s == ' ' || *s == '\t' ) s++;

  if ( *s == '\0' )
    return(NULL);

  b = s;

  for ( s++; *s != ' ' && *s != '\t' && *s != '\0'; s++ ) /* NOTHING */ ;

  *s = '\0';

  return( b );
}

static void CANN_DumpSpecialPragmas(fd)
FILE *fd;
{
  register int i;
  register char *s;

  for ( i = 0; i < ENum; i++ )
    if ( EnTrY[i][0] != '\0' ) {
      if ( (s = CANN_StripWhites(EnTrY[i])) == NULL ) 
        continue;

      fprintf( fd, "CE$%s\n", s );
      }

  for ( i = 0; i < FNum; i++ )
    if ( FoRtRaN[i][0] != '\0' ) {
      if ( (s = CANN_StripWhites(FoRtRaN[i])) == NULL ) 
        continue;

      fprintf( fd, "CF$%s\n", s );
      }

  for ( i = 0; i < CNum; i++ )
    if ( CcC[i][0] != '\0' ) {
      if ( (s = CANN_StripWhites(CcC[i])) == NULL ) 
        continue;

      fprintf( fd, "CC$%s\n", s );
      }
}

static void error(LINK)
struct LOC_dissectpragma *LINK;
{
  printf("*** malformed pragma in file ");
  writestring(stdout, &LINK->LINK->fname);
  printf(", line %d ***\n", LINK->linenum);
  *LINK->pname = pother;
  myabort();
}

static void dissectpragma(linebuf, linenum_, pragmastart, pname_, pragmaparam, LINK)
inputbuffer *linebuf;
int linenum_;
int pragmastart;
pragmaname *pname_;
stryng *pragmaparam;
struct LOC_pass1 *LINK;
{
  struct LOC_dissectpragma V;
  int namestart, nameend, paramstart, paramend, length, pointer;
  stryng name, includestr;
  long whitespace[9];

  V.LINK = LINK;
  V.linenum = linenum_;
  V.pname = pname_;
  length = linebuf->length;
  pointer = pragmastart;

  if ( CANN_DissectSpecialPragmas(pointer,length,linebuf->buf) ) {
    *V.pname = pother;
    return;
    }

  string10(&includestr, "include   ");
  stripspaces(&includestr);
  P_addset(P_expset(whitespace, 0L), blankord);
  P_addset(whitespace, tabord);
  while ((pointer <= length) & P_inset(linebuf->buf[pointer], whitespace))
    pointer++;
  if (pointer > length) {
    error(&V);
    return;
  }
  namestart = pointer;
  while (pointer <= length && linebuf->buf[pointer] != '(')
    pointer++;
  if (pointer > length) {
    error(&V);
    return;
  }
  nameend = pointer - 1;
  paramstart = pointer + 1;
  while (pointer <= length && linebuf->buf[pointer] != ')')
    pointer++;
  if (pointer > length) {
    error(&V);
    return;
  }
  paramend = pointer - 1;
  mymemcpy(name.str, blankstring, sizeof(stryngar));
  name.len = 0;
  for (pointer = namestart; pointer <= nameend; pointer++)
    concatchar(&name, linebuf->buf[pointer]);
  stripspaces(&name);
  stringlowercase(&name);
  if (!equalstrings(&name, &includestr)) {
    *V.pname = pother;
    return;
  }  /*then*/

/* CANN 2/92 */
fprintf( stderr, "\nERROR - %%$include IS OBSOLETE, USE THE C PREPROCESSOR\n\n" );
myabort();
/* CANN */

  *V.pname = pinclude;
  mymemcpy(pragmaparam->str, blankstring, sizeof(stryngar));
  pragmaparam->len = 0;
  for (pointer = paramstart; pointer <= paramend; pointer++)
    concatchar(pragmaparam, linebuf->buf[pointer]);
  stripspaces(pragmaparam);
  while (stringchar(pragmaparam, 1) == ' ')
    deletestring(pragmaparam, 1, 1);
  if ((stringchar(pragmaparam, 1) != '"') |
      (stringchar(pragmaparam, pragmaparam->len) != '"')) {
    error(&V);
    *V.pname = pother;
  }  /*then*/
  else {
    deletestring(pragmaparam, 1, 1);
    deletestring(pragmaparam, pragmaparam->len, pragmaparam->len);
  }  /*else*/

  /*else*/
  /*else*/
  /*else*/
}  /*DissectPragma*/


boolean pass1(txtp,fname_p, outfile_)
stryng *txtp;
stryng *fname_p;
FILE *outfile_;
{
  /* This pass will expand the  pragmas.  An internal pragma
     (UNINCLUDE) is used to pass infomation about the actual name of
     the input file and the line number within that file to the rest of
     the passes of the compiler.*/
  stryng txt,fname_;            /* PJM to fix Vax CC problem */
  struct LOC_pass1 V;
  boolean Result;
  int linenum;
  FILE *infile;
  boolean error;
  inputbuffer *linebuf;
  boolean pragma;
  pragmaname pname;
  stryng pragmaparam, inclstring;
  boolean blankline;
  int pointer, len;
  boolean endoffile /*, temperror*/;

  txt = *txtp;
  fname_ = *fname_p;

  V.fname = txt;
  V.outfile = outfile_;
  infile = NULL;
  if (!recursiveincl(fname_, &V)) {
    linenum = 0;
    error = false;
    string10(&inclstring, "include   ");
    stripspaces(&inclstring);

    linebuf = (inputbuffer *)Malloc(sizeof(inputbuffer));

    linebuf->underline = NULL;
    linebuf->next = NULL;
    if (!openread(&infile, &fname_)) {
      if (includelist == NULL) {
        concatchar(&V.fname, '.');
        concatchar(&V.fname, 's');
        concatchar(&V.fname, 'i');
        concatchar(&V.fname, 's');
        if (!openread(&infile, &fname_)) {
          error = true;
          printf("***ERROR File ");
          writestring(stdout, &fname_);
          printf("  not found\n");
        }
      } else {
        error = true;
        printf("***ERROR in pass1, File ");
        writestring(stdout, &fname_);
        printf("  not found\n");
      }
    }
    if (!error) {
      fprintf(V.outfile, "%%$UNINCLUDE(");
      writestring(V.outfile, &V.fname);
      fprintf(V.outfile, ",%d)\n", linenum);
      endoffile = false;
      while (!endoffile) {
        blankline = true;
        while (blankline) {
          if (P_eof(infile)) {
            endoffile = true;
            blankline = false;
            break;
          }
          if (!P_eoln(infile)) {
            blankline = false;
            break;
          }
          linenum++;
          fscanf(infile, "%*[^\n]");
          getc(infile);
          putc('\n', V.outfile);
        }  /*while*/
        if (endoffile) {
          break;
        }  /*then*/
        readline_(linenum, linebuf, infile, &V);
        linenum++;
        pointer = 1;
        len = linebuf->length;
        while (pointer <= len && linebuf->buf[pointer] != '%')
          pointer++;
        pragma = true;
        if (linebuf->buf[pointer] != '%' || pointer + 1 >= len) {
          dumpline(linebuf, &V);
          continue;
        }  /*then*/
        pointer++;
        if (linebuf->buf[pointer] == '$')
          dissectpragma(linebuf, linenum, pointer + 1, &pname, &pragmaparam,
                        &V);
        else {
          pragma = false;
          dumpline(linebuf, &V);
        }
        if (!pragma) {
          continue;
        }  /*then*/
        switch (pname) {

        case pinclude:
          linebuf->length = pointer - 2;
          if (linebuf->length > 0)
            dumpline(linebuf, &V);
          pushinclstack(V.fname, linenum, &V);
          /* temperror = */ (void)pass1(&pragmaparam,&pragmaparam, V.outfile);
          popinclstack(&V);
          fprintf(V.outfile, "%%$UNINCLUDE(");
          writestring(V.outfile, &V.fname);
          fprintf(V.outfile, ",%d)\n", linenum);
          break;

        case pother:
          dumpline(linebuf, &V);
          break;
        }/*case*/
      }  /*while*/
    }  /*then*/
  }  /*then*/
  else {
    printf("*** recursive include pragma in file ");
    writestring(stdout, &includelist->name);
    printf(", line %12d ***\n", includelist->linenum);
  }  /*else*/
  Result = error;
  if (infile != NULL)
    fclose(infile);
  return Result;

  /*else*/
}  /*pass1*/


static void splitaelement(n)
node *n;
{
  /* - N is an AElement node with more than one index inputs on ports 2, 3,...
     - A new AElement node is constructed and placed in front of this node.
     - The first two inputs are moved to this node as its inputs.
     - An output is constructed from the new node to N
     - The ports of N are shifted left by 1
   */
  node *newn;
  port *arraye, *indexe /*, *newe*/;
  stentry *etype, *edgebasetype;
  stryng ename;

  newn = createsimplenode(ifnaelement);
  insertnode(n->ndparent, toprevnode(n), newn);
  arraye = getinputedge(n, 1);
  indexe = getinputedge(n, 2);
  changeedgedest(arraye, newn, 1);
  changeedgedest(indexe, newn, 2);
  shiftinputports(n, 1, -1);
  etype = arraye->pttype;
  if (etype->stsort == iftarray)
    edgebasetype = etype->UU.stbasetype;
  else
    edgebasetype = etype->UU.stbasetype;
  mymemcpy(ename.str, blankstring, sizeof(stryngar));
  ename.len = 0;
  /* newe = */ (void)insertedge(newn, 1, n, 1, edgebasetype, ename);
}  /* SplitAElement */

static void convertareplacen(n)
node *n;
{
  /* - N is an AReplaceN node with the number of levels on port 2
     - Iteratively convert this node to a sequence of three nodes by:
       (1) adding an AElement node above N
       (2) converting N to an AReplaceN node of one lower level
       (3) adding an AReplace Node below N
     - Change the Remaining AReplaceN node to its equivalent AReplace node.
   */
  node *newaelem, *parent, *aelem, *arepl, *pn;
  port *levele, *arraye, /* *newe, */ *indexe, *e, *tmpe;
  stryng litvalue, levelstring, ename;
  int startpos, level, pp;
  stentry *arraytype, *indextype, *arraybasetype;

  parent = n->ndparent;
  aelem = toprevnode(n);
  levele = getinputedge(n, 2);
  /* NOTE:  LevelE MUST be a Literal edge */
  levelstring = levele->UU.ptlitvalue;
  startpos = 1;
  level = stringnumber(&levelstring, &startpos, 10);
  while (level > 1) {
    newaelem = createsimplenode(ifnaelement);
    insertnode(parent, aelem, newaelem);
    aelem = newaelem;
    arepl = createsimplenode(ifnareplace);
    insertnode(parent, n, arepl);
    /* Construct input edges for new AReplace node */
    arraye = getinputedge(n, 1);
    arraytype = arraye->pttype;
    ename = arraye->ptname;
    if (arraye->ptsort == ptlit) {
      litvalue = arraye->UU.ptlitvalue;
      /* newe = */ (void)insertliteral(arepl, 1, arraytype, litvalue, ename);
    } else {
      pn = producernodeofedge(arraye);
      pp = producerportnumber(arraye);
      /* newe = */ (void)insertedge(pn, pp, arepl, 1, arraytype, ename);
    }
    indexe = getinputedge(n, 3);
    indextype = indexe->pttype;
    ename = indexe->ptname;
    if (indexe->ptsort == ptlit) {
      litvalue = indexe->UU.ptlitvalue;
      /* newe = */ (void)insertliteral(arepl, 2, indextype, litvalue, ename);
    } else {
      pn = producernodeofedge(indexe);
      pp = producerportnumber(indexe);
      /* newe = */ (void)insertedge(pn, pp, arepl, 2, indextype, ename);
    }
    /* Move Output Edges from node N to ARepl */
    e = n->ndolist;
    while (e != NULL) {
      tmpe = e;
      e = e->UU.U1.ptfrnext;
      tmpe->pttype = arraytype;
      changeedgesrc(tmpe, arepl, 1);
    }
    /* Change Input and Output edges of node N */
    changeedgedest(arraye, aelem, 1);
    changeedgedest(indexe, aelem, 2);
    shiftinputports(n, 3, -1);
    arraybasetype = arraytype->UU.stbasetype;
    mymemcpy(ename.str, blankstring, sizeof(stryngar));
    ename.len = 0;
    /* newe = */ (void)insertedge(aelem, 1, n, 1, arraybasetype, ename);
    /* newe = */ (void)insertedge(n, 1, arepl, 3, arraybasetype, ename);
    level--;
  }
  /* convert to AReplace node */
  removeedge(&levele);
  shiftinputports(n, 2, -1);
  n->ndcode = ifnareplace;
}  /* ConvertAReplaceN */

static void removeunusedports(seln)
node *seln;
{
  /* - SelN is a select node with K inputs and no input gaps.
     - This routine removed any input edges not used
       by any of the subgraphs of SelN.
     - Port Compaction is also done.
   */
  int lastgraph, grnum, count, eport;
  boolean used;
  port *e;
  int FORLIM;

  lastgraph = numbofsubgraphs(seln) - 1;
  eport = 1;
  FORLIM = largestinputportnumber(seln);
  for (count = 1; count <= FORLIM; count++) {
    e = getinputedge(seln, eport);
    used = false;
    for (grnum = 0; grnum <= lastgraph; grnum++) {
      if (getoutputedge(tochildgraph(seln, grnum), eport) != NULL)
        used = true;
    }
    if (!used) {
      removeedge(&e);
      shiftinputports(seln, eport, -1);
      for (grnum = 0; grnum <= lastgraph; grnum++)
        shiftoutputports(tochildgraph(seln, grnum), eport, -1);
    } else
      eport++;
  }
}  /* RemoveUnusedPorts */

static node *createselectorgraph(n)
node *n;
{
  node *g;
  /* port *e;*/
  stryng ename;

  g = newnodealloc(ndgraph);
  univnodecnt++;
  g->ndid = univnodecnt;
  g->ndparent = n;
  g->ndcode = ifngraph;
  mymemcpy(ename.str, blankstring, sizeof(stryngar));
  ename.len = 0;
  /* e = */ (void)insertedge(g, 1, g, 1, getbasictype(ifbinteger), ename);
  return g;
}  /* CreateSelectorGraph */

static void convertiftoselect(n)
node *n;
{
  /* Preconditions
        - N is an IfThenElse node with two subgraphs
        - Subgraph 0 is the True branch
        - Subgraph 1 is the False branch
    PostConditions
        - N is changed to a Select Node
        - An INT node has been added to change the predicate into an integer
        - A selector graph has been constructed with a direct edge.
        - The False branch becomes Subgraph 1
        - The True branch becomes Subgraph 2
  */
  port *pe /*, *e*/;
  stentry *ity, *pt;
  node *pn, *intn;
  int pp;
  stryng litvalue, pname;
  graph *gr;

  /* Insert INT node */
  intn = createsimplenode(ifnint);
  insertnode(n->ndparent, toprevnode(n), intn);
  /* Construct input edge to INT node */
  pe = getinputedge(n, 1);
  pname = pe->ptname;
  pt = pe->pttype;
  if (pe->ptsort == ptlit) {
    litvalue = pe->UU.ptlitvalue;
    /* e = */ (void)insertliteral(intn, 1, pt, litvalue, pname);
  } else {
    pn = producernodeofedge(pe);
    pp = producerportnumber(pe);
    /* e = */ (void)insertedge(pn, pp, intn, 1, pt, pname);
  }
  /* Shift input edges RIGHT one port */
  shiftinputports(n, 1, 1);
  shiftoutputports(tochildgraph(n, 0), 1, 1);
  shiftoutputports(tochildgraph(n, 1), 1, 1);
  /* Add output edge to INT node */
  ity = getbasictype(ifbinteger);
  mymemcpy(pname.str, blankstring, sizeof(stryngar));
  pname.len = 0;
  /* e = */ (void)insertedge(intn, 1, n, 1, ity, pname);
  /* Change N to a SELECT node */
  n->ndcode = ifnselect;
  /* Swap True and False graphs */
  gr = n->UU.U2.ndsubsid;
  n->UU.U2.ndsubsid = gr->grnext;
  gr->grnext = NULL;
  n->UU.U2.ndsubsid->grnext = gr;
  /* Insert Selector Graph */
  gr = newgraphptr();
  gr->grnode = createselectorgraph(n);
  gr->grnext = n->UU.U2.ndsubsid;
  n->UU.U2.ndsubsid = gr;
  removeunusedports(n);
}  /* ConvertIfToSelect */

static void convertelseiftoselect(n)
node *n;
{
  /* In this case, N is an IfThenElse node with more than two subgraphs,
     the last three are (1) a predicate graph, (2) its true branch, and
     (3) the false branch.
     What we do here is convert the predicate graph into the false branch
     of the preceeding predicate by adding a select node to this graph
     and attaching the True and False branches to this new select node.
     Note that a selector graph must be added and an INT node added to
     convert the boolean predicate into an integer selector.  Note also
     that the True and False branches must be swapped in the ordering so
     that the Flase branch corresponds to the zero selector value.
   */
  int count, eport;
  stryng ename;
  stentry *etype;
  port *e /*, *newe*/;
  node *predicate, *intn, *seln;
  graph *gr, *gr1, *gr2, *pgr;
  int FORLIM;

  /* Find the last three subgraphs */
  count = numbofsubgraphs(n) - 2;
  pgr = n->UU.U2.ndsubsid;
  while (count > 1) {
    pgr = pgr->grnext;
    count--;
  }
  predicate = pgr->grnode;
  /* create the INT and SELECT nodes and wire them */
  intn = createsimplenode(ifnint);
  insertnode(predicate, tolastnodeingraph(predicate), intn);
  seln = createcompoundnode(ifnselect);
  insertnode(predicate, intn, seln);
  e = getinputedge(predicate, 1);
  changeedgedest(e, intn, 1);
  mymemcpy(ename.str, blankstring, sizeof(stryngar));
  ename.len = 0;
  /* newe = */ (void)insertedge(intn, 1, seln, 1, getbasictype(ifbinteger), ename);
  e = n->ndilist;
  while (e != NULL) {
    etype = e->pttype;
    ename = e->ptname;
    eport = e->pttoport;
    /* newe = */ (void)insertedge(predicate, eport, seln, eport + 1, etype, ename);
    e = e->pttonext;
  }
  FORLIM = largestoutputportnumber(n);
  for (eport = 1; eport <= FORLIM; eport++) {
    e = getoutputedge(n, eport);
    if (e != NULL) {
      etype = e->pttype;
      ename = e->ptname;
      /* newe = */ (void)insertedge(seln, eport, predicate, eport, etype, ename);
    }
  }
  /* Add subgraphs to Select Node */
  seln->ndsort = ndcompound;
  gr = newgraphptr();
  gr->grnode = NULL;
  gr->grnext = NULL;
  seln->UU.U2.ndsubsid = gr;
  gr->grnode = createselectorgraph(seln);
  gr2 = pgr->grnext;   /* Last subgraph */
  gr1 = gr2->grnext;   /* Next to last subgraph */
  gr->grnext = gr1;
  gr1->grnext = gr2;
  gr2->grnext = NULL;
  pgr->grnext = NULL;
  gr1->grnode->ndparent = seln;
  shiftoutputports(gr1->grnode, 1, 1);
  gr2->grnode->ndparent = seln;
  shiftoutputports(gr2->grnode, 1, 1);
  removeunusedports(seln);
}  /* ConvertElseIfToSelect */

static void searchgraph_(g)
node *g;
{
  node *n;
  int grnum, FORLIM;

  n = g->ndnext;
  while (n != NULL) {
    /* depth first search */
    if (n->ndsort == ndcompound) {
      FORLIM = numbofsubgraphs(n);
      for (grnum = 0; grnum < FORLIM; grnum++)
        searchgraph_(tochildgraph(n, grnum));
      if (n->ndcode == ifnifthenelse) {
        /* Conver from right to left */
        while (numbofsubgraphs(n) > 2)
          convertelseiftoselect(n);
        /* Now only two subgraphs exist */
        convertiftoselect(n);
      }
    } else {
      if (n->ndcode == ifnaelement) {
        while (largestinputportnumber(n) > 2)
          splitaelement(n);
      } else if (n->ndcode == ifnareplacen)
        convertareplacen(n);
    }
    n = n->ndnext;
  }
}  /* SearchGraph */


static void converttoversion1()
{
  /* This routine converts IF1 version 1.1 to version 1.0 by
      - Translating IfThenElse nodes to nested Select nodes.
      - Translating multilevel AElement nodes to a string of single level
        AElement nodes.
      - Translating multilivel AReplaceN nodes to an equivalent combination
        of AElement - AReplace - AReplace nodes.
  */
  node *f;

  f = firstfunction;
  while (f != NULL) {
    searchgraph_(f);
    f = tonextfunction(f);
  }
}  /* ConvertToVersion1 */


static boolean nodesareequivalent(n1, n2, LINK)
node *n1, *n2;
struct LOC_removegraphcse *LINK;
{
  /* Pre:  (N1^.NDSort = NDAtomic) and (N2^.NDSort = NDAtomic) and OpCode(N1) = OpCode(N2)
     Post: NodesAreEquivalent := (Input edges of N1 and N2 are equivalent)
                     AND (corresponding output edges have the same types )
   */
  port *e1, *e2;
  stryng lit1, lit2;
  boolean sametypes, same;
  int port_, maxport;

  maxport = largestinputportnumber(n1);
  same = (maxport == largestinputportnumber(n2));
  port_ = 1;
  while (same && port_ <= maxport) {
    e1 = getinputedge(n1, port_);
    e2 = getinputedge(n2, port_);
    /* Check that the edges are equivalent */
    if (e1 != NULL || e2 != NULL) {
      if (e1 != NULL && e2 != NULL) {
        /* Both edges are not nil, check that they are equivalent */
        if (e1->ptsort == ptlit && e2->ptsort == ptlit) {
          lit1 = e1->UU.ptlitvalue;
          lit2 = e2->UU.ptlitvalue;
          same = (e1->pttype == e2->pttype) & equalstrings(&lit1, &lit2);
        } else if (e1->ptsort == ptedge && e2->ptsort == ptedge)
          same = (producernodeofedge(e1) == producernodeofedge(e2)) &
                 (producerportnumber(e1) == producerportnumber(e2));
        else
          same = false;
      } else  /* One edge is nil and the other is not */
        same = false;
    }
    /* do nothing, go on to the next port */
    port_++;
  }  /* while same ... */
  if (same) {
    /* The inputs of the two nodes are identical, now we must
       check that the corresponding types of the output edges
       are the same */
    sametypes = true;
    port_ = largestoutputportnumber(n1);
    maxport = largestoutputportnumber(n2);
    if (port_ > maxport)
      maxport = port_;
    port_ = 1;
    while (port_ <= maxport && sametypes) {
      e1 = getoutputedge(n1, port_);
      e2 = getoutputedge(n2, port_);
      if (e1 != NULL && e2 != NULL)
        sametypes = (e1->pttype == e2->pttype);
      port_++;
    }
    return sametypes;
  } else
    return false;

  /* one is an edge and the other is a literal */
}  /* NodesAreEquivalent */

static void inittable(LINK)
struct LOC_removegraphcse *LINK;
{
  /* Think of the Table as a collection of sets, one for each
     simple opcode.  InitTable initiallizes all these sets to
     be empty.
   */
  unchar index;

  for (index = firstatom; index <= ifmaxnode; index++)
    LINK->table[index - firstatom] = NULL;
}  /* InitTable */

static void addtotable_(key, n, LINK)
unchar key;
node *n;
struct LOC_removegraphcse *LINK;
{
  /* Add node N to the set identified by Key */
  trec *t;

  t = (trec *)Malloc(sizeof(trec));
  t->node_ = n;
  t->next = LINK->table[key - firstatom];
  LINK->table[key - firstatom] = t;
}  /* AddToTable */

static node *getequivnode(opcode, n, LINK)
unchar opcode;
node *n;
struct LOC_removegraphcse *LINK;
{
  /* Search the table for a node with the given OpCode and
     Matches N's input edges
     Return this equivalent node if one exists otherwise return nil.
   */
  boolean found;
  trec *t;
  node *checknode;

  found = false;
  t = LINK->table[opcode - firstatom];
  while (!found && t != NULL) {
    checknode = t->node_;
    if (nodesareequivalent(checknode, n, LINK))
      found = true;
    else
      t = t->next;
  }
  if (found)
    return checknode;
  else
    return NULL;
}  /* GetEquivNode */

static void movealloutputedges(fromnode, tonode, LINK)
node *fromnode, *tonode;
struct LOC_removegraphcse *LINK;
{
  /* move all the output edges of FromNode to corresponding
     output edges of ToNode.
     NOTE:  ChangeEdgeSrc( E, .. ) changes the "environment"
            of E and so we must save E in temp, then advance E
            and finally modify temp
   */
  port *e, *temp;
  int port_;

  e = fromnode->ndolist;
  while (e != NULL) {
    temp = e;
    e = e->UU.U1.ptfrnext;
    port_ = producerportnumber(temp);
    changeedgesrc(temp, tonode, port_);
  }
}  /* MoveAllOutputEdges */

static void moveoutputedges(n, fromport, toport)
node *n;
int fromport, toport;
{
  /* detach the output edges from port 'fromport' and reattach
     then to port 'toport'
   */
  port *e, *tmpe;

  e = getoutputedge(n, fromport);
  while (e != NULL) {
    /* NOTE: we must move off the edge we are moving
            BEFORE we move it! */
    tmpe = e;
    e = nextoutputedgesameport(e);
    changeedgesrc(tmpe, n, toport);
  }
}  /* MoveOutputEdges */

static void pushfanoutout(n, LINK)
node *n;
struct LOC_removegraphcse *LINK;
{
  /* If fanout was created from nodes inside the returns
     graph to the boundry of that edge, we wnat to push the
     fanout out of the subgraph and into the outside scope */
  /* The assumptions are:
     (1) N is a loop node (Forall, LoopA or LoopB)
     (2) cse has been run on it
  */
  node *retg, *srcnode, *cn;
  stryng litvalue, name;
  int litport, eport, srcport, removeport, cp;
  port *e, *lite, *ne, *srce, *removee;

  if (n->ndcode == ifnforall)
    retg = toforallreturnsgraph(n);
  else
    retg = toreturnsgraph(n);
  e = retg->ndilist;
  while (e != NULL) {
    if (e->ptsort == ptlit) {
      /* Push this Literal edge out of the returns
         graph and into the graph containing the
         compound node
       */
      lite = e;
      e = e->pttonext;
      litport = lite->pttoport;
      litvalue = lite->UU.ptlitvalue;
      ne = getoutputedge(n, litport);
      while (ne != NULL) {
        srce = ne;
        ne = nextoutputedgesameport(ne);
        cn = srce->pttonode;
        cp = srce->pttoport;
        name = srce->ptname;
        disconnectedgefromdest(srce);
        disconnectedgefromsource(srce);
        srce = insertliteral(cn, cp, srce->pttype, litvalue, name);
        /*  ChangeEdgeToLiteral( SrcE, LitValue );*/
      }
      removeedge(&lite);
      shiftinputports(retg, litport, -1);
      shiftoutputports(n, litport, -1);
      continue;
    }
    /* Replace fanout within the returns graph with fanout
       on the surrounding compound node.
       In this algorithm, all activity takes place to the RIGHT
       of edge E.  Edge E itself is never removed.
     */
    eport = e->pttoport;
    srcnode = producernodeofedge(e);
    srcport = producerportnumber(e);
    srce = getoutputedge(srcnode, srcport);
    while (srce != NULL) {
      if (srce == e || srce->pttonode != retg) {
        srce = nextoutputedgesameport(srce);
        continue;
      }
      removee = srce;
      srce = nextoutputedgesameport(srce);
      removeport = removee->pttoport;
      moveoutputedges(n, removeport, eport);
      removeedge(&removee);
      shiftinputports(retg, removeport, -1);
      shiftoutputports(n, removeport, -1);
    }
    e = e->pttonext;
  }
}  /* PushFanoutOut */

static int removegraphcse(g, recurse)
node *g;
boolean recurse;
{
  /* Search this graph removing all common subexpressions involving
     simple nodes.
     NOTE:  Will not equate equivalent compound nodes.
            This can be done by checking for:
                1) Equivalent Opcodes
                2) Equivalent inputs
                3) Equivalent subgraphs.  We can assume subgraphs
                   have common subexpressions already merged and
                   hence all surviving nodes are in fact unique.
                   Walk the two graphs in the given order and
                   check that corresponding nodes are equivalent.
                   This will only find IDENTICAL graphs and not
                   equivalent graphs.  Finding EQUIVALENT graphs
                   is a bit more complicated.  It involves constructing
                   parallel lists, one for each opcode in each graph.
                   With each list, pull one node off a list at a time
                   and pair it with an equivalent node from its
                   parallel list.  The two subgraphs are equivalent
                   if the operation terminates normally.
     NOTE:  Will not equate node with identical but reversed
            inputs on a commutative operation node.
            The only commutative nodes are:  Plus, Times, Min, Max,
                Equal, NotEqual.
     NOTE:  Common subexpressions are not moved across graph boundaries.
   */
  struct LOC_removegraphcse V;
  node *tmpn, *eqnode, *n;
  boolean remove;
  int count, subgr;
  unchar opcode;
  int FORLIM;

  count = 0;
  inittable(&V);   /* Initialize all sets to be empty */
  n = g->ndnext;
  while (n != NULL) {   /* Walk the graph */
    remove = false;
    if (n->ndsort == ndatomic) {
      opcode = n->ndcode;
      eqnode = getequivnode(opcode, n, &V);
      if (eqnode == NULL) {
        /* No equivalent nodes found, add it to the set */
        addtotable_(opcode, n, &V);
      } else {
        count++;
        /* An equivalent node was found, flag this one to be removed */
        remove = true;
      }
    } else {  /* Recursively walk subgraphs of compound node */
      if (recurse) {
        FORLIM = numbofsubgraphs(n);
        for (subgr = 0; subgr < FORLIM; subgr++)
          count += removegraphcse(tochildgraph(n, subgr), recurse);
      }
      if ((unsigned)n->ndcode < 32 &&
          ((1L << n->ndcode) &
           ((1L << ifnforall) | (1L << ifnloopb) | (1L << ifnloopa))) != 0)
        pushfanoutout(n, &V);
    }
    tmpn = n;
    n = n->ndnext;
    if (remove) {
      movealloutputedges(tmpn, eqnode, &V);
      /* Note, RemoveNode also removes all remaining input
              and output edges */
      removenode(tmpn);
    }
  }  /* while */
  return count;
}  /* RemoveGraphCSE */



static ndptrreclist *ndptrnewlist()
{
  ndptrreclist *templis;

  templis = (ndptrreclist *)Malloc(sizeof(ndptrreclist));
  templis->length = 0;
  templis->listhd = NULL;
  templis->listtl = NULL;
  return templis;
}

static boolean ndptrisnull(lisptr)
ndptrreclist *lisptr;
{
  return (lisptr->length == 0);
}

static node *ndptrrmhead(lisptr)
ndptrreclist *lisptr;
{
  node *Result;

  if (lisptr->listhd == NULL)
    return NULL;
  Result = lisptr->listhd->elem;
  lisptr->length--;
  if (lisptr->listhd == lisptr->listtl) {
    lisptr->listhd = NULL;
    lisptr->listtl = NULL;
  } else
    lisptr->listhd = lisptr->listhd->next;
  return Result;
}

static int ndptrlength(lisptr)
ndptrreclist *lisptr;
{
  return (lisptr->length);
}

static ndptrreclist *ndptrappend(lisptr, element)
ndptrreclist *lisptr;
node *element;
{
  ndptrelmlist *elmptr;

  elmptr = (ndptrelmlist *)Malloc(sizeof(ndptrelmlist));
  elmptr->elem = element;
  elmptr->next = NULL;
  if (lisptr->length == 0)
    lisptr->listhd = elmptr;
  else
    lisptr->listtl->next = elmptr;
  lisptr->listtl = elmptr;
  lisptr->length++;
  return lisptr;
}

static void imposegraphordering(neworder, g)
ndptrreclist *neworder;
node *g;
{
  /* ImposeGraphOrdering*/
  /*   Rearrange the links on the nodes in G to reflect the*/
  /*   ordering given in NewOrder*/
  /* Precondition:  length( NewOrder ) = length( G )   */
  /* written 84/3/8 by sks*/
  /* modified 85/1/13 by mlw*/
  int newlabel;
  node *thisnode, *previousnode;

  /* ImposeGraphOrdering */
  newlabel = 0;
  previousnode = g;
  while (!ndptrisnull(neworder)) {
    thisnode = ndptrrmhead(neworder);
    newlabel++;
    thisnode->ndlabel = newlabel;
    previousnode->ndnext = thisnode;
    previousnode = thisnode;
  }
  previousnode->ndnext = NULL;
}

static int numancestors(n)
node *n;
{
  /* NumAncestors*/
  /*   Return the number of direct ancestor nodes*/
  /* written 84/9/11 by sks*/
  port *e;
  int result;
  node *prodn;

  /* NumAncestors */
  result = 0;
  e = n->nddepilist;
  if (e == NULL)
    e = n->ndilist;
  while (e != NULL) {
    if (e->ptsort != ptlit) {
      prodn = producernodeofedge(e);
      if (prodn->ndsort != ndgraph)
        result++;
    }
    e = e->pttonext;
  }
  return result;
}

/* Store the reference count of a node in the Misc field of the node */
static void setrefcount(n, count)
node *n;
int count;
{
  n->ndmisc.numb = count;
}  /* SetRefCount */

static int refcount(n)
node *n;
{
  return (n->ndmisc.numb);
}  /* RefCount */

static boolean dfordergraph(g)
node *g;
{
  /* DFOrderGraph*/
  /*   Rearrange nodes in a graph so that if node A depends*/
  /*   on outputs of node B, A will follow B*/
  /* written 84/2/22 by sks*/
  /* changed 84/9/11 by sks to use linear time algorithm*/
  /* modified 85/1/13 by mlw to check for cycles in graph*/
  /* modified 86/2/24 by mlw: Changed to a function to return a    */
  /*   status code (true if it worked ok, false if a problem).     */
  /*   Also, changed for seperate compilation of */
  ndptrreclist *newordering, *scheduled;
  int i, neworderlength, graphlength;
  node *n, *current, *consumer;
  boolean noerror;
  port *e;
  int FORLIM;

  /*DFOrderGraph*/
  noerror = true;
  if (g->ndnext == NULL) {
    return noerror;
  }  /* not an empty graph */
  scheduled = ndptrnewlist();
  newordering = ndptrnewlist();
  /* Set the reference count for each node to be the number*/
  /* of ancestors.  If none, place node on 'scheduled' list*/
  /* if we see a compound node, schedule within it now!*/
  current = g->ndnext;
  while (current != NULL) {
    if (current->ndsort == ndcompound) {
      FORLIM = numbofsubgraphs(current);
      for (i = 0; i < FORLIM; i++)
        noerror &= dfordergraph(tochildgraph(current, i));
    }
    setrefcount(current, numancestors(current));
    if (refcount(current) == 0)
      scheduled = ndptrappend(scheduled, current);
    current = current->ndnext;
  }
  /* Decrement reference counts of direct descendants of each node*/
  /* that has been scheduled.  When reference count reaches zero,*/
  /* move a node to the scheduled list.*/
  current = ndptrrmhead(scheduled);
  while (current != NULL) {
    newordering = ndptrappend(newordering, current);
    e = current->nddepolist;
    if (e == NULL)
      e = current->ndolist;
    while (e != NULL) {
      consumer = e->pttonode;
      if (consumer->ndsort != ndgraph) {
        setrefcount(consumer, refcount(consumer) - 1);
        if (refcount(consumer) == 0)
          scheduled = ndptrappend(scheduled, consumer);
      }
      e = e->UU.U1.ptfrnext;
    }
    current = ndptrrmhead(scheduled);
  }
  neworderlength = ndptrlength(newordering);
  graphlength = numbnodesingraph(g);
  if (neworderlength < graphlength) {
    noerror = false;
    printf("ERROR: Not all graph nodes scheduled\n");
    printf("  ---  Check for cycles in graph\n");
    printf("  ---  Here is a list of unscheduled nodes:\n");
    n = g->ndnext;
    while (n != NULL) {
      if (refcount(n) != 0)
        printf("  -----      %.16sID = %5d    (Label = %d)\n",
               nodename[n->ndcode], n->ndid, n->ndlabel);
      n = n->ndnext;
    }
    return noerror;
  }
  if (neworderlength <= graphlength) {
    imposegraphordering(newordering, g);
    return noerror;
  }
  noerror = false;
  printf("ERROR: More nodes scheduled than in graph\n");
  printf("  ---  Some nodes may be scheduled twice.\n");
  return noerror;
}

static boolean allconstantinputs(n, LINK)
node *n;
struct LOC_fixreturnsgraph *LINK;
{
  /* Returns true if all inputs of N are either literals or come from
     K ports.
     -- N is a node in the returns graph of Loop which does not
        depend on any other node in that graph.
   */
  boolean constant;
  port *e;

  /* K : integer   -- Imported from outer scope */
  constant = true;
  e = n->ndilist;
  while (constant && e != NULL) {
    if (e->ptsort == ptedge) {
      if (producerportnumber(e) > LINK->k)
        constant = false;
    }
    e = e->pttonext;
  }
  return constant;
}  /* AllConstantInputs */

static void createnewkport(LINK)
struct LOC_fixreturnsgraph *LINK;
{
  /* Creates ONE new K port on the compound node Loop.
     -- Imports the following variables:
     -- IsForall : boolean;
     -- Loop, InitG, TestG, BodyG, RetG, GenG : NDPtr;
     -- var  K, L, T : integer
   */
  LINK->k++;
  LINK->l++;
  LINK->t++;
  if (LINK->isforall) {
    shiftinputports(LINK->geng, LINK->k, 1);
    shiftoutputports(LINK->bodyg, LINK->k, 1);
    shiftinputports(LINK->bodyg, LINK->k, 1);
    shiftoutputports(LINK->retg, LINK->k, 1);
    return;
  }
  shiftinputports(LINK->initg, LINK->k, 1);
  shiftoutputports(LINK->bodyg, LINK->k, 1);
  shiftinputports(LINK->bodyg, LINK->k, 1);
  shiftoutputports(LINK->testg, LINK->k, 1);
  shiftoutputports(LINK->retg, LINK->k, 1);
}  /* CreateNewKPort */

static void createnewlport(LINK)
struct LOC_fixreturnsgraph *LINK;
{
  /* Creates ONE new L port on the compound node Loop.
     -- Imports the following variables:
     -- IsForall : boolean;
     -- Loop, InitG, TestG, BodyG, RetG, GenG : NDPtr;
     -- var  L, T : integer
   */
  LINK->l++;
  LINK->t++;
  if (LINK->isforall) {
    shiftinputports(LINK->bodyg, LINK->l, 1);
    shiftoutputports(LINK->retg, LINK->l, 1);
    return;
  }
  shiftinputports(LINK->bodyg, LINK->l, 1);
  shiftoutputports(LINK->testg, LINK->l, 1);
  shiftoutputports(LINK->retg, LINK->l, 1);
}  /* CreateNewLPort */

static void insureedgeisnotconstant(n, p, LINK)
node *n;
int p;
struct LOC_fixreturnsgraph *LINK;
{
  /* The edge on input port P of node N is not supposed to be
     a literal or from a K port.  If it is, a new L or T port is
     added and this edge is redirected to that new port.
   */
  port *e /*, *newe*/;
  stryng ename;
  stentry *etype;
  int pp;
  node *pn;

  e = getinputedge(n, p);
  if (e == NULL) {
    return;
  }  /* E <> nil */
  mymemcpy(ename.str, blankstring, sizeof(stryngar));
  ename.len = 0;
  etype = e->pttype;
  if (etype->stsort == iftmultiple)
    etype = etype->UU.stbasetype;
  if (e->ptsort == ptlit) {
    if (LINK->isforall) {
      LINK->t++;
      changeedgedest(e, LINK->bodyg, LINK->t);
      /* newe = */ (void)insertedge(LINK->retg, LINK->t, n, p, etype, ename);
      return;
    }
    createnewlport(LINK);
    changeedgedest(e, LINK->initg, LINK->l);
    /* newe = */ (void)insertedge(LINK->bodyg, LINK->l, LINK->bodyg, LINK->l, etype,
                      ename);
    /* newe = */ (void)insertedge(LINK->retg, LINK->l, n, p, etype, ename);
    return;
  }
  pn = producernodeofedge(e);
  pp = producerportnumber(e);
  if (pn != LINK->retg || pp > LINK->k)
    return;
  if (LINK->isforall) {  /* Should Come from a T port in the Body */
    LINK->t++;
    /* newe = */ (void)insertedge(LINK->bodyg, pp, LINK->bodyg, LINK->t, etype, ename);
    changeedgesrc(e, LINK->retg, LINK->t);
    return;
  }
  createnewlport(LINK);
  /* newe = */ (void)insertedge(LINK->initg, pp, LINK->initg, LINK->l, etype, ename);
  /* newe = */ (void)insertedge(LINK->bodyg, LINK->l, LINK->bodyg, LINK->l, etype, ename);
  changeedgesrc(e, LINK->retg, LINK->l);

  /* E is an edge */
  /* Should come from an L port */
}  /* InsureEdgeIsNotConstant */

static void moveoutsideofloop(n, LINK)
node *n;
struct LOC_fixreturnsgraph *LINK;
{
  /* -- N is a node in the returns graph that is to be moved outside
       the loop.  Its inputs are either literals for edges directly from
       K ports.  A copy of the node is make outside and a new K port
       and edges are created for each wired output port of N
  */
  port *le, *e, /* *newe,*/ *tmpe;
  node *newn, *pn;
  int pp, cp;
  stryng ename, litvalue;
  stentry *etype;
  int FORLIM;

  /* Imported from outside scope . . .
     var K : integer;
     LoopParent, Loop, RetG : NDPtr;
   */
  newn = copynode(n);
  insertnode(LINK->loopparent, toprevnode(LINK->loop), newn);
  /* Add input edges */
  e = n->ndilist;
  while (e != NULL) {
    cp = e->pttoport;
    if (e->ptsort == ptlit) {
      ename = e->ptname;
      litvalue = e->UU.ptlitvalue;
      etype = e->pttype;
      if (etype->stsort == iftmultiple)
        etype = etype->UU.stbasetype;
      /* newe = */(void)insertliteral(newn, cp, etype, litvalue, ename);
    } else {
      pp = producerportnumber(e);
      le = getinputedge(LINK->loop, pp);
      ename = le->ptname;
      etype = le->pttype;
      if (etype->stsort == iftmultiple)
        etype = etype->UU.stbasetype;
      if (le->ptsort == ptlit) {
        litvalue = le->UU.ptlitvalue;
        /* newe = */(void)insertliteral(newn, cp, etype, litvalue, ename);
      } else {
        pn = producernodeofedge(le);
        pp = producerportnumber(le);
        /* newe = */(void)insertedge(pn, pp, newn, cp, etype, ename);
      }
    }
    e = e->pttonext;
  }  /* Add input edges to NewN */
  FORLIM = largestoutputportnumber(n);
  /* Create a new K port for each used output port of node N */
  for (pp = 1; pp <= FORLIM; pp++) {
    e = getoutputedge(n, pp);
    if (e != NULL) {
      createnewkport(LINK);
      etype = e->pttype;
      if (etype->stsort == iftmultiple)
        etype = etype->UU.stbasetype;
      ename = e->ptname;
      /* newe = */(void)insertedge(newn, pp, LINK->loop, LINK->k, etype, ename);
      do {
        tmpe = e;
        e = nextoutputedgesameport(e);
        changeedgesrc(tmpe, LINK->retg, LINK->k);
      } while (e != NULL);
    }
  }
}  /* MoveOutsideOfLoop */

static void copynodetograph(n, g, startport, LINK)
node *n, *g;
int startport;
struct LOC_fixreturnsgraph *LINK;
{
  /* -- N is a node in the returns graph.
     -- All input edges of N are Literals or from K or L ports.
     -- Make a copy of N and install it as the last node in graph G.
     -- Graph ports, starting at number StartPort, have been allocated
        and reserved for the outputs of the copy of N.  These edges
        are installed here, but the output edges of node N itself
        are left unchanged.
   */
  node *prev, *newn, *pn;
  int pp, cp;
  port *ge, *e /*, *newe*/;
  stentry *etype;
  stryng ename, litvalue;
  int FORLIM;

  prev = tolastnodeingraph(g);
  newn = copynode(n);
  insertnode(g, prev, newn);
  /* Add input edges */
  e = n->ndilist;
  while (e != NULL) {
    cp = e->pttoport;
    etype = e->pttype;
    if (etype->stsort == iftmultiple)
      etype = etype->UU.stbasetype;
    ename = e->ptname;
    if (e->ptsort == ptlit) {
      litvalue = e->UU.ptlitvalue;
      /* newe = */ (void)insertliteral(newn, cp, etype, litvalue, ename);
    } else {  /* E is an edge, trace it back to graph G */
      pp = producerportnumber(e);
      ge = getinputedge(g, pp);
      if (ge == NULL)   /* create one */
        /* newe = */ (void)insertedge(g, pp, newn, cp, etype, ename);
      else if (ge->ptsort == ptedge) {
        pp = producerportnumber(ge);
        pn = producernodeofedge(ge);
        /* newe = */ (void)insertedge(pn, pp, newn, cp, etype, ename);
      } else {
        litvalue = ge->UU.ptlitvalue;
        /* newe = */ (void)insertliteral(newn, cp, etype, litvalue, ename);
      }
    }
    e = e->pttonext;
  }
  FORLIM = largestoutputportnumber(n);
  /* Add Output Edges, assume ports have already been created */
  for (LINK->port_ = 1; LINK->port_ <= FORLIM; LINK->port_++) {
    e = getoutputedge(n, LINK->port_);
    if (e != NULL) {
      ename = e->ptname;
      etype = e->pttype;
      if (etype->stsort == iftmultiple)
        etype = etype->UU.stbasetype;
      /* newe = */ (void)insertedge(newn, LINK->port_, g, startport, etype, ename);
      startport++;
    }
  }

  /* GE is a literal edge */
}  /* CopyNodeToGraph */

static void movenodeafterloop(node_, fvnode, loop, LINK)
node *node_, *fvnode, *loop;
struct LOC_fixreturnsgraph *LINK;
{
  /* -- Node is a node in the returns graph.
     -- FVNode is the final value node that an input edge at port 1 which
        which comes from the above Node.
     -- Loop is the for loop we are working in.
     Make a copy of Node and place it below the loop.  Connect each of its
     input edges as follows:
       if the edge is a literal
         then just connect it
       else if it comes from a KPort in the returns graph
         then make a connection from the value outside the loop
       else
         create a Final Value node with in the returns graph
         connect the value that used to go into Node to port 1 of the
         Final Value node.  If FVNode has a masking value, connect it to
         the new Final Value node.  Create an edge from the Final Value to
         the returns subgraph.  Create an edge from the loop to the copied
         node outside the loop.
      Finally create an edge(s) from the output of the newly created node
      to where ever the output of FVNode used to go (this edge will come
      out of the loop node);*/
  node *newn, *newfv;
  port *nextedgetomove, *nexte, /* *newe,*/ *tempe;
  stentry *etype;
  stryng valuestr, namestr;
  int eoldinputport;

  newn = copynode(node_);
  /* Place node after loop */
  insertnode(loop->ndparent, loop, newn);
  /* Connect input edges */
  LINK->e = node_->ndilist;
  while (LINK->e != NULL) {
    eoldinputport = LINK->e->pttoport;
    nextedgetomove = LINK->e->pttonext;
    if (LINK->e->pttype->stsort == iftmultiple)
      etype = LINK->e->pttype->UU.stbasetype;
    else
      etype = LINK->e->pttype;
    if (((producernodeofedge(LINK->e) == LINK->retg) &
         (producerportnumber(LINK->e) <= LINK->k)) ||
        LINK->e->ptsort == ptlit)
    {  /*connect edge from outside of loop*/
      if (LINK->e->ptsort == ptlit) {
        valuestr = LINK->e->UU.ptlitvalue;
        namestr = LINK->e->ptname;
        /* newe = */ (void)insertliteral(newn, LINK->e->pttoport, etype, valuestr,
                             namestr);
      } else {  /*else its coming from a K Port */
        tempe = getinputedge(loop, producerportnumber(LINK->e));
        namestr = tempe->ptname;
        if (tempe->ptsort == ptlit) {
          valuestr = tempe->UU.ptlitvalue;
          /* newe = */ (void)insertliteral(newn, LINK->e->pttoport, etype, valuestr,
                               namestr);
        }  /*then*/
        else
          /* newe = */ (void)insertedge(producernodeofedge(tempe),
                            producerportnumber(tempe), newn,
                            LINK->e->pttoport, etype, namestr);
      }  /*else*/
    }  /*then*/
    else {  /* else input isn't a literal or imported into loop */
      newfv = createsimplenode(ifnfinalvalue);
      insertnode(LINK->retg, tolastnodeingraph(LINK->retg), newfv);
      changeedgedest(LINK->e, newfv, 1);
      tempe = getinputedge(fvnode, 2);
      namestr = LINK->e->ptname;
      if (tempe != NULL)   /*FV has a mask, must add it to newFV */
        tempe = insertedge(producernodeofedge(tempe),
                           producerportnumber(tempe), newfv, 2, tempe->pttype,
                           namestr);
      /* Connect NewFV to RetG */
      tempe = insertedge(newfv, 1, LINK->retg,
                         largestinputportnumber(LINK->retg) + 1, etype,
                         namestr);
      /* Connect output edge to NewN */
      mymemcpy(namestr.str, blankstring, sizeof(stryngar));
      namestr.len = 0;
      tempe = insertedge(loop, largestinputportnumber(LINK->retg), newn,
                         eoldinputport, etype, namestr);
    }  /*else*/
    LINK->e = nextedgetomove;
  }  /*while*/
  tempe = getoutputedge(fvnode, 1);
  if (tempe == NULL)
    printf("Error in fix returns graph!\n");
  else {
    tempe = getoutputedge(loop, tempe->pttoport);
    while (tempe != NULL) {
      nexte = nextoutputedgesameport(tempe);
      changeedgesrc(tempe, newn, producerportnumber(getinputedge(fvnode, 1)));
      tempe = nexte;
    }  /*while*/
  }  /*else*/
  /* chop off connection from Node to FVNode */
  tempe = getinputedge(fvnode, 1);
  removeedge(&tempe);
}  /* MoveNodeAfterLoop */

static void removefinalvalue(n, loop, LINK)
node *n, *loop;
struct LOC_fixreturnsgraph *LINK;
{
  int pp, foroutport;
  port *fvinedge, *fvoutedge, *foroutedge, *loopinedge, /* *newe,*/ *tempe;
  boolean literal;
  stryng ename, eval;

  fvinedge = getinputedge(n, 1);
  pp = producerportnumber(fvinedge);
  literal = (fvinedge->ptsort == ptlit);
  if (!literal)
    loopinedge = getinputedge(loop, pp);
  fvoutedge = n->ndolist;
  while (fvoutedge != NULL) {
    foroutport = fvoutedge->pttoport;
    foroutedge = getoutputedge(loop, foroutport);
    while (foroutedge != NULL) {
      if (literal) {
        ename = fvinedge->ptname;
        eval = fvinedge->UU.ptlitvalue;
        /* newe = */ (void)insertliteral(foroutedge->pttonode, foroutedge->pttoport,
                             fvinedge->pttype, eval, ename);
      } else {
        ename = loopinedge->ptname;
        /* newe = */ (void)insertedge(producernodeofedge(loopinedge),
                          producerportnumber(loopinedge),
                          foroutedge->pttonode, foroutedge->pttoport,
                          loopinedge->pttype, ename);
      }
      disconnectedgefromdest(foroutedge);
      tempe = foroutedge;
      foroutedge = nextoutputedgesameport(tempe);
      disconnectedgefromsource(tempe);
    }  /*while*/
    disconnectedgefromdest(fvoutedge);
    tempe = fvoutedge;
    fvoutedge = nextoutputedgesameport(tempe);
    disconnectedgefromsource(tempe);
  }  /*while*/
}  /*RemoveFinalValue*/

static void fixreturnsgraph(loop_)
node *loop_;
{
  /*  -- Loop is either a FORALL, LOOPA or LOOPB compound node.
      -- All the subgraphs of Loop must be complete and must have
         been ordered by data dependence.
      -- Loop is contained in a graph G that must be complete above this
         compound node (Parent pointers are set, Next fields are set,
         input edges of Loop are defined).
      This routine will walk the returns graph, transplanting nodes that
      really don't belong there to either the outer graph G or the other
      subgraphs.  After the walk:
      -- The returns graph will only contain nodes dealing with multiple
         values.
      -- The port numbers of the subgraphs may be dramatically altered
         but will be consistant with the new graph organization.
   */
  struct LOC_fixreturnsgraph V;
  node *n, *pn, *rn;
  int oports, startport /* , cse */;
  port *tmpe;
  stentry *etype;
  boolean ok;
  long legalreturnsnodes[ifmaxnode / 32 + 2];
  int FORLIM;

  V.loop = loop_;
  P_addset(P_expset(legalreturnsnodes, 0L), ifnfirstvalue);
  P_addset(legalreturnsnodes, ifnfinalvalue);
  P_addset(legalreturnsnodes, ifnagather);
  P_addset(legalreturnsnodes, ifnallbutlastvalue);
  P_addset(legalreturnsnodes, ifnreduce);
  P_addset(legalreturnsnodes, ifnredleft);
  P_addset(legalreturnsnodes, ifnredright);
  P_addset(legalreturnsnodes, ifnredtree);
  P_addset(legalreturnsnodes, ifnagatherat);
  P_addset(legalreturnsnodes, ifnreduceat);
  P_addset(legalreturnsnodes, ifnfinalvalueat);
  V.loopparent = V.loop->ndparent;
  V.k = largestinputportnumber(V.loop);
  V.isforall = (V.loop->ndcode == ifnforall);
  if (V.isforall) {
    V.geng = toforallgeneratorgraph(V.loop);
    V.bodyg = toforallbodygraph(V.loop);
    V.retg = toforallreturnsgraph(V.loop);
    V.l = largestinputportnumber(V.geng);
    if (V.l == 0)
      V.l = V.k;
  } else {
    V.initg = toinitgraph(V.loop);
    V.testg = totestgraph(V.loop);
    V.bodyg = tobodygraph(V.loop);
    V.retg = toreturnsgraph(V.loop);
    V.l = largestinputportnumber(V.initg);
    if (V.l == 0)
      V.l = V.k;
  }
  V.t = largestinputportnumber(V.bodyg);
  if (V.t == 0)
    V.t = V.l;
  /* cse = */ (void)removegraphcse(V.retg, false);
  rn = V.retg->ndnext;
  while (rn != NULL) {
    n = rn;
    if (n->ndcode == ifnfinalvalue) {
      V.e = getinputedge(n, 1);
      if (V.e->ptsort != ptlit) {
        pn = producernodeofedge(V.e);
        tmpe = pn->ndolist;
        if (tmpe->UU.U1.ptfrnext == NULL && pn != V.retg &&
            pn->ndcode != ifnallbutlastvalue)
          movenodeafterloop(pn, n, V.loop, &V);
      }  /*then*/
    }  /*then*/
    rn = rn->ndnext;
  }  /*while*/
  cleanupgraph(V.loop->ndparent);
  if (V.loop->ndparent == NULL)
  {   /* make sure loop was not removed by CleanUpGraph*/
    return;
  }  /*then*/
  V.k = largestinputportnumber(V.loop);
  if (V.isforall) {
    V.l = largestinputportnumber(V.geng);
    if (V.l == 0)
      V.l = V.k;
  } else {
    V.l = largestinputportnumber(V.initg);
    if (V.l == 0)
      V.l = V.k;
  }
  V.t = largestinputportnumber(V.bodyg);
  if (V.t == 0)
    V.t = V.l;
  rn = V.retg->ndnext;
  while (rn != NULL) {
    n = rn;
    rn = rn->ndnext;
    if (P_inset(n->ndcode, legalreturnsnodes)) {
      switch (n->ndcode) {

      case ifnfinalvalue:
        pn = producernodeofedge(getinputedge(n, 1));
        if (pn == NULL)
          ok = true;
        else if (pn->ndsort == ndgraph)
          ok = true;
        else
          ok = false;
        if ((allconstantinputs(n, &V) & (getinputedge(n, 2) == NULL)) && ok)
          removefinalvalue(n, V.loop, &V);
        else {
          insureedgeisnotconstant(n, 1, &V);
          insureedgeisnotconstant(n, 2, &V);
        }
        break;

      case ifnfirstvalue:
      case ifnallbutlastvalue:
      case ifnfinalvalueat:
        insureedgeisnotconstant(n, 1, &V);
        insureedgeisnotconstant(n, 2, &V);
        break;
        /* FirstValue */

      case ifnagather:
      case ifnagatherat:
        insureedgeisnotconstant(n, 2, &V);
        insureedgeisnotconstant(n, 3, &V);
        break;
        /* AGather */

      case ifnreduce:
      case ifnredleft:
      case ifnredright:
      case ifnredtree:
      case ifnreduceat:
        insureedgeisnotconstant(n, 3, &V);
        insureedgeisnotconstant(n, 4, &V);
        break;
        /* Reduce */
      }/* case */
      continue;
    }
    if (allconstantinputs(n, &V))
      moveoutsideofloop(n, &V);
    else {
      oports = numberofwiredoutputports(n);
      if (V.isforall) {
        /* Create ports for output edges of N */
        startport = V.t + 1;
        V.t += oports;
        copynodetograph(n, V.bodyg, startport, &V);
      } else {  /* Must be an iterative loop */
        /* Create ports for output edges of N */
        startport = V.l + 1;
        shiftoutputports(V.testg, startport, oports);
        shiftinputports(V.bodyg, startport, oports);
        V.l += oports;
        V.t += oports;
        copynodetograph(n, V.bodyg, startport, &V);
        copynodetograph(n, V.initg, startport, &V);
      }
      FORLIM = largestoutputportnumber(n);
      /* Move output ports of N to RetG */
      for (V.port_ = 1; V.port_ <= FORLIM; V.port_++) {
        V.e = getoutputedge(n, V.port_);
        if (V.e != NULL) {
          do {
            tmpe = V.e;
            V.e = nextoutputedgesameport(V.e);
            changeedgesrc(tmpe, V.retg, startport);
          } while (V.e != NULL);
          startport++;
        }
      }
    }
    removenode(n);
  }  /* while RN */
  compactports(V.loop);
  /* Make sure all L and T port edges in RetG are multiples */
  V.k = largestinputportnumber(V.loop);
  V.e = outputedgegeport(V.retg, V.k + 1);
  while (V.e != NULL) {
    etype = V.e->pttype;
    if (etype->stsort != iftmultiple && etype->stsort != iftbuffer) {
      etype = getconstructortype(iftmultiple, etype);
      V.e->pttype = etype;
    }
    V.e = V.e->UU.U1.ptfrnext;
  }
  /* Change the type of the output edges of AllButLastValue
     nodes to a Multiple */
  n = V.retg->ndnext;
  while (n != NULL) {
    if (n->ndcode == ifnallbutlastvalue) {
      V.e = n->ndolist;
      while (V.e != NULL) {
        etype = V.e->pttype;
        if (etype->stsort != iftmultiple) {
          etype = getconstructortype(iftmultiple, etype);
          V.e->pttype = etype;
        }
        V.e = V.e->UU.U1.ptfrnext;
      }
    }
    n = n->ndnext;
  }

  /* Must move N out of RetG */
  /* Move N out of RetG */
}  /* FixReturnsGraph */

static void findloopnodes(g)
node *g;
{
  node *n;
  int grnum, FORLIM;

  n = g->ndnext;
  while (n != NULL) {
    if (n->ndsort == ndcompound) {
      FORLIM = numbofsubgraphs(n);
      for (grnum = 0; grnum < FORLIM; grnum++)
        findloopnodes(tochildgraph(n, grnum));
      switch (n->ndcode) {

      case ifnforall:
      case ifnloopa:
      case ifnloopb:
        fixreturnsgraph(n);
        break;

      case ifnselect:
      case ifntagcase:
      case ifnifthenelse:
      case ifniter:
        /* blank case */
        break;
      }/* case */
    }
    n = n->ndnext;
  }
}  /* FindLoopNodes */


static boolean dforder(module)
node *module;
{
  boolean Result;
  node *g;
  int i;
  stryng orderstring;
  boolean ok, noerror;
  int FORLIM;

  /* DFOrder */
  noerror = true;
  FORLIM = numbofsubgraphs(module);
  for (i = 0; i < FORLIM; i++) {
    g = tochildgraph(module, i);
    ok = dfordergraph(g);
    if (ok)
      findloopnodes(g);
    noerror = (noerror && ok);
  }  /* for */
  removedeadcode();
  Result = noerror;
  if (!noerror)
    return Result;
  string20(&orderstring, " Nodes are DFOrdered");
  addstamp('D', orderstring);
  /* Remove the offsetter stamp */
  removestamp('O');
  return Result;
}




/*  This code calls the routines that do the processing that used to be done
    separatly in if1prepare.*/
static boolean backend()
{  /* Back End */
  boolean ok;
  stryng checkstring;

  ok = true;
  /* Add Stamp for IF1check */
  string20(&checkstring, " Faked IF1CHECK     ");
  addstamp('C', checkstring);
  if (!dforder(module)) {
    ok = false;
    printf("******** graph couldn't be ordered ********\n");
  }
  converttoversion1();
  removedeadcode();
  return ok;
}  /* Back End */

extern int main(int,char**);
int
main(argc, argv)
int argc;
Char *argv[];
{
  register int i;                                /* NEW CANN */
  stryng txt;
  for ( i = 0; i < argc; i++ ) {                 /* NEW CANN */
    if ( strcmp( argv[i], "-SISglue" ) == 0 )   /* NEW CANN */
      CANN_GlueMode = 1;                        /* NEW CANN */
    else if ( argv[i][1] == 'F' ) /* NEW CANN */
      CANN_file_name = &(argv[i][2]); /* NEW CANN */
    }                                            /* NEW CANN */

  for(i=0;i<maxstringchars;++i) blankstring[i] = ' ';

  PASCAL_MAIN(argc, argv);
  /*llparse*/
  listfile = NULL;
  reservedwords = NULL;
  inputfile = NULL;
  etableout = NULL;
  ptableout = NULL;
  diag = NULL;
  source = NULL;
  printf(" LL Parse");
  printf(", using binary files\n");
  paramlist = NULL;
  xrefparam = defineparameter(&paramlist, "XREF      ", "X         ", flagpar,
                              13, 1);
  directoryparam = defineparameter(&paramlist, "DIRECTORY ", "DIR       ",
                                   strpar, 14, 1);
  debugparam = defineparameter(&paramlist, "DEBUG     ", "D         ",
                               flagpar, 15, 1);
  listingparam = defineparameter(&paramlist, "LISTING   ", "L         ",
                                 flagpar, 16, 1);
  pass1param = defineparameter(&paramlist, "PREPRO    ", "PREPRO    ",
                               flagpar, 17, 1);
  listfparam = defineparameter(&paramlist, "ListFile  ", "LF        ", strpar,
                               18, 1);
  readcommandline(infile, &outfile, &paramlist);
  listing = (listingparam->parvalue.len > 0 || listfparam->parvalue.len > 0);
  string20(&defaultdirectoryname, "/usr/local/sisal    ");
  askordefault(directoryparam, &defaultdirectoryname, false,
               "                    ");
  directoryname = directoryparam->parvalue;
  xref = (xrefparam->parvalue.len > 0);
  if (xref)
    listing = true;
  if (listing) {
    if (listfparam->parvalue.len > 0)
      listfilename = listfparam->parvalue;
    else
      listfilename = outfile->parvalue;
    if (!openlistfile(listfilename, &listfile)) {
      listing = false;
      if (xref) {
        printf("No Cross Reference will be generated, can not open listing file.\n");
        xref = false;
      }
    }
  }
  if (infile[0]->parvalue.len > 0) {

{ /* NEW CANN 2/92 */
  char *Ptr;
  int   Idx;

  if ( CANN_file_name != NULL ) {
    txt.len = 0;
    for ( Idx = 1, Ptr = CANN_file_name; *Ptr != '\0'; Ptr++, Idx++ ) {
      concatchar(&txt, *Ptr );
      }
    }
} /* NEW CANN 2/92 */

    filename = infile[0]->parvalue;

    if ( CANN_file_name == NULL ) /* NEW CANN 2/92 */
      txt = filename;             /* NEW CANN 2/92 */

    printf("* Reading file: ");
    writestring(stdout, &txt);
    printf("...\n\n");
    if (listing) {
      fprintf(listfile, "* Reading file: ");
      writestring(listfile, &txt);
      fprintf(listfile, "...\n\n");
    }
  }
  if (pass1param->parvalue.len > 0) {
    passerr = pass1(&txt,&filename, stdout);
    if (passerr) {
      printf("Compilation terminated, input file did not exist\n");
      if (listing)
        fprintf(listfile,
                "Compilation terminated, input file did not exist\n");
      CANN_exit(1);
    }
  } else {   /*else*/
    /* if (source != NULL)
      rewind(source);
    else */

    /* source = tmpfile(); */
    source = fopen( CANN_source_file, "w+" );
    CANN_source = source;

    if (source == NULL)
      _EscIO(FileNotFound);
    passerr = pass1(&txt,&filename, source);
    if (!passerr) {
      rewind(source);
      parse(&directoryname);
      string20(&stampstr, " Livermore Frontend ");
      string10(&versionstr, "   Version");
      string10(&versionnum, version);
      if (stampstr.len < maxstringchars)
        insertstring(&stampstr, &versionstr, stampstr.len + 1);
      if (stampstr.len < maxstringchars)
        insertstring(&stampstr, &versionnum, stampstr.len + 1);
      addstamp('F', stampstr);
      if (semerrcnt == 0)
        passerr = backend();
      else {
        printf("Due to semantic errors the optimization and offset ");
        printf("passes were skipped.\n");
        if (listing) {
          fprintf(listfile, "Due to semantic errors the optimization and ");
          fprintf(listfile, "offset passes were skipped.\n");
        }
      }
      dumpmodule();
      if (!passerr)   /* Backend returns true if all is well */
        CANN_exit(1);
    } else {
      printf("Compilation terminated, input file did not exist\n");
      if (listing)
        fprintf(listfile,
                "Compilation terminated, input file did not exist\n");
      CANN_exit(1);
    }
  }
  /* if (source != NULL)
    fclose(source); */
  /* FIXED BY CANN_exit 1/92 */
  /* if ( source != NULL ) { 
    fclose(source);
    sprintf(dummystring, "rm %s", dummyfilename);
    system(dummystring);
    } */

  if (diag != NULL)
    fclose(diag);
  if (ptableout != NULL)
    fclose(ptableout);
  if (etableout != NULL)
    fclose(etableout);
  if (inputfile != NULL)
    fclose(inputfile);
  if (reservedwords != NULL)
    fclose(reservedwords);
  if (listfile != NULL)
    fclose(listfile);
  CANN_exit(0);

/* p2c: mono.bin.noblank.p, line 25405:
 * Note: REWRITE does not specify a name [181] */
  return 0;
}



/* End. */
