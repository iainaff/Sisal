
/* Header file for code generated by "p2c", the Pascal-to-C translator */

/* "p2c"  Copyright (C) 1989 Dave Gillespie, version 1.16.
 * This file may be copied, modified, etc. in any way.  It is not restricted
 * by the licence agreement accompanying p2c itself.
 */


#include "sisalInfo.h"

/* CANN 1/92 TO ALLOW FOR BIGGER LINE BUFFERS */
/* #define short int */
#define SHORT int


/* #ifdef M_XENIX  */ /* CANN 3/92 */ /* avoid compiler bug */
# define SHORT_MAX  (32767)
# define SHORT_MIN  (-32768)
/* #endif */


/* The following definitions work only on twos-complement machines */
#ifndef SHORT_MAX
# define SHORT_MAX  (((unsigned SHORT) -1) >> 1)
# define SHORT_MIN  (~SHORT_MAX)
#endif

#ifndef INT_MAX
# define INT_MAX    (((unsigned int) -1) >> 1)
# define INT_MIN    (~INT_MAX)
#endif

#ifndef LONG_MAX
# define LONG_MAX   (((unsigned long) -1) >> 1)
# define LONG_MIN   (~LONG_MAX)
#endif

#ifndef SEEK_SET
# define SEEK_SET   0
# define SEEK_CUR   1
# define SEEK_END   2
#endif

#ifndef EXIT_SUCCESS
# define EXIT_SUCCESS  0
# define EXIT_FAILURE  1
#endif


#define SETBITS  32


# define Signed
# define Void       void
# ifndef Const
#  define Const
# endif
# ifndef Volatile
#  define Volatile
# endif

typedef void *Anyptr;

# define Inline

#define Register    register  /* Register variables */
#define Char        char      /* Characters (not bytes) */

#ifndef Static
# define Static
#endif

#ifndef Local
# define Local
#endif

typedef Signed   char schar;
/* typedef unsigned char unchar;*/ /* CANN TYPE CHANGE 1/92 FOR LONGER LINES */
/* typedef unsigned int unchar;*/
typedef unsigned char boolean;

#ifndef true
# define true    1
# define false   0
#endif


typedef struct {
    Anyptr proc, link;
} _PROCEDURE;

#ifndef _FNSIZE
# define _FNSIZE  120
#endif


extern void    PASCAL_MAIN  PROTO( (int, Char **) );
extern Char    **P_argv;
extern int     P_argc;
extern SHORT   P_escapecode;
extern int     P_ioresult;
extern Void CANN_exit(int);


/* extern Anyptr   malloc      PROTO( (size_t) ); */
/* extern void     free        PROTO( (Anyptr) ); */

/* extern int      _OutMem     PROTO((void)); */
extern Anyptr   _OutMem     PROTO((void));

extern int      _CaseCheck  PROTO((void));
extern int      _NilCheck   PROTO((void));
extern int	_Escape     PROTO( (int) );
extern int	_EscIO      PROTO( (int) );

extern long     ipow        PROTO( (long, long) );
extern Char    *strsub      PROTO( (Char *, Char *, int, int) );
extern Char    *strltrim    PROTO( (Char *) );
extern Char    *strrtrim    PROTO( (Char *) );
extern Char    *strrpt      PROTO( (Char *, Char *, int) );
extern Char    *strpad      PROTO( (Char *, Char *, int, int) );
extern int      strpos2     PROTO( (Char *, Char *, int) );
extern long     memavail    PROTO((void));
extern int      P_peek      PROTO( (FILE *) );
extern int      P_eof       PROTO( (FILE *) );
extern int      P_eoln      PROTO( (FILE *) );
extern void     P_readpaoc  PROTO( (FILE *, Char *, int) );
extern void     P_readlnpaoc PROTO( (FILE *, Char *, int) );
extern long     P_maxpos    PROTO( (FILE *) );
extern Char    *P_trimname  PROTO( (Char *, int) );
extern long    *P_setunion  PROTO( (long *, long *, long *) );
extern long    *P_setint    PROTO( (long *, long *, long *) );
extern long    *P_setdiff   PROTO( (long *, long *, long *) );
extern long    *P_setxor    PROTO( (long *, long *, long *) );
extern int      P_inset     PROTO( (unsigned, long *) );
extern int      P_setequal  PROTO( (long *, long *) );
extern int      P_subset    PROTO( (long *, long *) );
extern long    *P_addset    PROTO( (long *, unsigned) );
extern long    *P_addsetr   PROTO( (long *, unsigned, unsigned) );
extern long    *P_remset    PROTO( (long *, unsigned) );
extern long    *P_setcpy    PROTO( (long *, long *) );
extern long    *P_expset    PROTO( (long *, long) );
extern long     P_packset   PROTO( (long *) );
extern int      P_getcmdline PROTO( (int l, int h, Char *line) );
extern void     TimeStamp   PROTO( (int *Day, int *Month, int *Year,
				 int *Hour, int *Min, int *Sec) );
extern void	P_sun_argv  PROTO( (char *, int, int) );


/* I/O error handling */
#define _CHKIO(cond,ior,val,def)  ((cond) ? P_ioresult=0,(val)  \
					  : P_ioresult=(ior),(def))
#define _SETIO(cond,ior)          (P_ioresult = (cond) ? 0 : (ior))

/* Following defines are suitable for the HP Pascal operating system */
#define FileNotFound     10
#define FileNotOpen      13
#define FileWriteError   38
#define BadInputFormat   14
#define EndOfFile        30

extern Anyptr __MallocTemp__;
# define Malloc(n)  ((__MallocTemp__ = calloc(n,1)) ? __MallocTemp__ : (Anyptr)_OutMem())

/* #define FreeR(p)    (free((Anyptr)(p))) */    /* used if arg is an rvalue */
/* #define Free(p)     (free((Anyptr)(p)), (p)=NULL) */
#define MyFree(p)     (free((Anyptr)(p)), (p)=NULL)
#define Free(p)     ((p)=NULL)

/* sign extension */
#define SEXT(x,n)   ((x) | -(((x) & (1L<<((n)-1))) << 1))

/* packed arrays */   /* BEWARE: these are untested! */
#define P_getbits_UB(a,i,n,L)   ((int)((a)[(i)>>((L)-(n))] >> (((~(i))&((1<<((L)-(n)))-1)) << (n)) & ((1<<(1<<(n)))-1)))

#define P_getbits_SB(a,i,n,L)   ((int)((a)[(i)>>((L)-(n))] <<   \
				       (16 - ((((~(i))&((1<<((L)-(n)))-1))+1) <<\
					      (n)) >> (16-(1<<(n))))))

#define P_putbits_UB(a,i,x,n,L) ((a)[(i)>>((L)-(n))] |=   \
				 (x) << (((~(i))&((1<<((L)-(n)))-1)) << (n)))

#define P_putbits_SB(a,i,x,n,L) ((a)[(i)>>((L)-(n))] |=   \
				 ((x) & (1<<(1<<(n)))-1) <<   \
				 (((~(i))&((1<<((L)-(n)))-1)) << (n)))

#define P_clrbits_B(a,i,n,L)    ((a)[(i)>>((L)-(n))] &=   \
				 ~( ((1<<(1<<(n)))-1) <<   \
				   (((~(i))&((1<<((L)-(n)))-1)) << (n))) )

/* small packed arrays */
#define P_getbits_US(v,i,n)     ((int)((v) >> ((i)<<(n)) & (1<<(1<<(n)))-1))
#define P_getbits_SS(v,i,n)     ((int)((long)(v) << (SETBITS - (((i)+1) << (n))) >> (SETBITS-(1<<(n)))))
#define P_putbits_US(v,i,x,n)   ((v) |= (x) << ((i) << (n)))
#define P_putbits_SS(v,i,x,n)   ((v) |= ((x) & (1<<(1<<(n)))-1) << ((i)<<(n)))
#define P_clrbits_S(v,i,n)      ((v) &= ~( ((1<<(1<<(n)))-1) << ((i)<<(n)) ))

#define P_max(a,b)   ((a) > (b) ? (a) : (b))
#define P_min(a,b)   ((a) < (b) ? (a) : (b))


/* Fix toupper/tolower on Suns and other stupid BSD systems */
#ifdef toupper
# undef toupper
# undef tolower
# define toupper(c)   my_toupper(c)
# define tolower(c)   my_tolower(c)
#endif

#ifndef z_toupper
# if 'A' == 65 && 'a' == 97
#  define z_toupper(c)  ((c)-'a'+'A')
#  define z_tolower(c)  ((c)-'A'+'a')
# else
#  define z_toupper(c)  toupper(c)
#  define z_tolower(c)  tolower(c)
# endif
#endif


#ifdef LINUX
/* Fix things on Linux */
#ifdef islower
#undef islower
#endif
#define islower(c) ((c) >= 'a' && (c) <= 'z')
#ifdef isupper
#undef isupper
#endif
#define isupper(c) ((c) >= 'A' && (c) <= 'Z')
#ifdef isspace
#undef isspace
#endif
#define isspace(c) ((c) == ' ')
#ifdef isdigit
#undef isdigit
#endif
#define isdigit(c) ((c) >= '0' && (c) <= '9')

#endif
